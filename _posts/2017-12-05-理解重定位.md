---
layout:     post
title:      理解重定位
date:       2017-12-05
summary:    理解重定位
categories: 二进制
tags:
 - 重定位
---

### 0x00 必读link

1.[Linux动态链接为什么要用PLT和GOT表][1]

2.[共享库加载时重定位][2]

3.[共享库中的PIC][3]

### 0x01 预备知识

1.硬件对变量和函数的寻址方式不同,寻找变量要求绝对地址,寻找函数要求相对地址.

call指令的偏移量计算方法:偏移量=跳转到的地址-call指令后一条指令的起始地址

```
00413766    e8 7a da ff ff      call 00411e5
0041376b    ...                 ...

e8代表call,7a da ff ff代表偏移量0xffffda7a,对应负数-0x2586,0x0041376b+(-0x2586)=0x00411e5
```

3.程序由编译(成汇编代码),链接(组合.o文件)得到可执行文件,重定位有链接时重定位+运行时重定位(上面必读link中叫load-time
relocate),运行时重定位完成后得到的地址是虚拟存储器的虚拟地址,实际与内存交互时,需要由内核再完成虚拟存储器的虚拟
地址到真实物理内存地址的转换.

4.编译阶段,.o文件的全局变量位置不确定,因为这时无法确定还有其它哪些.o文件,以及链接器将来会按什么顺序"排列"这些.o文
件,所以编译阶段没有重定位,链接阶段,如果elf没有调用so中的符号,则可以在链接时重定位所有符号的地址(因为这时所有的.o
文件的数据段代码段都组合完成了,所有符号的偏移都是确定的),如果elf调用了so中的符号,则由于so文件的符号位置不确定,因为
这时不知道.so文件将来被加载到进程空间的什么位置,所以与so中符号有关的地址需要运行时重定位.

5.在没有aslr和pie的情况下:elf如果没有调用so中的符号则不用运行时重定位,so则一般必然发生运行时重定位

6.一般情况下,exe的期望加载基址为0x400000(4M),dll为0x1000000(16M),elf为0x8000000(128M),so为0x40000000(1G),期望加载
基址由编译器指定,在可执行文件中有一个位置存放这个值

7.pie的什么用是什么?pic和pie是什么,有什么关系?

### 0x02 实例跟踪重定位过程


[1]: https://www.zhihu.com/question/21249496
[2]: https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/
[3]: https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/
