---
layout:     post
title:      理解重定位
date:       2017-12-05
summary:    理解重定位
categories: 二进制
tags:
 - 重定位
---

### 0x00 必读link

1.<<程序员的自我修养>> 4.2和7.3.2章节

2.[Linux动态链接为什么要用PLT和GOT表][1]

3.[共享库加载时重定位][2]

4.[pie/pic/aslr的理解][4]

5.[共享库中的PIC][3]

### 0x01 预备知识

1.硬件对变量和函数的寻址方式不同,寻找变量要求绝对地址,寻找函数要求相对地址.

call指令的偏移量计算方法:偏移量=跳转到的地址-call指令后一条指令的起始地址

```
00413766    e8 7a da ff ff      call 00411e5
0041376b    ...                 ...

e8代表call,7a da ff ff代表偏移量0xffffda7a,对应负数-0x2586,0x0041376b+(-0x2586)=0x00411e5
```

3.程序由编译(成汇编代码),链接(组合.o文件)得到可执行文件,重定位有链接时重定位+装载时重定位(上面必读link中叫load time
relocate),装载时重定位完成后得到的地址是虚拟存储器的虚拟地址,实际与内存交互时,需要由内核再完成虚拟存储器的虚拟
地址到真实物理内存地址的转换.

4.编译阶段,.o文件的全局变量位置不确定,因为这时无法确定还有其它哪些.o文件,以及链接器将来会按什么顺序"排列"这些.o文
件,所以编译阶段没有重定位,链接阶段,如果elf没有调用so中的符号,则可以在链接时重定位所有符号的地址(因为这时所有的.o
文件的数据段代码段都组合完成了,所有符号的偏移都是确定的),如果elf调用了so中的符号,则由于so文件的符号位置不确定,因为
这时不知道.so文件将来被加载到进程空间的什么位置,所以与so中符号有关的地址需要装载时重定位.

5.在没有开启pie的情况下:elf如果没有调用so则不用装载时重定位.elf如果没有调用so则没有plt表(有got表).so(elf)通过
plt+got来实现pic(pie)

6.一般情况下,exe的期望加载基址为0x400000(4M),dll为0x1000000(16M),elf为0x8000000(128M),so为0x40000000(1G),期望加载
基址由编译器指定,在可执行文件中有一个位置存放这个值

7.查看elf有没有开pie可简单通过readelf -l elffile看出,对应如下

```
Elf 文件类型为 DYN (共享目标文件)       ===>对应开启了pie
Elf 文件类型为 EXEC (可执行文件)        ===>对应未开启pie
```

8.plt和got示例(linux下这样叫,macOS下有其他名字)

如下图中printf函数是外部so文件中的函数,于是需要有plt和got,从左边的printf,puts,atoi等函数看出,一般只有外部so文件中
的函数调用才会用到plt,在下图ida中,发现plt段在.init段之后,.text段之前

<img src="https://raw.githubusercontent.com/3xp10it/pic/master/reloc1.png">

printf函数的plt表中内容如下:

```
.plt:080483C0
.plt:080483C0 ; =============== S U B R O U T I N E =======================================
.plt:080483C0
.plt:080483C0 ; Attributes: thunk
.plt:080483C0
.plt:080483C0 ; int printf(const char *format, ...)
.plt:080483C0 _printf         proc near               ; CODE XREF: main+2C↓p
.plt:080483C0
.plt:080483C0 format          = dword ptr  4
.plt:080483C0
.plt:080483C0                 jmp     ds:off_804A000
.plt:080483C0 _printf         endp
.plt:080483C0
```

printf函数对应的got表中内容如下:

<img src="https://raw.githubusercontent.com/3xp10it/pic/master/reloc2.png">

上图中的got表被ida解析了,ida指出0x804A000处的内容是printf函数的偏移,实际在16进制模式下的内容如下图:

<img src="https://raw.githubusercontent.com/3xp10it/pic/master/reloc3.png">

也即在0x804A000这个地址中的值为0x804A030,也即got表中对应内容如下:

```
0x804A000:0x804A030
```

这个0x804A030在运行后会被因为重定位被修改成其他值,因为实际运行时printf函数的地址应该会变成不再是0x404A030了


### 0x02 链接时重定位

如果没涉及so函数调用,则只通过链接时重定位即可完成重定位,不需要装载时重定位,由链接器单独完成重定位,下面进入操作

```
works in x86 kali linux

vi a.c

    /* a.c */
    extern int shared;

    int main()
    {
        int a = 100;
        swap(&a,&shared);
    }

vi b.c

    /* b.c */
    int shared = 1;

    void swap(int* a,int* b)
    {
        *a ^= *b ^= *a ^= *b;
    }

gcc -c a.c b.c 
    编译得到a.o和b.o目标文件

ld a.o b.o -e main -o ab
    链接a.o和b.o,设置输出文件为ab,设置main函数为入口


objdump -h a.o

objdump -h a.o
    a.o：     文件格式 elf32-i386

    节：
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         0000004a  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000000  00000000  00000000  00000086  2**0
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000086  2**0

objdump -h b.o
    b.o：     文件格式 elf32-i386

    节：
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         00000043  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000004  00000000  00000000  00000080  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000084  2**0

objdump -h ab
    ab：     文件格式 elf32-i386

    节：
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .text         00000091  08048094  08048094  00000094  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
      1 .eh_frame     00000080  08048128  08048128  00000128  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
      2 .got.plt      0000000c  0804a000  0804a000  00001000  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .data         00000004  0804a00c  0804a00c  0000100c  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      4 .comment      00000026  00000000  00000000  00001010  2**0

      VMA表示虚拟存储器的虚拟地址,由上可以看出,在链接之前,所有段的VMA都是0,在链接后出现了got表.且got表中的内容全
      为0,如下:
            .got.plt:0804A000 ; ===========================================================================
            .got.plt:0804A000
            .got.plt:0804A000 ; Segment type: Pure data
            .got.plt:0804A000 ; Segment permissions: Read/Write
            .got.plt:0804A000 _got_plt        segment dword public 'DATA' use32
            .got.plt:0804A000                 assume cs:_got_plt
            .got.plt:0804A000                 ;org 804A000h
            .got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd 0              ; DATA XREF: LOAD:0804805C↑o
            .got.plt:0804A000                                         ; swap+10↑r ...
            .got.plt:0804A004                 db    0
            .got.plt:0804A005                 db    0
            .got.plt:0804A006                 db    0
            .got.plt:0804A007                 db    0
            .got.plt:0804A008                 db    0
            .got.plt:0804A009                 db    0
            .got.plt:0804A00A                 db    0
            .got.plt:0804A00B                 db    0
            .got.plt:0804A00B _got_plt        ends
            .got.plt:0804A00B
            .data:0804A00C ; ===========================================================================
      如果在链接前就产生了got表的话,可以通过在编译时直接在需要重定位的地方写上got表项的地址中的指针指向的值来达到
      plt表的功能,如:
      mov var,[[0x0804A000]]   
      其中0x0804A000是一个got表项的地址.这样的话(在链接前就产生了got表)就可以省去plt表了,因为plt表的作用就是找到
      got表中的地址.当然这里的elf文件ab没有plt表,因为不涉及so文件中符号的使用.

objdump -d a.o
    a.o：     文件格式 elf32-i386
    Disassembly of section .text:
    00000000 <main>:
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	e8 fc ff ff ff       	call   13 <main+0x13>
      17:	05 01 00 00 00       	add    $0x1,%eax
      1c:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
      23:	83 ec 08             	sub    $0x8,%esp
      26:	8b 90 00 00 00 00    	mov    0x0(%eax),%edx   ===>shared变量
      2c:	52                   	push   %edx
      2d:	8d 55 f4             	lea    -0xc(%ebp),%edx
      30:	52                   	push   %edx
      31:	89 c3                	mov    %eax,%ebx
      33:	e8 fc ff ff ff       	call   34 <main+0x34>   ===>swap函数
      38:	83 c4 10             	add    $0x10,%esp
      3b:	b8 00 00 00 00       	mov    $0x0,%eax
      40:	8d 65 f8             	lea    -0x8(%ebp),%esp
      43:	59                   	pop    %ecx
      44:	5b                   	pop    %ebx
      45:	5d                   	pop    %ebp
      46:	8d 61 fc             	lea    -0x4(%ecx),%esp
      49:	c3                   	ret    

      如上反汇编代码中,在a.c编译成a.o时,编译器不知道shared变量和swap函数的地址,因为它们定义在其他目标文件中
      (b.o),所以编译器就暂时把地址0看作是shared的地址,同样将call指令的目标地址的位置当作call的目标地址
      (0xfffffffc=-4,0x38-0x4=0x34,相当于call自己),也即在编译阶段,编译器把这两个待重定位的值分别写成0x00000000和
      0xfffffffc,把真正的地址计算工作留给了链接器,链接器在完成地址和空间分配之后就已经可以确定所有符号的虚拟地址
      了(因为这里未涉及so的调用),那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正.

objdump -d ab
    ab：     文件格式 elf32-i386
    Disassembly of section .text:

    08048094 <main>:
     8048094:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     8048098:	83 e4 f0             	and    $0xfffffff0,%esp
     804809b:	ff 71 fc             	pushl  -0x4(%ecx)
     804809e:	55                   	push   %ebp
     804809f:	89 e5                	mov    %esp,%ebp
     80480a1:	53                   	push   %ebx
     80480a2:	51                   	push   %ecx
     80480a3:	83 ec 10             	sub    $0x10,%esp
     80480a6:	e8 33 00 00 00       	call   80480de <__x86.get_pc_thunk.ax>
     80480ab:	05 55 1f 00 00       	add    $0x1f55,%eax
     80480b0:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
     80480b7:	83 ec 08             	sub    $0x8,%esp
     80480ba:	c7 c2 0c a0 04 08    	mov    $0x804a00c,%edx      ===>shared变量
     80480c0:	52                   	push   %edx
     80480c1:	8d 55 f4             	lea    -0xc(%ebp),%edx
     80480c4:	52                   	push   %edx
     80480c5:	89 c3                	mov    %eax,%ebx
     80480c7:	e8 16 00 00 00       	call   80480e2 <swap>       ===>swap函数
     80480cc:	83 c4 10             	add    $0x10,%esp
     80480cf:	b8 00 00 00 00       	mov    $0x0,%eax
     80480d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
     80480d7:	59                   	pop    %ecx
     80480d8:	5b                   	pop    %ebx
     80480d9:	5d                   	pop    %ebp
     80480da:	8d 61 fc             	lea    -0x4(%ecx),%esp
     80480dd:	c3                   	ret    

     由ab文件的反汇编代码可以看出,经过链接阶段的修正后,shared变量和swap函数的地址分别为0x804a00c和0x00000016.
     链接器通过重定位表来对shared和swap的地址重定位,对于每个要重定位的elf段都有一个对应的重定位段(重定位表),比如
     代码段.text如有要重定位的地方,那么会有一个相应叫.rel.text的段保存了代码段的重定位表,如果代码段.data有要重定
     位的地方,那么会有一个相应叫.rel.data的段保存了数据段的重定位表,可以通过objdump -r查看目标文件的重定位表

objdump -r a.o
    a.o：     文件格式 elf32-i386
    RELOCATION RECORDS FOR [.text]:
    OFFSET   TYPE              VALUE 
    00000013 R_386_PC32        __x86.get_pc_thunk.ax
    00000018 R_386_GOTPC       _GLOBAL_OFFSET_TABLE_
    00000028 R_386_GOT32X      shared
    00000034 R_386_PLT32       swap

    由上看出shared和swap是不同的重定位类型,下面是不同重定位类型的不同计算重定位值的方法.
    容易想到,变量和函数的计算重定位值的算法是不同的,因为函数一般用相对地址,变量用绝对地址.
```

<img src="https://raw.githubusercontent.com/3xp10it/pic/master/reloc4.png">

```


```

### 0x03 装载时重定位






[1]: https://www.zhihu.com/question/21249496
[2]: https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/
[3]: https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/
[4]: https://zhuanlan.zhihu.com/p/24231428
