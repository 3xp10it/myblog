---
layout:     post
title:      漏洞战争-cve-2013-2551
date:       2016-12-27
summary:    漏洞战争-cve-2013-2551
categories: 二进制
tags:
 - 漏洞分析
 - 整数溢出
---

### 0x00 About

```
漏洞源:vgx.dll在处理<v:stroke>标签的dashstyle.array.length属性时,没有对传入的参数进行完备验证而导致整数溢出
调试环境:
    win7
good knowledge:
    http://www.isclab.org.cn/archives/2014/11/2830.html
    http://www.voidcn.com/blog/tony_whu/article/p-4307461.html
```

### 0x01 分析

```
poc中关键处为:
    vml1.dashstyle="1 2 3 4 ... 44"
    vml1.dashstyle.array.length=0-1
    shape.dashstyle.array.length=0-1
也即在设置dashstyle.array.length时,由原来的44变成了-1,这样导致了整数溢出漏洞,产生了数组越界访问的读写能力,而
COARuntimeStyle对象偏移0x58处为可控字符串指针,可以将可控字符串设置成AAAAAA,书中poc中为:a[i].marginLeft="a"
这样就可以通过动态调试中找到内存中AAAAAA与模块基址的偏移量,从而由AAAAAA的内存地址减去该偏移量得到aslr下的模块的
基址,由此基址可通过heap spray构造rop gadgets绕过dep+aslr,然后再次利用数组越界访问的读写能力改写对象的虚表指针就
可以控制eip了

通过poc分析这个整数溢出漏洞的溢出细节可这样实现:
1)找到poc中关键的代码:vml1.dashstyle.array.length=0-1
2)通过ida中的"Functions Windows"中按"alt+t"组合键找到1)中对应的dll中的对应类的函数:
    vgx.dll中的COALineDashStyleArray类中的put_length函数
3)windbg中bu vgx!COALineDashStyleArray::put_length
4)单步调试分析汇编指令(细心活):
    分析得到导致整数溢出的关键点在
        mov esi,dword ptr [ebp+0Ch] ss:0023:040fa190=ffffffff  //获取到dashstyle数组长度值0xFFFFFFFF
        cmp eax,esi //与poc中原来设置的dashstyle数组长度0x2C做比较,大于等于则跳转
        jge vgx!COALineDashStyleArray::put_length+0xca处 //口诀:AB无符号,GL有符号,此处为g(有符号比较),导致漏洞
        的产生

```
