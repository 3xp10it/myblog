---
layout:     post
title:      深入理解计算机系统第12章笔记
date:       2017-10-24
summary:    深入理解计算机系统第12章笔记
categories: auxilary
tags:
 - csapp
---

### 并发编程

1.I/O多路复用:多路复用是指使用一个线程来检查多个描述符(socket)的就绪状态,比如调用select和poll函数,传入多个文件描
述符,如果有一个文件描述符就绪,则返回,否则阻塞直到超时.得到就绪状态后进行真正的操作可以在同一个线程里执行,也可以启
动线程执行(比如使用线程池),[必读理解][1]

2.现代操作系统提供了三种基本的构造并发程序的方法:`进程`,`I/O多路复用`,`线程`.

3.select实现I/O多路复用用法示例 [1][2],[2][3]

4.信号量:线程的信号量与进程间通信中使用的信号量的概念是一样,它是一种特殊的变量,它可以被增加或减少,但对其的关键
访问被保证是原子操作.如果一个程序中有多个线程试图改变一个信号量的值,系统将保证所有的操作都将依次进行.

5.信号量与互斥量的[理解1][5],[理解2][4]

6.每个线程都有它自己独立的线程上下文,包括线程ID,栈,栈指针,程序计数器,条件码和通用目的寄存器值.每个线程和其他线程
一起共享进程上下文的剩余部分,这包括整个用户虚拟地址空间,它是由只读文本(代码),读/写数据,堆以及所有的共享库代码和数
据区域组成的.线程也共享同样的打开的文件的集合.寄存器是从不共享的,而虚拟存储器总是共享的.

7.如果一个线程以某种方式得到一个指向其他线程栈的指针,那么它就可以读写这个栈的任何部分.

8.互斥锁的[理解][6]

9.如果线程不安全函数是难以修改或不可能修改的(例如,代码非常复杂或是没有源代码可用),那么另外一种选择就是使用`加锁-
拷贝`技术.基本思想是将线程不安全函数与互斥锁联系起来.在每一个调用位置,对互斥锁加锁,调用线程不安全函数,将函数返回
的结果拷贝到一个私有的存储器位置,然后对互斥锁解锁.

10.死锁:死锁(Deadlock)就是一个进程拿着资源A请求资源B,另一个进程拿着资源B请求资源A,双方都不释放自己的资源,导致
两个进程都进行不下去.[理解][7]


[1]: https://www.zhihu.com/question/28594409
[2]: http://www.jb51.net/article/111899.htm
[3]: https://www.chengxulvtu.com/2017/10/10/以python理解linux的io多路复用,select、poll、epoll.html
[4]: http://blog.csdn.net/bao_qibiao/article/details/4516196
[5]: https://www.zhihu.com/question/47411729
[6]: https://yq.aliyun.com/articles/5690
[7]: http://www.jianshu.com/p/0494ab7c96f9
