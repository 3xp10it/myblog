<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 30 Oct 2017 07:34:06 +0800</pubDate>
    <lastBuildDate>Mon, 30 Oct 2017 07:34:06 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>深入理解计算机系统第12章笔记</title>
        <description>&lt;h3 id=&quot;并发编程&quot;&gt;并发编程&lt;/h3&gt;

&lt;p&gt;1.I/O多路复用:多路复用是指使用一个线程来检查多个描述符(socket)的就绪状态,比如调用select和poll函数,传入多个文件描
述符,如果有一个文件描述符就绪,则返回,否则阻塞直到超时.得到就绪状态后进行真正的操作可以在同一个线程里执行,也可以启
动线程执行(比如使用线程池),&lt;a href=&quot;https://www.zhihu.com/question/28594409&quot;&gt;必读理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.现代操作系统提供了三种基本的构造并发程序的方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;进程&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O多路复用&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;线程&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;3.select实现I/O多路复用用法示例 1&lt;a href=&quot;http://www.jb51.net/article/111899.htm&quot;&gt;2&lt;/a&gt;,2&lt;a href=&quot;https://www.chengxulvtu.com/2017/10/10/以python理解linux的io多路复用，select、poll、epoll.html&quot;&gt;3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;/p&gt;

</description>
        <pubDate>Tue, 24 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC12%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC12%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>git当svn用</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.git pull相当于svn update
2.git push相当于svn commit
3.git有本地仓库,svn没有本地仓库,上面git push前要git commit -a -m 到本地仓库
4.git多人协作  https://gist.github.com/suziewong/4378619
5.同一个github帐号多台不同电脑时可用下面代码方便同步数据
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 每天第1次接触电脑时运行py3 gitTool.py --update
# 每天第-1次接触电脑时运行py3 gitTool.py --commit

import sys
import os
dirList = [&quot;~/myblog/&quot;, &quot;~/3xp10it.github.io/&quot;,
           &quot;~/mypypi/&quot;, &quot;/usr/share/mytools&quot;]
if sys.argv[1] == &quot;--update&quot;:
    for eachDir in dirList:
        os.system(&quot;cd %s &amp;amp;&amp;amp; git pull&quot; % eachDir)
if sys.argv[1] == &quot;--commit&quot;:
    os.system(&quot;bash /usr/share/mytools/up.sh&quot;)
    for eachDir in dirList:
        os.system(
            &quot;cd %s &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -a -m 'up' &amp;amp;&amp;amp; git push -u origin master&quot; % eachDir)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/10/21/git%E5%BD%93svn%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/10/21/git%E5%BD%93svn%E7%94%A8/</guid>
        
        <category>git</category>
        
        <category>svn</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第11章笔记</title>
        <description>&lt;h3 id=&quot;网络编程&quot;&gt;网络编程&lt;/h3&gt;

&lt;p&gt;1.认识到客户端和服务器是进程,而不是常常提到的机器或主机,这是很重要的.无论客户端和服务器是怎样映射到主机上的,客户
端-服务器模型是相同的.&lt;/p&gt;

&lt;p&gt;2.因为因特网主机可以有不同的主机字节顺序,TCP/IP为任意整数数据项定义了统一的网络字节顺序(大端字节顺序),例如IP地址.
htonl函数将32位整数由主机字节顺序转换为网络字节顺序,ntohl函数将32位整数从网络字节顺序转换为主机字节,htons和ntohs
函数为16位的整数执行相应的转换.(不同的CPU有不同的字节序类型,这些字节序是指整数在内存中保存的顺序,这个叫做主机序
),网络程序使用inet_aton和inet_ntoa函数来实现IP地址和点分十进制之间的转换.&lt;a href=&quot;http://blog.csdn.net/fan_hai_ping/article/details/8435140&quot;&gt;以上python版本&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.linux中&lt;code class=&quot;highlighter-rouge&quot;&gt;hostname -I&lt;/code&gt;可得到ip地址&lt;/p&gt;

&lt;p&gt;4.一旦一个组织得到了一个二级域名,那么它就可以在这个子域中创建任何新的域名了,从数学意义上讲,可以认为每条主机条目就
是一个域名和IP地址的等价类&lt;/p&gt;

&lt;p&gt;5.每台主机都有本地定义的域名localhost,这个域名总是映射为本地回送地址(loopback address)127.0.0.1&lt;/p&gt;

&lt;p&gt;6.在unix机器上,文件/etc/services包含一张这台机器提供的服务以及它们的知名端口号的综合列表&lt;/p&gt;

&lt;p&gt;7.socket连接中监听描述符和已连接描述符之间的区别使很多人感到迷惑,监听描述符是作为客户端连接请求的一个端点.它被创
建一次,并存在于服务器的整个生命周期.已连接描述符是客户端和服务器之间已经建立起来了的连接的一个端点,服务器每次接受
连接请求时都会创建一次,它只存在于服务器为一个客户端服务的过程中.图11-18展示了监听描述符和已连接描述符的关系,其中
的3和4表示描述符值(0~2描述符是预留给标准文件的)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp11-1.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp11-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8.内核在一个进程终止时会自动关闭所有打开的描述符&lt;/p&gt;

&lt;p&gt;9.http请求头中的host字段在HTTP/1.1请求中是需要的,而在HTTP/1.0请求中是不需要的.代理缓存(proxy cache)会使用host字段
,这个代理缓存有时作为浏览器和管理被请求文件的原始服务器(origin server)的中介[这里的1.1和1.0的区别可能可以成为绕过
waf和漏洞挖掘的思路]&lt;/p&gt;

&lt;p&gt;10.图11-24是一些http状态码
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp11-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11.&lt;a href=&quot;https://www.awaimai.com/371.html&quot;&gt;cgi理解&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 17 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC11%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/10/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC11%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第10章笔记</title>
        <description>&lt;h3 id=&quot;系统级io&quot;&gt;系统级I/O&lt;/h3&gt;

&lt;p&gt;1.输入/输出(I/O)是在主存和外部设备(如磁盘驱动器,终端和网络)之间拷贝数据的过程.输入操作是从I/O设备拷贝数据到主存,
而输出操作是从主存拷贝数据到I/O设备.I/O函数如&lt;code class=&quot;highlighter-rouge&quot;&gt;printf,scanf,&amp;lt;&amp;lt;,&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.所有的I/O设备,如网络,磁盘和终端,都被模型化为文件,而所有的输入和输出都被当做对相应文件的读和写来执行.这种将设备
优雅地映射为文件的方式,允许unix内核引出一个简单,低级的应用接口,称为unix I/O,这种使得所有的输入和输出都能以一种统
一且一致的方式来执行:打开文件,改变当前的文件位置,读写文件,关闭文件.&lt;/p&gt;

&lt;p&gt;3.stat函数以一个文件名作为输入,并填写如图10-8所示的一个stat数据结构中的各个成员.其中&lt;code class=&quot;highlighter-rouge&quot;&gt;st_size&lt;/code&gt;成员包含了文件的字节
数大小,&lt;code class=&quot;highlighter-rouge&quot;&gt;st_mode&lt;/code&gt;成员则编码了文件访问许可位和文件类型.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp10-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;code class=&quot;highlighter-rouge&quot;&gt;描述符表&lt;/code&gt;:每个进程都有它独立的描述符表,它的表项是由进程打开的文件描述符来索引的.每个打开的描述符表项指向文件表中
的一个表项.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;文件表&lt;/code&gt;:打开文件的集合是由一张文件表来表示的,所有的进程共享表.每个文件表的表项组成包括有当前的文件位置,引用计数
(即当前指向该表项的描述符表项数),以及一个指向v-node表中对应表项的指针.关闭一个描述符会减少相应的文件表表项中的引
用计数.内核不会删除这个文件表表项,直到它的引用计数为零.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;v-node&lt;/code&gt;:同文件表一样,所有的进程共享这张v-node表.每个表项包含stat结构中的大多数信息,包括st_mode和st_size成员.&lt;/p&gt;

&lt;p&gt;每个描述符都有它自己的文件位置,所以对不同描述符的读操作可以从文件的不同位置获取数据.理解父子进程是如何共享文件的:
假设在调用fork之前,父进程有如图10-11所示的打开文件.然后,图10-13展示了调用fork后的情况.子进程有一个父进程描述符表
的副本.父子进程共享相同的打开文件表集合,因此共享相同的文件位置.一个很重要的结果就是,在内核删除相应文件表表项之前,
父子进程必须都关闭了它们的描述符.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp10-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.每个ANSI C程序开始时都有三个打开的流stdin,stdout,stderr,分别对应于标准输入(对应描述符0),标准输出(对应描述符1)和
标准错误(对应描述符2)&lt;/p&gt;

&lt;p&gt;6.ANSI C定义了一组高级输入输出函数,称为标准I/O库,为程序员提供了Unix I/O的较高级别的替代,这个库(libc)提供了打开和
关闭文件的函数(fopen和fclose),读和写字节的函数(fread和fwrite),读和写字符串的函数(fgets和fputs),以及复杂的格式化的
I/O函数(scanf和printf).应用程序可以通过open,close,lseek,read,write和stat这样的函数来访问Unix I/O.较高级别的RIO和
标准I/O函数都是基于(使用)Unix I/O函数来实现的.RIO函数是专为本书开发的read和write的健壮的包装函数,它们自动处理不足
值,并且为读文本行提供一种高效的带缓冲的方法.&lt;/p&gt;

&lt;p&gt;7.大多数C程序员在他们的职业生涯中只使用标准I/O,而从不涉及低级Unix I/O函数,不幸的是,当我们对网络输入输出使用标准
I/O时,它却带来了一些令人讨厌的问题,我们建议你在网络套接字上不要使用标准I/O函数来进行输入和输出,而要使用健壮的
RIO函数.&lt;/p&gt;

&lt;p&gt;8.标准I/O库是基于Unix I/O实现的,并提供了一组强大的高级I/O例程,对于大多数应用程序而言,标准I/O更简单,是优于Unix I/O
的选择,然而,因为对标准I/O和网络文件的一些相互不兼容的限制,Unix I/O比标准I/O更适用于网络应用程序.图10-15为Unix
I/O,标准I/O和RIO之间的关系.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp10-3.png&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 13 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC10%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/10/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC10%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第9章笔记</title>
        <description>&lt;h3 id=&quot;虚拟存储器&quot;&gt;虚拟存储器&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&quot;https://www.zhihu.com/question/21088377&quot;&gt;虚拟存储器的理解&lt;/a&gt;,windows下的c盘中的pagefile.sys是虚拟内存文件.&lt;/p&gt;

&lt;p&gt;2.虚拟存储器是硬件异常,硬件地址翻译,主存,磁盘文件和内核软件的完美交互,它为每个进程提供了一个大的,一致的私有的地址
空间.虚拟存储器提供了3个重要能力:&lt;br /&gt;
a)它将主存看成是一个存储在磁盘上的地址空间的高速缓存,在主存中只保存活动区域,并根据需要在磁盘和主存之间来回传送数
据,通过这种方式,它高效地使用了主存&lt;br /&gt;
b)它为每个进程提供了一致的地址空间,从而简化了存储器管理&lt;br /&gt;
c)它保护了每个进程的地址空间不被其他进程破坏&lt;/p&gt;

&lt;p&gt;3.地址翻译:将一个虚拟地址转换为物理地址.就像异常处理一样,地址翻译需要cpu硬件和操作系统之间的紧密合作.cpu芯片上叫
做存储器管理单元(MMU)的专用硬件,利用存放在主存中的查询表来动态翻译虚拟地址.如下图.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.主存中的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址&lt;/p&gt;

&lt;p&gt;5.磁盘上数组的内容被缓存在主存中.和存储器层次结构中其他缓存一样,磁盘(较低层)上的数据被分割成块,这些块作为磁盘和主
存(较高层)之间的传输单元.为了有助于清晰地去理解存储层次结构中不同的缓存概念,我们将使用术语SRAM缓存来表示位于CPU和
主存之间的L1,L2和L3调整缓存,并且用术语DRAM缓存来表示虚拟存储器系统的缓存,它在主存中缓存虚拟页&lt;/p&gt;

&lt;p&gt;6.虚拟存储器系统通过将虚拟存储器分割为称为虚拟页的大小固定的块来处理这个问题,如下图中的虚拟存储器有8个虚拟页.类似
地,物理存储器被分割为物理页,物理页和虚拟页大小相同,物理页也称为页帧.任意时刻,虚拟页面的集合都分为有一个不相交的子
集:&lt;br /&gt;
未分配的:虚拟存储器系统还未分配的页,未分配的块没有任何数据和它们相关联,因此也就不占用任何磁盘空间&lt;br /&gt;
缓存的:当前缓存在物理存储器中的已分配页&lt;br /&gt;
未缓存的:没有缓存在物理存储器中的已分配页(已分配代表占用磁盘空间)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7.Linux将随机存储RAM称为内存页.交换技术就是将一页内存复制到预先设定的硬盘上的交换空间,来释放该页占用内存.物理
内存和交换空间的和就是可提供的虚拟内存的总量.&lt;br /&gt;
windows:虚拟内存 
linux:swap分区 
windows即使物理内存没有用完也会去用到虚拟内存,而Linux不一样 Linux只有当物理内存用完的时候才会去动用虚拟内存(即
swap分区)&lt;br /&gt;
swap类似于windows的虚拟内存,不同之处在于,Windows可以设置在windows的任何盘符下面,默认是在C盘,可以和系统文件放
在一个分区里.而linux则是独立占用一个分区,方便由于内存需求不够的情况下,把一部分内容放在swap分区里,待内存有空余
的情况下再继续执行,也称之为交换分区,交换空间是其中的部分&lt;/p&gt;

&lt;p&gt;8.垃圾收集器是一种动态存储分配器,它自动释放程序不再需要的已分配块,这些块称为垃圾,自动回收堆存储的过程叫做垃圾收集
.在一个支持垃圾收集的系统中,应用显式分配堆块,但是从不显式地释放它们.在C程序的上下文中,应用调用malloc,但是从不调用
free.反之,垃圾收集器定期识别垃圾块,并相应地调用free,将这些块放回到空闲链表中.&lt;/p&gt;

&lt;p&gt;9.虚拟存储器是对主存的一个抽象,支持虚拟存储器的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存.专门的硬件通过
使用页表来翻译虚拟地址,而页表的内容是由操作系统提供的.&lt;/p&gt;

&lt;p&gt;10.分配器有两种类型.显式分配器要求应用显式地释放它们的存储器块,隐式分配器(垃圾收集器)自动释放任何未使用的和不可达
的块.&lt;/p&gt;

&lt;p&gt;11.页表是一个存放在物理存储器中的数据结构,页表将虚拟页映射到物理页,每次地址翻译硬件将一个虚拟地址转换为物理地址时
都会读取页表,页表是敷于脸上页表条目的数组,虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个PTE(page table
entry,页表条目).&lt;/p&gt;

&lt;p&gt;12.图9-4中的示例展示了一个有8个虚拟页和4个物理页的系统的页表.四个虚拟页(vp1,vp2,vp4,vp7)当前被缓存在DRAM中,两个页
(vp0,vp5)还未被分配,而剩下的页(vp3,vp6)已经被分配了,但是当前还未被缓存.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;13.缺页:在虚拟存储器的习惯说法中,DRAM缓存不命中称为缺页,图9-6展示了在缺页之前我们的示例页表的状态.cpu引用了vp3中
的一个字,vp3并未缓存在DRAM中,地址翻译硬件从存储器中读取PTE3,从有效位推断出vp3未被缓存,并且触发一个缺页异常.缺页异
常调用内核中的缺页异常处理程序,该程序会选择一个牺牲页,在紫剑中就是存放在pp3中的vp4,如果vp4已经被修改了,那么内核就
会将它拷贝加磁盘.当异常处理程序返回时,它会重新启动导致缺页的指令,该指令会把导致缺页的虚拟地址重发送到地址翻译硬件
.但是现在,vp3已经缓存在主存中了,那么页命中也能由地址翻译硬件正常处理了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;14.操作系统为每个进程提供了一个独立的页表,因而也就是一个独立的虚拟地址空间.&lt;/p&gt;

&lt;p&gt;15.地址翻译:图9-12展示了MMU如何利用页表来实现虚拟地址到物理地址的映射.cpu中的一个控制寄存器,页表基址寄存器
(PTBR)指向当前页表.n位的虚拟地址包含两个部分:一个p位的虚拟页面偏移(VPO)和一个(n-p)位的虚拟页号(VPN).MMU利用VPN来
选择适当的PTE.例如,VPN 0选择PTE 0,VPN 1选择PTE 1,以此类推.将页表条目中物理页号(PPN)和虚拟地址中的VPO串联起来,就得
到相应的物理地址.注意,因为物理和虚拟页面都是P字节的,所以物理页面偏移(PPO)和VPO是相同的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;16.linux为每个进程维持了一个单独的虚拟地址空间,形式如图9-26所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp9-6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;17.linux通过将一个虚拟存储器区域与一个磁盘上的对象关联起来,以初始化这个虚拟存储器区域的内容,这个过程称为存储器映
射.一旦一个虚拟页面被初始化了,它就在一个由内核维护的专门的交换文件之间换来换去,在任何时刻,交换空间都限制着当前运
行着的进程能够分配的虚拟页面的总数.&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC9%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC9%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>四种环视匹配</title>
        <description>&lt;h3 id=&quot;0x00-refer&quot;&gt;0x00 refer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jb51.net/article/52491.htm&quot;&gt;匹配不出现字符串&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;肯定顺序环视(?=...)     positive lookahead  (中文也有翻译成:后向界定)
否定顺序环视(?!...)     negtive lookahead   (中文也有翻译成:后向非界定)
肯定逆序环视(?&amp;lt;=...)    positive lookbehind (中文也有翻译成:前向界定)
否定逆序环视(?&amp;lt;!...)    negtive lookbehind  (中文也有翻译成:前向非界定)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上看出:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;是      =
不是    !
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在用正则表达式匹配时将待匹配的字符串变量看作是有隐藏位置的字符串,也即将abcd看作|a|b|c|d|,其中|表示一个隐藏位置.
如果正则表达式中没有上面4种用法则不考虑隐藏的位置,如果有4种任意一种则要考虑隐藏位置,以上4种在匹配时匹配的结果为
这些隐藏的位置(只匹配位置,不匹配字符).&lt;/p&gt;

&lt;h3 id=&quot;0x02-example&quot;&gt;0x02 example&lt;/h3&gt;

&lt;h4 id=&quot;a前面没有form后面有action&quot;&gt;a.前面没有form后面有action&lt;/h4&gt;

&lt;p&gt;使用(?:\n)不捕获匹配\n
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reg1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;替换(?:\n),使用(?&amp;lt;=\n)前向界定和(?=\n)后向界定匹配\n&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reg2.png&quot; /&gt;
上图共使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;=)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!=)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=)&lt;/code&gt;,没有用到&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了用到&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;,具体如下图
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reg3.png&quot; /&gt;
上图共使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;=)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;b前面有form后面没有action&quot;&gt;b.前面有form后面没有action&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reg4.png&quot; /&gt;
上图共使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;=)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=)&lt;/code&gt;,没有用到&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了用到&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;,具体如下图
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reg5.png&quot; /&gt;
上图共使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;=)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;(?=)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x03-vim中的环视匹配&quot;&gt;0x03 vim中的环视匹配&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/vim%E7%8E%AF%E8%A7%86%E5%8C%B9%E9%85%8D.png&quot; /&gt;
注意&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.其中上图的倒数第2个应该是:`...\@&amp;lt;!`
2.匹配时是正常匹配,不是\v(very magic)模式匹配
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x04-attention&quot;&gt;0x04 attention&lt;/h3&gt;

&lt;p&gt;1.为了匹配到一个字符串变量中没有form,可以有4种方法:
a)&lt;code class=&quot;highlighter-rouge&quot;&gt;.(?&amp;lt;!form)&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;(.(?&amp;lt;!form))*&lt;/code&gt;&lt;br /&gt;
b)&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;!form).&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;((?&amp;lt;!form).)*&lt;/code&gt;&lt;br /&gt;
c)&lt;code class=&quot;highlighter-rouge&quot;&gt;.(?!form)&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;(.(?!form))*&lt;/code&gt;&lt;br /&gt;
d)&lt;code class=&quot;highlighter-rouge&quot;&gt;(?!form).&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;((?!form).)*&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中.在()前[&lt;code class=&quot;highlighter-rouge&quot;&gt;.()&lt;/code&gt;]或.在()后[&lt;code class=&quot;highlighter-rouge&quot;&gt;().&lt;/code&gt;]最终的效果一样,但是对于正则引擎来说,匹配的顺序不同,&lt;code class=&quot;highlighter-rouge&quot;&gt;.()&lt;/code&gt;是先匹配字符再匹配隐藏
的位置,&lt;code class=&quot;highlighter-rouge&quot;&gt;().&lt;/code&gt;是先匹配隐藏的位置再匹配字符&lt;/p&gt;

&lt;p&gt;2.四种环视匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;(...)&lt;/code&gt;匹配的结果是一个隐藏的位置,是一个位置,不是多个位置,也不是字符&lt;/p&gt;

&lt;p&gt;3.&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ifconfig | ack '(?&amp;lt;=inet )(.*)(?= netmask)' -o&quot;&lt;/code&gt;可得到ip地址&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;echo lllnihaolllnihaoxxxnihao666 | ack -o '(?&amp;lt;=x)(?=n)nihao.*'&lt;/code&gt;其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;(?&amp;lt;=x)(?=n)&lt;/code&gt;两个紧挨的环视匹配得到的是一个
隐藏的位置,因为环视匹配不会匹配到字符(不捕获),于是第1个环视匹配得到1个位置后由于无法前进字符串,所以第2个环视匹配
得到的依然是相同的位置处,同理,多个紧挨的环视匹配得到的是相同的位置,说明多个环视匹配紧挨时,匹配结果与各个环视匹配
表达式的先后顺序无关&lt;/p&gt;

</description>
        <pubDate>Thu, 28 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/regexp/2017/09/28/%E5%9B%9B%E7%A7%8D%E7%8E%AF%E8%A7%86%E5%8C%B9%E9%85%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/regexp/2017/09/28/%E5%9B%9B%E7%A7%8D%E7%8E%AF%E8%A7%86%E5%8C%B9%E9%85%8D/</guid>
        
        <category>环视匹配</category>
        
        <category>正则表达式</category>
        
        
        <category>regexp</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第8章笔记</title>
        <description>&lt;h3 id=&quot;异常控制流&quot;&gt;异常控制流&lt;/h3&gt;

&lt;p&gt;1.ECF:异常控制流(Exceptional Control Flow)&lt;/p&gt;

&lt;p&gt;2.应用程序通过使用一个叫做陷阱(trap)或者系统调用(system call)的ECF形式,向操作系统请求服务&lt;/p&gt;

&lt;p&gt;3.非本地跳转是一种应用层ECF,在C中是通过setjmp和longjmp函数提供的&lt;/p&gt;

&lt;p&gt;4.异常位于硬件和操作系统交界的部分,进程和信号位于应用和操作系统的交界之处&lt;/p&gt;

&lt;p&gt;5.异常是异常控制流的一种形式,它一部分是由硬件实现的,一部分是由操作系统实现的&lt;/p&gt;

&lt;p&gt;6.异常处理程序运行在内核模式下,这意味着它们对所有的系统资源都有完全的访问权限&lt;/p&gt;

&lt;p&gt;7.异常可以分为4类:中断,陷阱,故障,终止.如下图8-4.&lt;br /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp8-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;a)中断:中断是异步发生的,是来自处理器外部的I/O设备的信号的结果.I/O设备通过向外理器芯片上的一个引脚发信号,并将异常
号放到系统总线上,以触发中断.在当前指令完成执行之后,处理器注意到中断引脚的电压变高了,就从系统总线读取异常号,然后调
用适当的中断处理程序&lt;br /&gt;
b)陷阱:陷阱是有意的异常,是执行一条指令的结果,陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口,叫系
统调用.用户程序向内核请求服务(也即应用程序执行一次系统调用syscall),执行syscall指令会导致一个到异常处理程序的陷阱,
这个处理程序对参数解码,并调用适当的内核程序.在IA32系统上,系统调用是通过一条称为int n的陷阱指令来提供的.C程序用
syscall函数可以直接调用任何系统调用,然而,实际中几乎没必要这么做,对于大多数系统调用,标准C库提供了一组方便的包装函
数.这些包装函数将参数打包到一起,以适当的系统调用号陷入内核,然后将系统调用的返回状态传递回应用程序.所有的Linux系统
调用的参数老师通过寄存器而不是栈传递的.按照惯例,寄存器%eax包含系统调用号,寄存器%ebx,%ecx,%edx,%esi,%edi和%ebp包含
最多六个任意的参数,栈指针%esp不能使用,因为当进入内核模式时,内核会覆盖它.常见系统级调用如下: &lt;br /&gt;
exit,fork,read,write,open,close,waitpid
c)故障:故障由错误情况引起,它可能能够被故障处理程序修正.如果处理程序能够修正这个错误情况,它就将控制返回到引起故障
的指令,从而重新执行它,否则,处理程序返回到内核中的abort例程并终止引起故障的应用程序&lt;br /&gt;
d)终止:终止是不可恢复的致命错误造成的结果,通常是一些硬件错误,终止处理程序从不将控制返回给应用程序&lt;/p&gt;

&lt;p&gt;8.进程是计算机科学最深刻最成功的概念之一.系统中的每个程序都是运行在某个进程的上下文中的.上下文是由程序正确运行所
需的状态组成的.每次用户通过向外壳输入一个可执行目标文件的名字,并运行一个程序时,外壳就会创建一个新的进程,然后在这
个新进程的上下文中运行这个可执行目标文件.应用程序也能够创建新进程,且在这个新进程的上下文中运行它们自己的代码或其
他应用程序.进程提供给应用程序的2个抽象:&lt;br /&gt;
a)一个独立的逻辑控制流,它提供一个假象,好像我们的程序独占地使用处理器&lt;br /&gt;
b)一个么有的地址空间,它提供一个假象,好像我们的程序独占地使用存储器系统&lt;/p&gt;

&lt;p&gt;9.并行与并发的区别&lt;br /&gt;
你吃饭吃到一半,电话来了,你一直到吃完了以后才去接,这就说明你不支持并发也不支持并行.你吃饭吃到一半,电话来了,
你停了下来接了电话,接完后继续吃饭,这说明你支持并发.你吃饭吃到一半,电话来了,你一边打电话一边吃饭,这说明你支
持并行.并发的关键是你有处理多个任务的能力,不一定要同时.并行的关键是你有同时处理多个任务的能力.&lt;/p&gt;

&lt;p&gt;10.处理器通常是用某个控制寄存器中的一个模式位来提供控制权限的,该寄存器描述了进程当前享有的权限,当设置了模式位时,
进程就运行在内核模式中,一个运行在内核模式的进程可以执行指令集中的任何指令,并且可以访问系统中任何存储器位置.没有设
置模式位时,进程就运行在用户模式中,必须通过系统调用接口间接访问内核代码和数据.进程从用户模式变为内核模式的唯一方法
是通过诸如中断,故障或者陷入系统调用这样的异常.&lt;/p&gt;

&lt;p&gt;11.unix系统级函数遇到错误时,它们典型地会返回-1,并设置全局整数变量errno来表示什么出错了.&lt;/p&gt;

&lt;p&gt;12.从程序员的角度,可以认为进程总是处于下面3种状态之一:&lt;br /&gt;
a)运行.要么在cpu上执行,要么在等待被执行且最终会被内核调度&lt;br /&gt;
b)停止.进程的执行被挂起(suspend),且不会被调度.当收到SIGSTOP,SIGTSTP,SIDTTIN或者SIGTTOU信号时,进程就停止,并且保持
停止直到它收到一个SIGCONT信号,在这个时刻,进程再次开始运行.(相当于linux命令中的ctrl+z,ctrl+z的是将任务中断,但是此
任务并没有结束,他仍然在进程中他只是维持挂起的状态.)&lt;br /&gt;
c)终止.进程永远停止了.进程会因为3种原因终止:1)收到一个信号,该信号的默认行为是终止进程,2)从主程序返回,3)调用exit函
数&lt;/p&gt;

&lt;p&gt;13.父进程通过调用fork函数创建一个新的运行子进程(pid_t fork(void)).新创建的子进程几乎但不完全与父进程相同.子进程得
到与父进程用户级虚拟地址空间相同的(但是独立的)一份拷贝,包括文本,数据和bss段,堆以及用户栈.子进程还获得与父进程任何
打开文件描述符相同的拷贝,这就意味着当父进程调用fork时,子进程可以读写父进程中打开的任何文件.父进程和新创建的子进程
之间最大的区别在于它们有不同的pid.frok函数只被调用1次却会返回2次,一次是在调用进程(父进程)中,一次是在新创建的子进
程中.在父进程中,fork返回子进程的pid,在子进程中,fork返回0.fork被调用后,父进程和子进程是并发运行的独立进程,父进程和
子进程对各自相同的变量所做的改变都是独立的,不会反映在另一个进程的存储器中.(联想github上的fork项目后发生的事).&lt;/p&gt;

&lt;p&gt;14.当一个进程由于某种原因终止时,内核并不是立即把它从系统中清除,相反,进程被保持在一种已终止的状态中,直到被它的父进
程回收.&lt;/p&gt;

&lt;p&gt;15.程序与进程的关系.程序是一堆代码和数据;程序可以作为目标模块存在于磁盘上,或者作为段存在于地址空间中.进程是执行中
程序的一个具体的实例;程序总是运行在某个进程的上下文中.fork函数在新的子进程中运行相同的程序,新的子进程是父进程的一
个复制品.execve函数在当前进程的上下文中加载并运行一个新的程序,它会覆盖当前进程的地址空间,但并没有创建一个新进程.
新的程序仍然有相同的pid,并且继承了调用execve函数时已打开的所有文件描述符.python中os.system(cmd)相当于在当前的
python脚本中阻塞运行一个cmd,这里的python脚本和cmd的关系相当于linux中bash和手动输入的命令的关系,就算bash被kill -9
bashPid了,手动输入的命令还在执行,同样,就算python脚本被kill -9 pythonFilePid了,python脚本中运行的cmd还在运行,相当
于异步阻塞.python中可用&lt;a href=&quot;http://blog.csdn.net/seetheworld518/article/details/49639247&quot;&gt;os.fork()&lt;/a&gt;实现linux的C语言中的fork()&lt;/p&gt;

&lt;p&gt;16.unix信号是一种相对更高层的软件形式的异常,它允许进程中断其他进程,一个信号就是一条小消息,它通知进程系统中发生了
一个某种类型的事件.&lt;/p&gt;

&lt;p&gt;17.每个进程都只属于一个进程组,进程组是由一个正整数进程组ID来标识的,getpgrp函数返回当前进程的进程组ID,默认地,一个
子进程和它的父进程同属于一个进程组,一个进程可以通过使用setpgid函数来改变自己或其他进程的进程组.&lt;/p&gt;

&lt;p&gt;18./bin/kill -9 -15213表示由kill程序向15213进程组中的每个进程发送信号9(SIGKILL),kill程序可以向另外的进程发送任意
的信号,一个为负的PID会导致信号被发送到进程组PID中的每个进程.除了kill程序可以发送信号外,也可从键盘发送信号,或者调
用alarm函数来发送信号.&lt;/p&gt;

&lt;p&gt;19.应用程序可以使用sigprocmask函数显示地(阻塞)和(取消阻塞)信号&lt;/p&gt;

&lt;p&gt;20.异常控制流(ECF)发生在计算机系统的各个层次,是计算机系统中提供并发的基本机制.&lt;/p&gt;

&lt;p&gt;21.在操作系统层,内核用ECF提供进程的基本概念,进程提供给应用两个重要的抽象:&lt;br /&gt;
a)逻辑控制流:它提供给每个程序一个假象,好像它是丰独占地使用处理器&lt;br /&gt;
b)私有地址空间:它提供给每个程序一个假象,好像它是在独占地使用主存&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC8%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC8%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>cookie和session</title>
        <description>&lt;p&gt;0x00 set-cookie&lt;/p&gt;

&lt;p&gt;第一次访问页面后,Server可将Cookie信息加入HTTP Header返回给浏览器(set-cookie),浏览器会自动将这些信息保存在本地;
当再次访问相同域名时,浏览器将对应Cookie信息随请求一起发送,Server端可读取这些信息进行处理.&lt;/p&gt;

&lt;p&gt;0x01 session_start()&lt;/p&gt;

&lt;p&gt;session_start()做了哪些初始化工作
1.读取名为PHPSESSID(如果没有改变默认值)的cookie值,假使为abc123
2.若读取到PHPSESSID这个COOKIE,创建$_SESSION变量,并从相应的目录中(可以再php.ini中设置)读取SESS_abc123(默认
是这种命名方式)文件,将字符装在入$_SESSION变量中; 若没有读取到PHPSESSID这个COOKIE,也会创建$_SESSION变量,同时创
建一个sess_abc321(名称为随机值)的session文件,同时将abc321作为PHPSESSID的cookie值返回给浏览器端.&lt;/p&gt;

&lt;p&gt;0x02 sessionID&lt;/p&gt;

&lt;p&gt;在用户登录前后,客户端的cookie不会变,只是如果登录成功,这个cookie对应的服务器中的session变成可以访问后台内容的权限,
所以如果sessionID值放在数据库中,可遍历这些sesionID,将客户端中cookie中的对应的sessioID值替换成数据库中的sessionID,
如果有一个sessionID是管理员身份的session,那么可用这个cookie进后台&lt;/p&gt;

&lt;p&gt;登录后的用户人为logout后,客户端cookie依然不变,除非时间过期了,这样浏览器就不会再用这个cookie了(dvwa中如此,其他未测
)&lt;/p&gt;

&lt;p&gt;0x03 python处理cookie&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21736970/using-requests-module-how-to-handle-set-cookie-in-request-response&quot;&gt;python中自动处理cookie的方法&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with requests.Session() as s:
    r = s.get(URL1)
    r = s.post(URL2, data=&quot;username and password data payload&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/09/19/cookie%E5%92%8Csession/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/09/19/cookie%E5%92%8Csession/</guid>
        
        <category>cookie</category>
        
        <category>session</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>dvwa的csrf_token机制</title>
        <description>&lt;p&gt;dvwa的csrf_token在设置level为impossible(除low外未验证)时起作用,有了csrf_token后可防csrf漏洞的利用,同时也给自动化漏洞
检测带来了麻烦,客户端扫描漏洞时需要每次重新设置新的csrf_token来发送get/post请求,如果没有带上新的token参数值服务器
会校验不通过&lt;/p&gt;

&lt;p&gt;dvwa设置level为impossible后服务端验证(由form action中的地址对应的页面进行验证)客户端传来的csrf_token的过程如下:(以xss[reflected]和login页面为例,dvwa中的login.php和xss_r中的form action中的url都是当前页面)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    加载impossible.php
    impossible.php执行内容流程:
        1.验证csrf_token
        2.刷新服务器端存储的csrf_token

    取出新的csrf_token到html的body
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中刷新服务器存储的csrf_token的代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function generateSessionToken() {  # Generate a brand new (CSRF) token                                                                                    
     if( isset( $_SESSION[ 'session_token'  ]  )  ) {                                                                                                         
         destroySessionToken();                                                                                                                            
     }                                                                                                                                                     
     $_SESSION[ 'session_token'  ] = md5( uniqid()  );                                                                                                       
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的验证csrf_token中,xss[reflected]是先判断是否传入name参数,也即如果
在url中出现name参数,无论是否为空都将进行csrf_token验证(服务器中用的isset($_POST[‘name’])来判断)
eg.&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/?name=1&lt;/code&gt;时验证csrf_token&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/?name=&lt;/code&gt;时验证csrf_token&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/&lt;/code&gt;时不验证csrf_token&lt;/p&gt;

&lt;p&gt;从上面服务器校验客户端传入的csrf_token参数的过程可以看出:&lt;/p&gt;

&lt;p&gt;a.服务器判断客户端是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;人&lt;/code&gt;的方法是通过cookie中的sessionid来判断的,判断客户端是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;人&lt;/code&gt;正常合法地通过浏览器
访问的通过cookie中的sessionid+传入的csrf_token=服务器保存的csrf_token来判断的&lt;/p&gt;

&lt;p&gt;b.这种带csrf_token验证的情况会对暴力破解产生阻碍,导致暴力破解相当于只能单线程进行(需要每次等待返回的新的
csrf_token),且暴力破解时需要每次在请求时更新请求参数中的csrf_token的值为从服务器返回的新的csrf_token值&lt;/p&gt;

&lt;p&gt;c.在自动化漏洞检测时需要先判断要检测的页面是否有csrf_token(有些页面是没有的),如果有则要在请求前更新csrf_token参数
的值(sql注入和xss检测中可能会有)&lt;/p&gt;

&lt;p&gt;d.这里的csrf_token的验证和&lt;a href=&quot;http://3xp10it.cc/web/2016/11/10/%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/#0x02-about&quot;&gt;这里&lt;/a&gt;说的验证码验证机制几乎相同,只不过链接里的form action页面与登录页面不同,也即只
要登录页面中的form action值不是登录页面则很可能存在验证码绕过的问题(只要人工输入一次验证码即可)&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/09/14/dvwa%E7%9A%84csrf_token%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/09/14/dvwa%E7%9A%84csrf_token%E6%9C%BA%E5%88%B6/</guid>
        
        <category>csrf</category>
        
        <category>token</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第7章笔记</title>
        <description>&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;1.为了构造可执行文件,链接器必须完成两个主要任务&lt;/p&gt;

&lt;p&gt;a)符号解析:符号解析的目的是将每个符号引用刚好和一个符号定义联系起来&lt;/p&gt;

&lt;p&gt;b)重定位:链接器通过把每个符号定义与一个存储器位置联系起来,然后修改所有对这些符号的引用,使得它们指向这个存储器位置
,从而重定位这些节&lt;/p&gt;

&lt;p&gt;2.如下为一个典型的ELF可重定位目标文件格式(与elf[可执行目标文件]的格式类似)
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text:已编译程序的机器码
.rodata:只读数据,如printf语句中的格式串和开关语句的跳转表
.data:已初始化的全局变量,局部变量保存在栈中
.bss:未初始化的全局变量,在目标文件中这个节不占据实际的空间,它仅仅是一个点位符(better save space)
.symtab:一个符号表,它存放程序中定义和引用的函数和全局变量的信息,.symtab符号表不包含局部变量的条目
.rel.text:一个.text节中位置的列表,当链接器把这个目标文件和其他文件结合时,需要修改这些位置
.rel.data:被模块引用或定义的任何全局变量的重定位信息
.debug:一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件,只有-g
选项调用编译驱动程序(gcc)才会得到这张表
.line:源代码和.text节中机器指令之间的映射
.strtab:一个字符串表,其内容包括.symtab和.debug节中的符号表,以及节头部中的节名字,也即反汇编中&quot;查找字符串&quot;的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.符号:符号是函数名和变量名,本地链接器符号不包含对应于本地非静态程序变量的任何符号(局部变量)&lt;/p&gt;

&lt;p&gt;4.定义为带有C static属性的本地过程变量是不在栈中管理的,相反,编译器在.data和.bss中为每个定义分配空间,并在符号表中
创建一个有唯一名字的本地链接器符号&lt;/p&gt;

&lt;p&gt;5.任何声明带有static属性的全局变量或者函数都是模块私有有,类似地,任何声明不带static属性的全局变量和函数都是公共的,
可以被其他模块访问,使用static属性可在模块内部隐藏变量和函数声明,尽可能用static属性来保护你的变量和函数是很好的编
程习惯.python中在名称前加下划线表示私有,&lt;a href=&quot;http://python.jobbole.com/81129/&quot;&gt;更多详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.重定位:在装入程序前,系统会计算未使用的内存,然后将程序装入,并记下开始地址,在执行有相对地址的指令时,会将所有的地
址加上刚才记下的开始地址,就叫重定位.重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程,也就是说在
装入时对目标程序中指令和数据的修改过程,它是多道程序在内存中同时运行的基础.链接过程中会把多个文件的相同类型数据段
代码放在一起,所以需要将里面的符号变量重新安置在一个确定的内存地址中,这就是重定位.&lt;/p&gt;

&lt;p&gt;7.对可重定位目标文件的理解,&lt;a href=&quot;http://blog.csdn.net/ky_heart/article/details/51865526&quot;&gt;更多详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.elf可执行文件格式图如下,.text,.rodata和.data节和可重定位目标文件中的节是相似的,除了这些节已经被重定位到它们最终
的运行时存储器地址以外.elf可执行文件被设计得很容易加载到存储器,可执行文件的连续的片(chunk)被映射到连续的存储器段,
段头部表描述了这种关系,如下图7-12展示了一个可执行文件的段头部表(由objdump显示),其中第一部分是代码段,包括(elf头部,
段头部表,.init,.text,.rodata节),第二部分是数据段,包括(.data,.bss节)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-2.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9.任何unix程序都可以通过调用execve函数来调用加载器,加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器中,然后
通过跳转到程序的第一条指令或入口点来运行该程序,加载器运行时,它创建如下图7-13所示的存储器映像,其中内核虚拟存储器为
高地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10.&lt;a href=&quot;http://blog.chinaunix.net/uid-24532607-id-3082314.html&quot;&gt;静态链接库和动态链接库的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;11.C语言为什么要有main函数?&lt;a href=&quot;https://www.zhihu.com/question/28360770?sort=created&quot;&gt;a&lt;/a&gt;,&lt;a href=&quot;http://blog.csdn.net/xtydtc/article/details/53572455&quot;&gt;b&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;12.GOT:全局偏移量表(global offset table),在加载时,动态链接器会重定位(修改)GOT中的每个条目,使得它包含正确的绝对地址.
每个引用全局数据的目标模块都有自己的GOT&lt;/p&gt;

&lt;p&gt;13.PLT:过程链接表(Procedure Linkage Table),如果一个目标模块调用定义在共享库中的任何函数,那么它就有自己的GOT和PLT,
GOT是.data节的一部分,PLT是.text节的一部分&lt;/p&gt;

&lt;p&gt;14.&lt;a href=&quot;https://www.zhihu.com/question/21249496/answer/71226275&quot;&gt;理解GOT和PLt的关系和原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;15.链接可以在编译时由静态编译器来完成,也可以在加载时和运行时由动态链接器来完成.链接器的两个主要任务是符号解析和重
定位,符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义,而重定位确定每个符号的最终存储器地址,并修改对那些目
标的引用.&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
  </channel>
</rss>
