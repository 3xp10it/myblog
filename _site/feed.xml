<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 19 Sep 2017 22:55:58 +0800</pubDate>
    <lastBuildDate>Tue, 19 Sep 2017 22:55:58 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>深入理解计算机系统第8章笔记</title>
        <description>&lt;h3 id=&quot;异常控制流&quot;&gt;异常控制流&lt;/h3&gt;

&lt;p&gt;1.ECF:异常控制流(Exceptional Control Flow)&lt;/p&gt;

&lt;p&gt;2.应用程序通过使用一个叫做陷阱(trap)或者系统调用(system call)的ECF形式,向操作系统请求服务&lt;/p&gt;

&lt;p&gt;3.非本地跳转是一种应用层ECF,在C中是通过setjmp和longjmp函数提供的&lt;/p&gt;

&lt;p&gt;4.异常位于硬件和操作系统交界的部分,进程和信号位于应用和操作系统的交界之处&lt;/p&gt;

&lt;p&gt;5.异常是异常控制流的一种形式,它一部分是由硬件实现的,一部分是由操作系统实现的&lt;/p&gt;

&lt;p&gt;6.异常处理程序运行在内核模式下,这意味着它们对所有的系统资源都有完全的访问权限&lt;/p&gt;

&lt;p&gt;7.异常可以分为4类:中断,陷阱,故障,终止.如下图8-4.&lt;br /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp8-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;a)中断:中断是异步发生的,是来自处理器外部的I/O设备的信号的结果.I/O设备通过向外理器芯片上的一个引脚发信号,并将异常
号放到系统总线上,以触发中断.在当前指令完成执行之后,处理器注意到中断引脚的电压变高了,就从系统总线读取异常号,然后调
用适当的中断处理程序&lt;br /&gt;
b)陷阱:陷阱是有意的异常,是执行一条指令的结果,陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口,叫系
统调用.用户程序向内核请求服务(也即应用程序执行一次系统调用syscall),执行syscall指令会导致一个到异常处理程序的陷阱,
这个处理程序对参数解码,并调用适当的内核程序&lt;br /&gt;
c)故障:故障由错误情况引起,它可能能够被故障处理程序修正.如果处理程序能够修正这个错误情况,它就将控制返回到引起故障
的指令,从而重新执行它,否则,处理程序返回到内核中的abort例程并终止引起故障的应用程序&lt;br /&gt;
d)终止:终止是不可恢复的致命错误造成的结果,通常是一些硬件错误,终止处理程序从不将控制返回给应用程序&lt;/p&gt;

</description>
        <pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC8%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC8%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>cookie和session</title>
        <description>&lt;p&gt;0x00 set-cookie&lt;/p&gt;

&lt;p&gt;第一次访问页面后,Server可将Cookie信息加入HTTP Header返回给浏览器(set-cookie),浏览器会自动将这些信息保存在本地;
当再次访问相同域名时,浏览器将对应Cookie信息随请求一起发送,Server端可读取这些信息进行处理.&lt;/p&gt;

&lt;p&gt;0x01 session_start()&lt;/p&gt;

&lt;p&gt;session_start()做了哪些初始化工作
1.读取名为PHPSESSID(如果没有改变默认值)的cookie值,假使为abc123
2.若读取到PHPSESSID这个COOKIE,创建$_SESSION变量,并从相应的目录中(可以再php.ini中设置)读取SESS_abc123(默认
是这种命名方式)文件,将字符装在入$_SESSION变量中; 若没有读取到PHPSESSID这个COOKIE,也会创建$_SESSION变量,同时创
建一个sess_abc321(名称为随机值)的session文件,同时将abc321作为PHPSESSID的cookie值返回给浏览器端.&lt;/p&gt;

&lt;p&gt;0x02 sessionID&lt;/p&gt;

&lt;p&gt;在用户登录前后,客户端的cookie不会变,只是如果登录成功,这个cookie对应的服务器中的session变成可以访问后台内容的权限,
所以如果sessionID值放在数据库中,可遍历这些sesionID,将客户端中cookie中的对应的sessioID值替换成数据库中的sessionID,
如果有一个sessionID是管理员身份的session,那么可用这个cookie进后台&lt;/p&gt;

&lt;p&gt;登录后的用户人为logout后,客户端cookie依然不变,除非时间过期了,这样浏览器就不会再用这个cookie了(dvwa中如此,其他未测
)&lt;/p&gt;

&lt;p&gt;0x03 python处理cookie&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/21736970/using-requests-module-how-to-handle-set-cookie-in-request-response&quot;&gt;python中自动处理cookie的方法&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;with requests.Session() as s:
    r = s.get(URL1)
    r = s.post(URL2, data=&quot;username and password data payload&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 19 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/09/19/cookie%E5%92%8Csession/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/09/19/cookie%E5%92%8Csession/</guid>
        
        <category>cookie</category>
        
        <category>session</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>dvwa的csrf_token机制</title>
        <description>&lt;p&gt;dvwa的csrf_token在设置level为impossible(除low外未验证)时起作用,有了csrf_token后可防csrf漏洞的利用,同时也给自动化漏洞
检测带来了麻烦,客户端扫描漏洞时需要每次重新设置新的csrf_token来发送get/post请求,如果没有带上新的token参数值服务器
会校验不通过&lt;/p&gt;

&lt;p&gt;dvwa设置level为impossible后服务端验证(由form action中的地址对应的页面进行验证)客户端传来的csrf_token的过程如下:(以xss[reflected]和login页面为例,dvwa中的login.php和xss_r中的form action中的url都是当前页面)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    加载impossible.php
    impossible.php执行内容流程:
        1.验证csrf_token
        2.刷新服务器端存储的csrf_token

    取出新的csrf_token到html的body
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中刷新服务器存储的csrf_token的代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function generateSessionToken() {  # Generate a brand new (CSRF) token                                                                                    
     if( isset( $_SESSION[ 'session_token'  ]  )  ) {                                                                                                         
         destroySessionToken();                                                                                                                            
     }                                                                                                                                                     
     $_SESSION[ 'session_token'  ] = md5( uniqid()  );                                                                                                       
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的验证csrf_token中,xss[reflected]是先判断是否传入name参数,也即如果
在url中出现name参数,无论是否为空都将进行csrf_token验证(服务器中用的isset($_POST[‘name’])来判断)
eg.&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/?name=1&lt;/code&gt;时验证csrf_token&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/?name=&lt;/code&gt;时验证csrf_token&lt;br /&gt;
访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.83.11/dvwa/vulnerabilities/xss_r/&lt;/code&gt;时不验证csrf_token&lt;/p&gt;

&lt;p&gt;从上面服务器校验客户端传入的csrf_token参数的过程可以看出:&lt;/p&gt;

&lt;p&gt;a.服务器判断客户端是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;人&lt;/code&gt;的方法是通过cookie中的sessionid来判断的,判断客户端是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;人&lt;/code&gt;正常合法地通过浏览器
访问的通过cookie中的sessionid+传入的csrf_token=服务器保存的csrf_token来判断的&lt;/p&gt;

&lt;p&gt;b.这种带csrf_token验证的情况会对暴力破解产生阻碍,导致暴力破解相当于只能单线程进行(需要每次等待返回的新的
csrf_token),且暴力破解时需要每次在请求时更新请求参数中的csrf_token的值为从服务器返回的新的csrf_token值&lt;/p&gt;

&lt;p&gt;c.在自动化漏洞检测时需要先判断要检测的页面是否有csrf_token(有些页面是没有的),如果有则要在请求前更新csrf_token参数
的值(sql注入和xss检测中可能会有)&lt;/p&gt;

&lt;p&gt;d.这里的csrf_token的验证和&lt;a href=&quot;http://3xp10it.cc/web/2016/11/10/%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/#0x02-about&quot;&gt;这里&lt;/a&gt;说的验证码验证机制几乎相同,只不过链接里的form action页面与登录页面不同,也即只
要登录页面中的form action值不是登录页面则很可能存在验证码绕过的问题(只要人工输入一次验证码即可)&lt;/p&gt;

</description>
        <pubDate>Thu, 14 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/09/14/dvwa%E7%9A%84csrf_token%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/09/14/dvwa%E7%9A%84csrf_token%E6%9C%BA%E5%88%B6/</guid>
        
        <category>csrf</category>
        
        <category>token</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第7章笔记</title>
        <description>&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;

&lt;p&gt;1.为了构造可执行文件,链接器必须完成两个主要任务&lt;/p&gt;

&lt;p&gt;a)符号解析:符号解析的目的是将每个符号引用刚好和一个符号定义联系起来&lt;/p&gt;

&lt;p&gt;b)重定位:链接器通过把每个符号定义与一个存储器位置联系起来,然后修改所有对这些符号的引用,使得它们指向这个存储器位置
,从而重定位这些节&lt;/p&gt;

&lt;p&gt;2.如下为一个典型的ELF可重定位目标文件格式(与elf[可执行目标文件]的格式类似)
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text:已编译程序的机器码
.rodata:只读数据,如printf语句中的格式串和开关语句的跳转表
.data:已初始化的全局变量,局部变量保存在栈中
.bss:未初始化的全局变量,在目标文件中这个节不占据实际的空间,它仅仅是一个点位符(better save space)
.symtab:一个符号表,它存放程序中定义和引用的函数和全局变量的信息,.symtab符号表不包含局部变量的条目
.rel.text:一个.text节中位置的列表,当链接器把这个目标文件和其他文件结合时,需要修改这些位置
.rel.data:被模块引用或定义的任何全局变量的重定位信息
.debug:一个调试符号表,其条目是程序中定义的局部变量和类型定义,程序中定义和引用的全局变量,以及原始的C源文件,只有-g
选项调用编译驱动程序(gcc)才会得到这张表
.line:源代码和.text节中机器指令之间的映射
.strtab:一个字符串表,其内容包括.symtab和.debug节中的符号表,以及节头部中的节名字,也即反汇编中&quot;查找字符串&quot;的结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.符号:符号是函数名和变量名,本地链接器符号不包含对应于本地非静态程序变量的任何符号(局部变量)&lt;/p&gt;

&lt;p&gt;4.定义为带有C static属性的本地过程变量是不在栈中管理的,相反,编译器在.data和.bss中为每个定义分配空间,并在符号表中
创建一个有唯一名字的本地链接器符号&lt;/p&gt;

&lt;p&gt;5.任何声明带有static属性的全局变量或者函数都是模块私有有,类似地,任何声明不带static属性的全局变量和函数都是公共的,
可以被其他模块访问,使用static属性可在模块内部隐藏变量和函数声明,尽可能用static属性来保护你的变量和函数是很好的编
程习惯.python中在名称前加下划线表示私有,&lt;a href=&quot;http://python.jobbole.com/81129/&quot;&gt;更多详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.重定位:在装入程序前,系统会计算未使用的内存,然后将程序装入,并记下开始地址,在执行有相对地址的指令时,会将所有的地
址加上刚才记下的开始地址,就叫重定位.重定位就是把程序的逻辑地址空间变换成内存中的实际物理地址空间的过程,也就是说在
装入时对目标程序中指令和数据的修改过程,它是多道程序在内存中同时运行的基础.链接过程中会把多个文件的相同类型数据段
代码放在一起,所以需要将里面的符号变量重新安置在一个确定的内存地址中,这就是重定位.&lt;/p&gt;

&lt;p&gt;7.对可重定位目标文件的理解,&lt;a href=&quot;http://blog.csdn.net/ky_heart/article/details/51865526&quot;&gt;更多详情&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.elf可执行文件格式图如下,.text,.rodata和.data节和可重定位目标文件中的节是相似的,除了这些节已经被重定位到它们最终
的运行时存储器地址以外.elf可执行文件被设计得很容易加载到存储器,可执行文件的连续的片(chunk)被映射到连续的存储器段,
段头部表描述了这种关系,如下图7-12展示了一个可执行文件的段头部表(由objdump显示),其中第一部分是代码段,包括(elf头部,
段头部表,.init,.text,.rodata节),第二部分是数据段,包括(.data,.bss节)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-2.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9.任何unix程序都可以通过调用execve函数来调用加载器,加载器将可执行目标文件中的代码和数据从磁盘拷贝到存储器中,然后
通过跳转到程序的第一条指令或入口点来运行该程序,加载器运行时,它创建如下图7-13所示的存储器映像,其中内核虚拟存储器为
高地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp7-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10.&lt;a href=&quot;http://blog.chinaunix.net/uid-24532607-id-3082314.html&quot;&gt;静态链接库和动态链接库的区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;11.C语言为什么要有main函数?&lt;a href=&quot;https://www.zhihu.com/question/28360770?sort=created&quot;&gt;a&lt;/a&gt;,&lt;a href=&quot;http://blog.csdn.net/xtydtc/article/details/53572455&quot;&gt;b&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;12.GOT:全局偏移量表(global offset table),在加载时,动态链接器会重定位(修改)GOT中的每个条目,使得它包含正确的绝对地址.
每个引用全局数据的目标模块都有自己的GOT&lt;/p&gt;

&lt;p&gt;13.PLT:过程链接表(Procedure Linkage Table),如果一个目标模块调用定义在共享库中的任何函数,那么它就有自己的GOT和PLT,
GOT是.data节的一部分,PLT是.text节的一部分&lt;/p&gt;

&lt;p&gt;14.&lt;a href=&quot;https://www.zhihu.com/question/21249496/answer/71226275&quot;&gt;理解GOT和PLt的关系和原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;15.链接可以在编译时由静态编译器来完成,也可以在加载时和运行时由动态链接器来完成.链接器的两个主要任务是符号解析和重
定位,符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义,而重定位确定每个符号的最终存储器地址,并修改对那些目
标的引用.&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/08/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC7%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第6章笔记</title>
        <description>&lt;h3 id=&quot;存储器层次结构&quot;&gt;存储器层次结构&lt;/h3&gt;

&lt;p&gt;1.高速缓存介于cpu和主存(内存)之间,它们对于应用程序性能的影响最大&lt;/p&gt;

&lt;p&gt;2.在简单模型中,存储器系统是一个线性的字节数组,而cpu能够在一个常数时间内访问每个存储器位置,虽然迄今为止这都是一个
有效的模型,但是它没有反映现代系统实际工作的方式&lt;/p&gt;

&lt;p&gt;3.cpu是中央处理器(central processing unit),主要由运算器,控制器,寄存器三部分组成&lt;/p&gt;

&lt;p&gt;4.sram(static random-access memory):静态随机访问存储器主要用于作高速缓存存储器;dram(dynamic random-access
memory):动态随机访问存储器主要用于作主存(内存);rom(read-only memory):只读存储器;sram和dram断电后内容消失&lt;/p&gt;

&lt;p&gt;5.总线分为:系统总线,存储器总线,I/O总线.虽然I/O总线比系统总线和存储器总线慢,但是它可以容纳种类繁多的第三方I/O设备&lt;/p&gt;

&lt;p&gt;6.dma(direct memory access):直接存储器访问.在磁盘控制器收到来自cpu的读命令后,它将逻辑块号翻译成一个扇区地址,读该
扇区的内容,然后将这些内容直接传送到主存,不需要cpu的干涉.设备可自己执行读或写总线事务,这个过程称为dma(发生在将硬盘
中的数据读到内存中,这个命令是cpu发出的)&lt;/p&gt;

&lt;p&gt;7.局部性原理:一个编写良好的程序倾向于引用邻近于其他最近引用过的数据项,或者最近引用过的数据项本身,这是一个持久的概
念,对硬件和软件系统的设计和性能都有着极大的影响.局部性有两种不同的形式:时间局部性和空间局部性.在一个具有良好时间
局部性的程序中,被引用过一次的存储器位置很可能在不远的将来再被多次引用;在一个具有良好空间局部性的程序中,如果一个存
储器位置被引用了一次,那么程序很可能在不远的将来引用附近的一个存储器位置&lt;/p&gt;

&lt;p&gt;8.局部性小结&lt;/p&gt;

&lt;p&gt;a)重复引用同一个变量的程序有良好的时间局部性&lt;br /&gt;
b)对于具有步长为k的引用模式的程序,步长越小,空间局部性越好&lt;br /&gt;
c)对于取指令来说,循环有好的时间和空间局部性,循环体越小,循环迭代次数越多,局部性越好&lt;br /&gt;
d)二维C数组在存储器中是按照行顺序来存放的,对a[i][j]表示每个元素中:&lt;code class=&quot;highlighter-rouge&quot;&gt;for(i=0;j&amp;lt;n;i++)-&amp;gt;for(j=0;j&amp;lt;n;j++)&lt;/code&gt;的空间局部性
比&lt;code class=&quot;highlighter-rouge&quot;&gt;for(j=0;j&amp;lt;n;j++)-&amp;gt;for(i=0;i&amp;lt;n;i++)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;9.缓存命中:当程序需要第k+1层的某个数据对象d时,它首先在当前存储在第k层的一个块中查找d,如果d刚好缓存在第k层中,那么
这就是缓存命中&lt;/p&gt;

&lt;p&gt;10.存储器层次结构的本质是,每一层存储设备都是较低一层的缓存.基于缓存的存储器层次结构行之有效,是因为较慢的存储设备
比较快的存储设备更便宜,还因为程序往往展示局部性:&lt;br /&gt;
a)利用时间局部性:由于时间局部性,同一数据对象可能会被多次使用.一旦一个数据对象在第一次不命中时被拷贝到缓存中,我们
就会期望后面对该目标有一系列的访问命中&lt;br /&gt;
b)利用空间局部性:块通常包含有多个数据对象,由于空间局部性,我们会期望后面对该块中其他对象的访问能够补偿不命中的拷贝
该块的花费&lt;/p&gt;

&lt;p&gt;11.高速缓存读写过程&lt;/p&gt;

&lt;p&gt;a)读:首先,在高速缓存中查找所需字w的拷贝.如果命中,立即返回字w给cpu,如果不命中,从存储器层次结构中较低层中取出包含字
w的块,将这个块存储到某个高速缓存行中(可能会驱逐一个有效的行),然后返回字w&lt;/p&gt;

&lt;p&gt;b)写:写的情况复杂一些,假设要写一个已经缓存了的字w,有2种方法:一种是直写,就是立即将w的高速缓存块写回到紧接着的低一
层中,虽然简单,但是直写的缺点是每次写都会引起总线流量.另一种方法称为写回,尽可能地推迟存储器更新,只有当替换算法要驱
逐更新过的块时,才把它写到紧接着的低一层中.&lt;/p&gt;

&lt;p&gt;12.确保代码高速缓存友好的基本方法&lt;/p&gt;

&lt;p&gt;a)让最常见的情况运行得快,也即要把注意力集中在核心函数中的循环上而忽略其他部分&lt;/p&gt;

&lt;p&gt;b)在每个循环内部缓存不命中数量最小,也即保证有好的时间局部性(对局部变量的反复引用)和空间局部性(步长为1的引用模式)&lt;/p&gt;

&lt;p&gt;13.关于存储器山&lt;/p&gt;

&lt;p&gt;a)一个程序从存储系统中读数据的速率称为读吞吐量(或读带宽)&lt;br /&gt;
b)读带宽的时间和空间局部性的二维函数称为存储器山&lt;br /&gt;
c)即使是当程序的时间局部性很差时,空间局部性仍然能补救,并且是非常重要的
d)存储器系统的性能不是一个数字就能描述的,相反,它是一座时间和空间局部性的山,这座山的上升调试差别可以超过一个数量级&lt;br /&gt;
e)要使程序运行在存储器的山峰,就是要利用时间局部性,使得频繁使用的字从L1(最快的高速缓存)中取出,还要利用空间局部性,
使得尽可能多的字从一个L1高速缓存行中访问到&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Sep 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/09/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC6%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第5章笔记</title>
        <description>&lt;h3 id=&quot;优化程序性能&quot;&gt;优化程序性能&lt;/h3&gt;

&lt;p&gt;1.编写高效程序特点:&lt;/p&gt;

&lt;p&gt;a)必须选择一组合适的算法和数据结构&lt;br /&gt;
要特别警觉,避免使用那些会渐进地产生糟糕性能的算法或编码技术&lt;/p&gt;

&lt;p&gt;b)必须编写出编译器能够有效优化以转换成高效可执行代码的源代码&lt;br /&gt;
如,用好的风格重写条件操作,使得编译采用条件数据传送&lt;/p&gt;

&lt;p&gt;c)利用多核和多处理器并行计算&lt;br /&gt;
通过使用例如多个累积变量和重新结合等技术,找到方法提高指令级并行&lt;/p&gt;

&lt;p&gt;d)消除循环的低效率&lt;br /&gt;
展开循环,降低开销,并且使得进一步的优化成为可能&lt;/p&gt;

&lt;p&gt;e)减少过程调用&lt;br /&gt;
消除连续的函数调用,在可能时,将计算移到循环外,考虑有选择地妥协程序的模块性以获得更大的效率&lt;/p&gt;

&lt;p&gt;f)消除不必要的存储器引用&lt;br /&gt;
引入临时变量来保存中间结果,只有在最后的值计算出来时,才将结果存放到数组或全局变量中&lt;/p&gt;

&lt;p&gt;2.现代微处理器取得的了不起的功绩之一是:它们采用复杂而奇异的微处理器结构,其中,多条指令可以并行地执行,同时又呈现一
种简单地顺序执行的表象&lt;/p&gt;

&lt;p&gt;3.现代微处理器可以在每个时钟周期执行多个操作,而且是乱序的,意思就是指令执行的顺序不一定要与它们在机器程序中的顺序
一致,与第4章研究过的流水线相比,乱序处理器需要更大更复杂的硬件,但是它们能更好地达到更高的指令级并行度&lt;/p&gt;

&lt;p&gt;4.通常指令控制单元(ICU)会在当前正在执行的指令很早之前取指,这样它才有足够的时间对指令译码,并把操作发送到执行单元
(EU).不过,当程序遇到分支(jnz/retn等)时,程序有两个可能的前进方向,现代处理器采用了一种称为分支预测的技术,处理器会猜
测是否会选择分支并取指和译码,如果后来发现选错了,会将状态重新设置到分支点的状态,并取指和译码&lt;/p&gt;

&lt;p&gt;5.循环展开是一种程序变换,通过增加每次迭代计算的元素的数量,减少循环的迭代次数.编译器可以很容易地执行循环展开,只要
优化级别设置得足够高,许多编译器都能例行公事地做到这一点.用命令行选项”-funroll-loops”调用GCC,会执行循环展开.&lt;/p&gt;

&lt;p&gt;循环展开能够从两个方面改程序的性能,下图中psum2函数是一个循环展开的示例.&lt;/p&gt;

&lt;p&gt;a)减少了不利操作的数量,如:循环索引计算和条件分支&lt;br /&gt;
b)提供了一些方法,可以进一步变化代码,减少整个计算中关键路径上的操作数量&lt;br /&gt;
c)编译器可以很容易地执行循环展开,只要优化级别设置得足够高,许多编译器都能例行公事地做到这一点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp5-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6.每个运算都是由两个周期计数值来刻画的:一个是延迟,它表示完成运算所需要的总时间;另一个是发射时间,它表示两个连续的
同类型运算之间需要的最小时钟周期数.&lt;/p&gt;

&lt;p&gt;7.提高并行性&lt;/p&gt;

&lt;p&gt;a)多个累积变量&lt;br /&gt;
对于一个可结合和可交换的合并运算来说,比如说整数加法或乘法,我们可以通过将一组合并运算分割成两个或更多的部分,并在
最后合并结果来提高性能(利用功能单元的流水线能力来提高性能)&lt;/p&gt;

&lt;p&gt;b)重新结合变换&lt;br /&gt;
重新结合变换能够减少计算中关键路径上操作的数量,通过更好地利用功能单元的流水线能力得到更好的性能&lt;/p&gt;

&lt;p&gt;8.unix系统提供了一个剖析程序GPROF,它会计算每个函数花费的时间和函数被调用的次数&lt;/p&gt;

&lt;p&gt;9.为什么函数调用和递归效率低?&lt;/p&gt;

&lt;p&gt;系统每次函数调用都要分配存储空间,并将调用点压栈记录,在函数调用结束后还要释放空间,恢复栈空间,所以函数调用浪费时间
和空间,而递归正是函数自己调用自己,于是效率低&lt;/p&gt;

</description>
        <pubDate>Thu, 31 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC5%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>深入理解计算机系统第4章笔记</title>
        <description>&lt;h3 id=&quot;处理器体系结构&quot;&gt;处理器体系结构&lt;/h3&gt;

&lt;p&gt;1.ISA:指令集体系结构,是指一个处理器支持的指令和指令的字节级编码&lt;/p&gt;

&lt;p&gt;2.ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层,编译器编写者只需要知道允许哪些指令,以及它们是如何编码
的;而处理器设计者必须建造出执行这些指令的处理器&lt;/p&gt;

&lt;p&gt;3.ISA模型看上去应该是顺序指令执行,也就是先取出一条指令,等到它执行完毕,再开始下一条.然而,与一个时刻只执行一条指令
相比,通过同时处理金条指令的不同部分,处理器可以获得较高的性能(流水线),为了保证处理器能达到同顺序执行相同的结果,人
们采用了一些特殊的机制&lt;/p&gt;

&lt;p&gt;4.生产处理器的公司很少,但是研究处理器的设计人员的队伍已经非常巨大了,而且还在增大.一个主要的处理器设计的各个方面大
约涉及1000多人&lt;/p&gt;

&lt;p&gt;5.HCL:硬件控制语言,是一种描述硬件系统控制部分的简单语言&lt;/p&gt;

&lt;p&gt;6.基于顺序操作的功能正确但是有点不实用的Y86处理器是作者用的例子,基于这个顺序设计为基础,进行一系列的改造,创建一个
流水线化的处理器,这个流水线化的处理器将每条指令的执行分解成五步,处理器可以同时执行五条指令的不同阶段,为了使这个处
理器保留Y86 ISA的顺序的性质,要求处理很多冒险或冲突情况,冒险就是一条指令的位置或操作数信赖于其他仍在流水线中的指令&lt;/p&gt;

&lt;p&gt;7.指令集的一个重要性质就是字节编码必须有唯一的解释,任意一个字节序列要么是一个唯一的指令序列的编码,要么就不是一个
合法的字节序列&lt;/p&gt;

&lt;p&gt;8.通过将逻辑门组合成大的网,可以构造出能计算更加复杂函数的组合电路.算术/逻辑单元(ALU)是一种很重要的组合电路&lt;/p&gt;

&lt;p&gt;9.cpu的时钟频率也即工作频率,一般来说,一个时钟周期内完成的指令数是固定的,所以时钟频率越高,cpu的速度也就越快了,为什
么要有时钟可参考”通俗易懂的例子,好吧,分析一下抬轿子,八抬大轿,轿夫要一起用力,用力的方向和时间需一致,移轿中每
人的行进方向和速率也要一致,轿夫头负责喊号子,他的行动和速度是其它七个人的参照基点,这个轿夫头在某种意义上就是时
钟,没有这个轿夫头,八个人各行其事,轿子是无法到达目的地的,甚至都不能被抬离地面.” 4G的处理器表示这个处理器的时钟运行
频率是4GHz&lt;/p&gt;

&lt;p&gt;10.时钟寄存器存储单个位或字.时钟信号控制寄存器加载输入值.时钟信号上升时,输出=输入,时钟信号未上升时,输出=当前状态&lt;/p&gt;

&lt;p&gt;11.SEQ(“sequential”顺序的)处理器:每个时钟周期上,SEQ执行处理一条完整指令所有步骤.SEQ唯一的问题就是它太慢了.时钟必
须非常慢,以使信号能在一个周期内传播所有的阶段.SEQ的实现包括组合逻辑和两种存储器设备:时钟寄存器(程序计数器和条件码
寄存器),随机访问存储器(寄存器文件,指令存储器和数据存储器).组合逻辑不需要任何时序或控制——只要输入变化了,值就通
过逻辑门网络传播.SEQ这种方法不能充分利用硬件单元,因为每个单元只在整个时钟周期的一部分时间内才被使用,使用流水线可
获得更好的性能,流水线化的一个重要特性就是增加了系统的吞量,也就是单位时间内服务的顾客总数.&lt;/p&gt;

&lt;p&gt;12.指令的字节级编码如下图4-3,每条指令需要1-6个字节不等,每条指令的第一个字节表明指令的类型,这个字节分为两个部分:高
4位和低4位,高4位是代码(code)部分,低4位是功能(function)部分.如下图4-2中,代码值为0-0xB,功能值只有在一组相关指令共用
一个代码时才有用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;13.实现所有Y86指令所需要的计算可以组织成六个阶段:取指,译码,执行,访存,写回,更新pc.
取指:从程序计数器(PC)中读取指令指示符字节的两个四位部分,称为icode(指令代码)和ifun(指令功能)
译码:从寄存器文件读入最多两个操作数,得到值valA和/或valB.
执行:算术/逻辑单元(ALU)要么执行指令指明的操作(根据ifun的值),计算存储器引用的有效地址,要么增加或减少栈指针.得到的
值称为valE
访存:将数据写入存储器或从存储器读出数据,读出的值为valM
写回:最多可以写两个结果到寄存器文件
更新PC:将PC设置成下一条指令的地址&lt;/p&gt;

&lt;p&gt;如下图4-18是对OP1(整数和逻辑运算),rrmov1(寄存器-寄存器传送)和irmov1(立即数-寄存器传送)类型的指令所需的处理&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/csapp4-3.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/08/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>csapp</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>sqlmap以加载请求文件方式检测https服务器时存在的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap在扫描https类型的注入点的时候,当通过使用-r参数加载请求文件来检测有没有sql注入漏洞时,不能较好处理是否用ssl
通信,导致无法通过使用-r参数通过加载请求文件的方式自动检测是否是https协议,并因此无法检测出存在的注入点(需要人工添
加&lt;code class=&quot;highlighter-rouge&quot;&gt;--force-ssl&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;1.当requestFile(-r加载的请求文件)中有Referer参数且Referer的值中的hostname部分及port部分与requestFile中的Host参数的值
中的hostname与port部分相同,且Referer的值是https开头,认为这个requestFile的测试应该走ssl(也即走https通信)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google.com:6666/xxxooo/xxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.当requestFile(-r加载的请求文件)中的port值不为80且requestFile中有Referer参数且Referer的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;https://.*cdn.*&lt;/code&gt;的格式,这种情况也认为要走https通信&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eg:[requestFile]

POST /xxx/xxx/xxx/x.jsp?x=a HTTP/1.1
Host: www.google.com:6666
...
Referer: https://www.google-cdn.com/lllllllllllxxoo/xxx.jsp
...

xx=xxx&amp;amp;ooo=ooo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这种情况认为测试要走https通信,对应修改sqlmap中的lib/core/option.py中相关代码(&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/core/option.py&lt;/code&gt;),已提交pull request到sqlmap,对应下面的与conf.forceSSL相关的部分代码&lt;br /&gt;
&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/23/sqlmap%E4%BB%A5%E5%8A%A0%E8%BD%BD%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E6%A3%80%E6%B5%8Bhttps%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>https</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>selenium自动提交表单方案</title>
        <description>&lt;h3 id=&quot;0x00-refer&quot;&gt;0x00 Refer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wang02011/article/details/6299517&quot;&gt;1.常见的提交表单的方法&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/manors/archive/2010/03/11/1683727.html&quot;&gt;2.表单提交规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/32779563/how-can-i-click-submit-button&quot;&gt;3.selenium提交表单&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/17530104/selenium-webdriver-submit-vs-click&quot;&gt;4.selenium中click()和submit()的区别&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-about&quot;&gt;0x01 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;利用selenium自动提交表单,要求能适应绝大多数的未知html情况下的提交,以便自动获取页面中的表单中的所有要提交的参
数
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-detail&quot;&gt;0x02 Detail&lt;/h3&gt;

&lt;p&gt;1.先判断html中form action所在行能不能通过selenium(通过查找&lt;code class=&quot;highlighter-rouge&quot;&gt;find_element_by_css_selector('form')&lt;/code&gt;)找到,不行再看看form这行有没有id或name,再通过id或name找到并用selenium的submit()来提交&lt;/p&gt;

&lt;p&gt;2.如果1失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?submit('|&quot;)?.*&amp;gt;&lt;/code&gt;的提交按钮,找到后用selenium的click()来提交&lt;/p&gt;

&lt;p&gt;3.如果2失败再找&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input.*type=('|&quot;)?button('|&quot;)?.*onclick=.*&amp;gt;&lt;/code&gt;的通过js提交表单的行中的按钮,找到后用selenium的
click()来提交&lt;/p&gt;

&lt;p&gt;4.目前这样做无法处理用图片提交的表单,后期视情况增加或不加&lt;/p&gt;

&lt;h3 id=&quot;0x03-code&quot;&gt;0x03 Code&lt;/h3&gt;

&lt;p&gt;目前情况看,直接通过上面第1步中的用selenium查找form可定位目前遇到的所有表单,但是由于selenium在py3下还无法直接通过
selenium对form元素的submit()调用来获得提交的post参数(get参数是可以得到的),在获取表单提交的参数时采用正则查找参数
的方式来获取,相关具体处理如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if proxyUrl == &quot;&quot; or proxyUrl == 0:
        service_args_value = ['--ignore-ssl-errors=true', '--ssl-protocol=any', '--web-security=false']
    if proxyUrl != &quot;&quot; and proxyUrl != 0:
        proxyType = proxyUrl.split(&quot;:&quot;)[0]
        proxyValueWithType = proxyUrl.split(&quot;/&quot;)[-1]
        service_args_value = ['--ignore-ssl-errors=true', '--ssl-protocol=any', '--web-security=false',
                              '--proxy=%s' % proxyValueWithType, '--proxy-type=%s' % proxyType]
    # 有跳转的url最后的url如下
    # final_url=driver.current_url
    # print(&quot;正在访问的url是这个:\n&quot;+final_url)
    # driver.quit()

    try:
        from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
        if cookie != &quot;&quot;:
            dcap = dict(DesiredCapabilities.PHANTOMJS)
            dcap[&quot;phantomjs.page.settings.cookie&quot;] = cookie
            dcap[&quot;phantomjs.page.settings.userAgent&quot;] = get_random_ua()
            driver = webdriver.PhantomJS(service_args=service_args_value, desired_capabilities=dcap)
        else:
            driver = webdriver.PhantomJS(service_args=service_args_value)

        driver.implicitly_wait(10)
        driver.set_page_load_timeout(10)

        driver.get(url)
        # selenium webdriver操作cookie
        # http://www.cnblogs.com/fnng/p/3269450.html
        originalCookie = driver.get_cookies()

        import random
        # driver.get_screenshot_as_file(&quot;/tmp/PhantomJSPic&quot; +
        # get_http_domain_from_url(url).split(&quot;/&quot;)[-1] + str(random.random()))
        # selenium无法得到code,先根据返回titile和内容来看如果是正常返回,则这里将code赋值为200
        # 如果title和内容异常(如包含&quot;页面不存在&quot;),则将这个请求重新发给get_request(url,by=&quot;MechanicalSoup&quot;)
        # 这里将正常的http网页用phantomJS来请求,如果发现异常则交给MechanicalSoup重新访问
        code = 200
        title = driver.title
        content = driver.page_source
        # 表单页面处理
        try:
            form = driver.find_element_by_css_selector('form').submit()
            hasFormAction = True
            if &quot;?&quot; in driver.current_url or re.search(r'''&amp;lt;form[^&amp;lt;&amp;gt;]*method=('|&quot;)?get('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                # 说明是get请求提交的参数
                # get提交表单的处理
                formActionValue = driver.current_url
            else:
                if re.search(r'''&amp;lt;form[^&amp;lt;&amp;gt;]*method=('|&quot;)?post('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                    # post提交表单的处理采用自行查找所有表单中的参数
                    # post的测试url中有^,这是人为添加的,便于放到数据库中
                    formActionValue += (driver.current_url + &quot;^&quot;)
                else:
                    # 其他情况当作get请求,并用正则找出表单中的参数(不用selenium的submit)
                    formActionValue += (driver.current_url + &quot;?&quot;)

                inputParamList = re.findall(
                    r'''(&amp;lt;input[^&amp;lt;&amp;gt;]*name=('|&quot;)?([^'&quot;&amp;lt;&amp;gt;\s]+)('|&quot;)?[^&amp;lt;&amp;gt;]*&amp;gt;)''', content, re.I)
                paramPartValue = &quot;&quot;
                paramNameList = []
                for each in inputParamList:
                    paramName = each[2]
                    if paramName not in paramNameList:
                        # 防止有重复的参数
                        paramNameList.append(paramName)
                        if re.search(r'''type=('|&quot;)?hidden('|&quot;)?''', each[0], re.I):
                            # 处理hidden类型的参数
                            hiddenParamValue = re.search(
                                r'''value=('|&quot;)?([^'&quot;&amp;lt;&amp;gt;\s]*)('|&quot;)?''', each[0], re.I).group(2)
                            paramPartValue += (paramName + &quot;=&quot; + hiddenParamValue + &quot;&amp;amp;&quot;)
                        elif re.search(r'''required=('|&quot;)?required('|&quot;)?''', each[0], re.I):
                            # 处理必须要填的参数
                            paramPartValue += (paramName + &quot;=requiredParamValue&amp;amp;&quot;)
                        else:
                            # 处理不是hidden也不是required类的参数的处理
                            paramPartValue += (paramName + &quot;=&amp;amp;&quot;)
                if paramPartValue[-1] == &quot;&amp;amp;&quot;:
                    paramPartValue = paramPartValue[:-1]

                formActionValue += paramPartValue

        except selenium.common.exceptions.NoSuchElementException:
            hasFormAction = False
            print(&quot;没找到这个元素哟...&quot;)
        print(&quot;len content is :\n&quot; + str(len(content)))
        print(&quot;title is :\n&quot; + title)
        if re.search(r&quot;(页面不存在)|(未找到页面)|(page\s+not\s+found)|(404\s+not\s+found)&quot;, content, re.I) or re.search(r&quot;404&quot;, title, re.I):
            if re.search(r'''&amp;lt;form\s+[^&amp;lt;&amp;gt;]*&amp;gt;''', content, re.I):
                input(&quot;需要调整代码!!!!!!!!!&quot;)
            else:
                return get_request(url, by=&quot;MechanicalSoup&quot;)
        # time.sleep(5) # Let the user actually see something!
        # driver.quit()

    except TimeoutException as e:
        # Handle your exception here
        print(e)
    finally:
        driver.quit()

    return {
        'code': code,
        'title': title,
        # 下面比较特殊,PhantomJS得到的html不用decode,直接就是string类型
        'content': content,
        #True or False
        'hasFormAction': hasFormAction,
        # eg,https://www.baidu.com^a=1&amp;amp;b=2
        # eg,https://www.baidu.com/?a=1&amp;amp;b=2
        # 上面?表示formAction对应get请求,^表示formAction对应post请求
        'formActionValue': formActionValue}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 21 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/21/selenium%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95%E6%96%B9%E6%A1%88/</guid>
        
        <category>python</category>
        
        <category>selenium</category>
        
        <category>form</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>sqlmap对状态码404处理的bug</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;sqlmap对页面遇到404响应码后直接抛出一个异常并退出sqlmap不再进行后续的paylaod测试,在用sqlmap测试sql注入点的时候,一
般用到&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数来节省时间,这种情况下sqlmap有一处对http状态码404的处理不当导致无法测出注入点的bug&lt;/p&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;p&gt;在爬虫时get请求的url可轻易爬到,但是post请求的url及post的数据的取得需要探测html中有没有表单相关的关键字,并通过表单
来构造post参数的值并提交来获取后续返回内容,如下例中详情:&lt;/p&gt;

&lt;p&gt;安装dvwa设置level=low,测试&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL Injection(Blind)&lt;/code&gt;这一项时,参数是通过表单来提交的,点击&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;提交后会将输入框&lt;code class=&quot;highlighter-rouge&quot;&gt;User
ID&lt;/code&gt;中的内容以get请求发送到服务器,例如在文本框中输入1则浏览器将对应访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/sqlmap404bug-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尝试用sqlmap跑出这个注入点,语句如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=1&amp;amp;Submit=Submit#&quot; --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样是可以跑出来的,但是要提高效率用工具自动发现这个漏洞时,一般这样用sqlmap:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlmap -u &quot;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms --batch -v 3 --cookie='...'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于这里的id参数的值通过爬虫无法获得,因为这个id参数的值是通过表单提交的,爬虫最多可得到的url为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Submit&lt;/code&gt;按钮对应的应该是js处理的动作,js将表单通过get请求发送到服务器,这种情况下,需要用selenium+phantomjs
来获得上面的url(或者使用sqlmap中的&lt;code class=&quot;highlighter-rouge&quot;&gt;--forms&lt;/code&gt;参数来捕获这样的表单),而就算得到了url,由于这个url中的&lt;code class=&quot;highlighter-rouge&quot;&gt;id=&lt;/code&gt;,也即id值为空,
这种情况下,sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数的处理是随机赋值给id并测试各种payload(eg,id=1389),然而dvwa中的这个页面在服务器上的
处理并不一般,如果用户提交的id参数在服务器上没有查询到,服务器会响应404状态码(可能一般waf也会这样做),而sqlmap遇到
404状态码,直接就抛出异常并退出了,这样导致无法用sqlmap的&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch&lt;/code&gt;参数测出这个sql注入点&lt;/p&gt;

&lt;p&gt;其实如果用selenium+phantomjs得到了url&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit#&lt;/code&gt;后
如果服务器正常响应查询(这里的dvwa不正常响应,对查不到的统一返回404状态码),用sqlmap是可以检测到这种不带具体值的参数
类型url的注入点的,但是要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--risk=3&lt;/code&gt;,默认的sqlmap的risk值为1,为1时sqlmap不会测试&lt;code class=&quot;highlighter-rouge&quot;&gt;' or [sqli] and '1'='1&lt;/code&gt;(要测出
不带参数值的参数的注入点则要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt;来测试),也即要发挥sqlmap的功能最好设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--batch --risk=3 --forms&lt;/code&gt;.试试直接用这种
方法测试上面的注入点(在dvwa中对应的页面为&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.8.190/dvwa/vulnerabilities/sqli_blind/&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
        ___
       __H__
 ___ ___[']_____ ___ ___  {1.1.8.6#dev}
|_ -| . [(]     | .'| . |
|___|_  [&quot;]_|_|_|__,|  _|
      |_|V          |_|   http://sqlmap.org

[!] legal disclaimer: Usage of sqlmap for attacking targets without prior mutual consent is illegal. It is the end user's responsibility to obey all applicable local, state and federal laws. Developers assume no liability and are not responsible for any misuse or damage caused by this program

[*] starting at 14:40:30

[14:40:30] [DEBUG] cleaning up configuration parameters
[14:40:30] [DEBUG] setting the HTTP timeout
[14:40:30] [DEBUG] setting the HTTP Cookie header
[14:40:30] [DEBUG] creating HTTP requests opener object
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [INFO] testing connection to the target URL
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [INFO] searching for forms
[14:40:30] [DEBUG] initializing the knowledge base
[#1] form:
GET http://192.168.8.190:80/dvwa/vulnerabilities/sqli_blind/?id=&amp;amp;Submit=Submit
Cookie: PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low
do you want to test this form? [Y/n/q]
&amp;gt; Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
Edit GET data [default: id=&amp;amp;Submit=Submit]: id=&amp;amp;Submit=Submit
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
do you want to fill blank fields with random values? [Y/n] Y
[14:40:30] [DEBUG] used the default behaviour, running in batch mode
[14:40:30] [INFO] resuming back-end DBMS 'mysql'
[14:40:30] [INFO] using '/var/root/.sqlmap/output/results-08202017_0240pm.csv' as the CSV results file in multiple targets mode
[14:40:30] [DEBUG] resolving hostname '192.168.8.190'
[14:40:30] [DEBUG] declared web page charset 'utf-8'
[14:40:30] [CRITICAL] page not found (404)
[14:40:30] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 1 times
[14:40:30] [INFO] you can find results of scanning in multiple targets mode inside the CSV file '/var/root/.sqlmap/output/results-08202017_0240pm.csv'

[*] shutting down at 14:40:30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现sqlmap跑不出来,尝试修改sqlmap代码,结果中有关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;page not found (404)&lt;/code&gt;,于是定位相关代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /tmp/sqlmap &amp;amp;&amp;amp; grep -r &quot;page not found&quot; .
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./lib/request/connect.py:                    errMsg = &quot;page not found (%d)&quot; % code
./lib/request/connect.py:                    debugMsg = &quot;page not found (%d)&quot; % code
./lib/utils/crawler.py:                    if &quot;page not found&quot; in getSafeExString(ex):
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;于是修改./lib/request/connect.py中代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;elif ex.code == httplib.NOT_FOUND:
    if raise404:
        errMsg = &quot;page not found (%d)&quot; % code
        raise SqlmapConnectionException(errMsg)
    else:
        debugMsg = &quot;page not found (%d)&quot; % code
        singleTimeLogMessage(debugMsg, logging.DEBUG)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其中的raise SqlmapConnectionException(errMsg)注释掉后再重新用刚才的sqlmap语句测试可测出这个注入点,详情如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/tmp/sqlmap [master●] » python2 sqlmap.py -u &quot;192.168.8.190/dvwa/vulnerabilities/sqli_blind/&quot; --forms -v 3 --cookie='PHPSESSID=glgav33fgc0l1hoikg5f267j51;security=low' --risk 3 --batch
[14:48:41] [DEBUG] checking for filtered characters
[14:48:41] [PAYLOAD] OOFt' OR 6597=IF((3988&amp;gt;3987),SLEEP(5),6597) AND 'sIjt'='sIjt
GET parameter 'id' is vulnerable. Do you want to keep testing the others (if any)? [y/N] N
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
sqlmap identified the following injection point(s) with a total of 146 HTTP(s) requests:
    ---
Parameter: id (GET)
    Type: AND/OR time-based blind
    Title: MySQL &amp;gt;= 5.0.12 OR time-based blind
    Payload: id=OOFt' OR SLEEP(5) AND 'CaKs'='CaKs&amp;amp;Submit=Submit
    Vector: OR [RANDNUM]=IF(([INFERENCE]),SLEEP([SLEEPTIME]),[RANDNUM])
    ---
do you want to exploit this SQL injection? [Y/n] Y
[14:49:06] [DEBUG] used the default behaviour, running in batch mode
[14:49:06] [INFO] the back-end DBMS is MySQL
web server operating system: Linux Debian
web application technology: Apache 2.4.25
back-end DBMS: MySQL &amp;gt;= 5.0.12
[14:49:06] [WARNING] HTTP error codes detected during run:
404 (Not Found) - 131 times
[14:49:06] [INFO] you can find results of scanning in multiple targets mode inside the CSV file
'/var/root/.sqlmap/output/results-08202017_0246pm.csv'

[*] shutting down at 14:49:06
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;已提交pull request到sqlmap,相关代码文件为&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/request/connect.py&lt;/code&gt;,&lt;a href=&quot;https://github.com/sqlmapproject/sqlmap/pull/2663&quot;&gt;follow&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 20 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/08/20/sqlmap%E5%AF%B9%E7%8A%B6%E6%80%81%E7%A0%81404%E5%A4%84%E7%90%86%E7%9A%84bug/</guid>
        
        <category>sqlmap</category>
        
        <category>python</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
