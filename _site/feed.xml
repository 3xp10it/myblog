<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 10 Apr 2018 08:09:37 +0800</pubDate>
    <lastBuildDate>Tue, 10 Apr 2018 08:09:37 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>港股基础概念</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stock.qq.com/a/20180129/012522.htm&quot;&gt;窝轮与牛熊证&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://finance.sina.com.cn/stock/hkstock/warrants/20090206/15065826186.shtml&quot;&gt;牛熊证回收价与行使价&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 07 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2018/04/07/%E6%B8%AF%E8%82%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%82%92%E8%82%A1/2018/04/07/%E6%B8%AF%E8%82%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
        
        <category>炒股</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>alfred--快速切换至目标应用程序</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;本文介绍通过使用alfred的workflows功能快速切换至后台中的目标应用程序的方法.在使用macOS时,一般会使用到多个app,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app1.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在使用iterm2时想切换至pd的kali机上(图中第6个图标),或者在pd的kali机上想切换到firefox上,或者当前在任意app中想切换到另一个指定的app时直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+tab&lt;/code&gt;效率较低,可通过alfred的workflows功能实现&lt;code class=&quot;highlighter-rouge&quot;&gt;一键切换&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;p&gt;最终实现3个应用程序的快速切换快捷键:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;firefox 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;pd的kali机 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+p&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;pd的iterm2 对应 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd+i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;alfred完成如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app2.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以其中pd的kali机为例,&lt;code class=&quot;highlighter-rouge&quot;&gt;Hotkey&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Launch App/Files&lt;/code&gt;详情分别如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app3.png&quot; alt=&quot;3&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alfred_quick_switch_app4.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2018/03/29/alfred-%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E8%87%B3%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2018/03/29/alfred-%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E8%87%B3%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
        
        <category>alfred</category>
        
        <category>效率</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>流畅的python第5-7章笔记</title>
        <description>&lt;h2 id=&quot;把函数视作对象&quot;&gt;把函数视作对象&lt;/h2&gt;

&lt;h3 id=&quot;第5章-一等函数&quot;&gt;第5章 一等函数&lt;/h3&gt;

&lt;p&gt;1.在函数式编程范式中,最为人熟知的高阶函数有&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;.函数式语言通常会提供map,filter和reduce三个高阶函数(有时使用不同的名称).在python3中,map和filter还是内置函数,但是由于引入了列表推导和生成器表达式,它们变得没那么重要了.列表推导和生成器表达式具有map和filter两个函数的功能.而且更易于阅读.&lt;/p&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;sum&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;函数用于求和.最好使用sum函数,可读性更好.sum和reduce的通用思想是把某个操作连续应用到序列的元素上,累计之前的结果,把一系列值&lt;code class=&quot;highlighter-rouge&quot;&gt;归约&lt;/code&gt;成一个值.&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt;也是内置的归约函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [2]: from functools import reduce

In [3]: from operator import add

In [4]: reduce(add,range(100))
Out[4]: 4950

In [5]: sum(range(100))
Out[5]: 4950


In [6]: all('niaho')
Out[6]: True

In [7]: all('niaho',['wohao'])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-7-663ce7255241&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 all('niaho',['wohao'])

TypeError: all() takes exactly one argument (2 given)

In [8]: all(('niaho',['wohao']))
Out[8]: True

In [9]: all(('niaho',['wohao'],''))
Out[9]: False

In [10]: any('niaho')
Out[10]: True

In [12]: any('niaho',['wohao'])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-12-3e515d3dba5a&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 any('niaho',['wohao'])

TypeError: any() takes exactly one argument (2 given)

In [13]: any(('niaho',['wohao'],''))
Out[13]: True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.为了使用高阶函数,有时创建一次性的小型函数更便利.这便是匿名函数存在的原因.lambda关键字在python表达式内创建匿名函数.然而,python简单的句法限制了lambda函数的定义体只能使用纯表达式.换句话说,lambda函数的定义体中不能赋值,也不能使用while和try等python语句.eval函数好像也是这样.除了作为参数传给高阶函数之外,python很少使用匿名函数.由于句法上的限制,非平凡的lambda表达式要么难以阅读,要么无法写出.lambda句法只是语法糖:与def语句一样,lambda表达式会创建函数对象&lt;/p&gt;

&lt;p&gt;4.python数据模型文档列出了7种可调用对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户定义的函数.使用def或lambda表达式创建&lt;/li&gt;
  &lt;li&gt;内置函数.使用c语言(cpython)实现的函数,如len或time.strftime&lt;/li&gt;
  &lt;li&gt;内置方法.使用c语言实现的方法,如dict.get&lt;/li&gt;
  &lt;li&gt;方法.在类的定义体中定义的函数&lt;/li&gt;
  &lt;li&gt;类.调用类时会运行类的&lt;code class=&quot;highlighter-rouge&quot;&gt;__new__&lt;/code&gt;方法创建一个实例,然后运行__init__方法,初始化实例,最后把实例返回给调用方&lt;/li&gt;
  &lt;li&gt;类的实例.如果类定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;__call__&lt;/code&gt;方法,那么它的实例可以作为函数调用&lt;/li&gt;
  &lt;li&gt;生成器函数.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;yield&lt;/code&gt;关键字的函数或方法.调用生成器函数返回的是生成器对象,生成器函数还可以作为协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.从定位参数到仅限关键字参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [17]: my_tag={'name':'img','title':'Sunset Boulevard','src':'sunset.jpg','cls':'framed'}

In [18]: tag(**my_tag)
name is:img
content is:()
cls is:framed
attrs is:{'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}

In [19]: def tag(name,*content,cls=None,**attrs):
    ...:     print(&quot;name is:&quot;+name)
    ...:     print(&quot;content is:&quot;+str(content))
    ...:     print(&quot;cls is:&quot;+str(cls))
    ...:     print(&quot;attrs is:&quot;+str(attrs))
    ...:
    ...:

In [20]: tag('p','hello')
name is:p
content is:('hello',)
cls is:None
attrs is:{}

In [21]: my_tag={'name':'img','title':'Sunset Boulevard','src':'sunset.jpg','cls':'framed'}

In [22]: tag(**my_tag)
name is:img
content is:()
cls is:framed
attrs is:{'title': 'Sunset Boulevard', 'src': 'sunset.jpg'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;tag('p','hello')&lt;/code&gt;时,第一个参数后面的任意个参数会被&lt;code class=&quot;highlighter-rouge&quot;&gt;*content&lt;/code&gt;捕获,存入一个元组
调用&lt;code class=&quot;highlighter-rouge&quot;&gt;tag(**my_tag)&lt;/code&gt;时,在my_tag前面加上&lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;,字典中的所有元素作为单个参数传入,同名键会绑定到对应的具名参数上,余下的则被&lt;code class=&quot;highlighter-rouge&quot;&gt;**attrs&lt;/code&gt;捕获&lt;/p&gt;

&lt;p&gt;6.函数对象有个&lt;code class=&quot;highlighter-rouge&quot;&gt;__defaults__&lt;/code&gt;属性,它的值是一个元组,里面保存着定位参数和关键字参数的默认值.仅限关键字参数的默认值在&lt;code class=&quot;highlighter-rouge&quot;&gt;__kwdefaults__&lt;/code&gt;属性中.然而,参数的名称在&lt;code class=&quot;highlighter-rouge&quot;&gt;__code__&lt;/code&gt;属性中,它的值是一个code对象引用,自身也有很多属性如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [31]: def tag(name,*content,cls=666,**attrs):
    ...:     print(&quot;name is:&quot;+name)

In [32]: tag.__defaults__

In [33]: tag.__kwdefaults__
Out[33]: {'cls': 666}

In [34]: tag.__code__
Out[34]: &amp;lt;code object tag at 0x102288540, file &quot;&amp;lt;ipython-input-31-7396c504e34a&amp;gt;&quot;, line 1&amp;gt;

In [35]: tag.__code__.co_name
Out[35]: 'tag'

In [36]: tag.__code__.co_names
Out[36]: ('print',)

In [37]: tag.__code__.co_varnames
Out[37]: ('name', 'cls', 'content', 'attrs')

In [38]: tag.__code__.co_argcount
Out[38]: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;第6章-使用一等函数实现设计模式&quot;&gt;第6章 使用一等函数实现设计模式&lt;/h3&gt;

&lt;p&gt;1.&lt;/p&gt;

&lt;h3 id=&quot;第7章-函数装饰器和闭包&quot;&gt;第7章 函数装饰器和闭包&lt;/h3&gt;

&lt;p&gt;1.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2018/03/01/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC5-7%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/03/01/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC5-7%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>流畅的python第4章笔记</title>
        <description>&lt;h3 id=&quot;文本和字节序列&quot;&gt;文本和字节序列&lt;/h3&gt;

&lt;p&gt;1.unicode与utf-8的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;关系&lt;/a&gt;
UTF-8就是在互联网上使用最广的一种unicode的实现方式(80%的网站已经使用UTF8),这是为传输而设计的编码,并使编码无国界,这样就可以显示全世界上所有文化的字符了.UTF-8最大的一个特点,就是它是一种变长的编码方式.它可以使用1~4个字节表示一个符号,根据不同的符号而变化字节长度,当字符在ASCII码的范围时,就用一个字节表示,保留了ASCII字符一个字节的编码做为它的一部分,注意的是unicode一个中文字符占2个字节,而UTF-8一个中文字符占3个字节)&lt;/p&gt;

&lt;p&gt;2.struct模块提供了一些函数,把字节序列转换成不同类型字段组成的元组(&lt;code class=&quot;highlighter-rouge&quot;&gt;struct.unpack&lt;/code&gt;),还有一些函数用于执行反向转换,把元组转换成字节序列(&lt;code class=&quot;highlighter-rouge&quot;&gt;struct.pack&lt;/code&gt;).struct模块能处理bytes,bytearray和memoryview对象&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [62]: struct.unpack('ii',b'\x0c\x00\x00\x00\r\x00\x00\x00')
Out[62]: (12, 13)

In [63]: struct.pack('ii',12,13)
Out[63]: b'\x0c\x00\x00\x00\r\x00\x00\x00'


In [70]: import struct

In [71]: with open('/Users/3xp10it/Downloads/1.gif','rb') as fp:
    ...:     img=memoryview(fp.read())

In [72]: img
Out[72]: &amp;lt;memory at 0x109972e88&amp;gt;

In [73]: header=img[:10]

In [74]: header
Out[74]: &amp;lt;memory at 0x109c13048&amp;gt;

In [75]: bytes(header)
Out[75]: b'GIF89a\x90\x01\x90\x01'

In [76]: fmt='&amp;lt;3s3sHH'

In [77]: struct.unpack(fmt,header)
Out[77]: (b'GIF', b'89a', 400, 400)

In [78]: del header

In [79]: del img
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.python自带了超过100种编解码器,用于在文本和字节之间相互转换.每个编解码器都有一个名称,如’utf_8’,而且经常有几个别名,如’utf8’,’utf-8’,’U8’.&lt;/p&gt;

&lt;p&gt;4.python3允许在源码中使用非ascii标识符.有些人不喜欢这么做.支持始终使用ascii标识符的人认为,这样便于所有人阅读和编辑代码.这些人没切中要害:源码应该便于目标群体阅读和编辑,而不是”所有人”.如果代码属于跨国公司,或者是开源的,想让来自世界各地的人作贡献,那么标识符应该使用英语,也就是说只能使用ascii字符.但是,如果你是巴西的一位老师,那么使用葡萄牙语正确拼写变量和函数名更便于学生阅读代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [81]: 笔='钢笔'

In [82]: print(笔)
钢笔
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.utf8的一在优势是,不管设备使用哪种字节序(大端或小端),生成的字节序列始终一致,因此不需要BOM(在文件头部的字节序标记,一些编辑器会给文件加BOM,如notepad).尽管如此,某些windows应用(如notepad)还是会在utf8编码的文件中添加BOM;而且,EXCEL会根据有没有BOM确定文件是不是UTF8编码&lt;/p&gt;

&lt;p&gt;6.需要在多台设备中或多种场合下运行的代码,一定不能依赖默认编码.打开文件时始终应该明确传入encoding参数,因为不同的设备使用的默认编码可能不同,有时隔一天也会发生变化&lt;/p&gt;

&lt;p&gt;7.&lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;会把string表达的内容当作代码执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [89]: eval('print(111)')
111

In [90]: a='[1,2]'
In [91]: eval(a)
Out[91]: [1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.windows中,&lt;code class=&quot;highlighter-rouge&quot;&gt;locale.getpreferredencoding()&lt;/code&gt;返回的编码是最重要的:这是打开文件的默认编码,也是重定向到文件的sys.stdout/stdin/stderr的默认编码.关于编码默认值的最佳建议是:别依赖默认值&lt;/p&gt;

</description>
        <pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2018/02/28/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/02/28/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC4%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>流畅的python第3章笔记</title>
        <description>&lt;h3 id=&quot;字典和集合&quot;&gt;字典和集合&lt;/h3&gt;

&lt;p&gt;1.散列表是字典类型性能出众的根本原因&lt;/p&gt;

&lt;p&gt;2.字典推导&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [2]: dial_codes=[(86,'china'),(91,'india'),(1,'US')]

In [3]: country_code={country: code for code,country in dial_codes}

In [4]: country_code
Out[4]: {'US': 1, 'china': 86, 'india': 91}

In [5]: country_code={country.upper(): code for code,country in dial_codes}

In [6]: country_code
Out[6]: {'CHINA': 86, 'INDIA': 91, 'US': 1}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.大多数映射类型都提供了两个很强大的方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;setdefault&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;.setdefault方法可以用来更新字典里存放的可变值(比如列表),从而避免了重复的键搜索.&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;方法则让批量更新成为可能,它可以用来插入新值或者更新已有键值对,它的参数可以是包含(key,value)这种键值对的可迭代对象,或者关键字参数.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dict的setdefault用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [18]: a = {'runoob': '菜鸟教程', 'google': 'Google 搜索'}

In [19]: a.setdefault('test','lalala')
Out[19]: 'lalala'

In [20]: a
Out[20]: {'google': 'Google 搜索', 'runoob': '菜鸟教程', 'test': 'lalala'}

In [21]: a.setdefault('runoob','lalala')
Out[21]: '菜鸟教程'

In [22]: a
Out[22]: {'google': 'Google 搜索', 'runoob': '菜鸟教程', 'test': 'lalala'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;dict的update用法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [37]: a
Out[37]: {'dajiahao': 'shide', 'nihao': 'wohao'}

In [38]: b={'nihao':'lala'}

In [39]: a.update(b)

In [40]: a
Out[40]: {'dajiahao': 'shide', 'nihao': 'lala'}

In [41]: b={'sho':'lll'}

In [42]: a.update(b)

In [43]: a
Out[43]: {'dajiahao': 'shide', 'nihao': 'lala', 'sho': 'lll'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.有时候为了方便起见,就算某个键在映射里不存在,我们也希望在通过这个键读取值的时候能得到一个默认值.有两个途径能帮我们达到这个目的.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a.通过&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.defaultdict&lt;/code&gt;这个类型而不是普通的dict&lt;/li&gt;
  &lt;li&gt;b.给自己定义一个dict的子类,然后在子类中实现&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法,如:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class StrKeyDict0(dict):

    def __missing__(self,key):
        if isinstance(key,str):
            raise KeyError(key)
        return self[str(key)]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有的映射类型在处理找不到的键的时候,都会牵扯到&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法.虽然基类dict并没有定义这个方法,但是dict是知道有这么个东西存在的.&lt;code class=&quot;highlighter-rouge&quot;&gt;__missing__&lt;/code&gt;方法只会被&lt;code class=&quot;highlighter-rouge&quot;&gt;__getitem__&lt;/code&gt;调用(比如在表达式&lt;code class=&quot;highlighter-rouge&quot;&gt;d[k]&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;5.字典的变种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.OrderdDict&lt;/code&gt;:这个类型在添加键的时候会保持顺序,因此键的迭代次序问题一致的.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.ChainMap&lt;/code&gt;:该类型可以容纳数个不同的映射对象,然后在进行键查找操作的时候,这些对象会被当作一个整体被逐个查找,直到键被找到为止.这个功能在给有嵌套作用域的语言做解释器的时候很有用,可以用一个映射对象来代表一个作用域的上下文&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.Counter&lt;/code&gt;:这个映射类型会给键准备一个整数计数器.每次更新一个键的时候都会增加这个计数器&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;collections.UserDict&lt;/code&gt;:这个类其实就是把标准dict用纯python又实现了一遍.就创造自定义映射类型来说,以UserDict为基类,总比普通的dict为基类要来得方便,更倾向于从UserDict而不是从dict继承的主要原因是,后者有时会在某些方法的实现上走一些捷径,导致我们不得不在它的子类中重写这些方法,但是UserDict就不会带来这些问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.不可变的字典类型&lt;/p&gt;

&lt;p&gt;标准库里所有的映射类型都是可变的,但有时候你会有这样的需求,比如不能让用户错误地修改某个映射.从python3.3开始,types模块中引入了一个封装类名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;MappingProxyType&lt;/code&gt;,如果给这个类一个映射,它会返回一个只读的映射视图.虽然是个只读视图,但是它是动态的.如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [44]: from types import MappingProxyType

In [45]: d={1:'A'}

In [46]: d_proxy=MappingProxyType(d)

In [47]: d_proxy
Out[47]: mappingproxy({1: 'A'})

In [48]: d_proxy[1]
Out[48]: 'A'

In [49]: d_proxy[2]='x'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&amp;lt;ipython-input-49-cb84dba8e1f4&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 d_proxy[2]='x'

TypeError: 'mappingproxy' object does not support item assignment

In [50]: d[2]='B'

In [51]: d_proxy
Out[51]: mappingproxy({1: 'A', 2: 'B'})

In [52]: d_proxy[2]
Out[52]: 'B'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.集合&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a.&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;是可变集合,&lt;code class=&quot;highlighter-rouge&quot;&gt;frozenset&lt;/code&gt;是不可变集合,区别在&lt;a href=&quot;http://blog.csdn.net/monkeyduck/article/details/18036381&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;b.集合的本质是许多唯一对象的聚集.因此,集合可以用于去重:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [58]: a=[1,2,3,2]

In [59]: set(a)
Out[59]: {1, 2, 3}

In [60]: list(set(a))
Out[60]: [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;c.给定两个集合a和b,&lt;code class=&quot;highlighter-rouge&quot;&gt;a|b&lt;/code&gt;返回的是它们的合集,&lt;code class=&quot;highlighter-rouge&quot;&gt;a&amp;amp;b&lt;/code&gt;得到的交集,而&lt;code class=&quot;highlighter-rouge&quot;&gt;a-b&lt;/code&gt;得到的是差集.合理地利用这些操作,不仅能够让代码的行数变少,不能减少python程序的运行时间.这样做同时也是为了让代码更易读,从而更容易判断程序的正确性,因为利用这些运算符可以省去不必要的循环和逻辑操作&lt;/li&gt;
  &lt;li&gt;d.如果要创建一个空集,必须用不带任何参数的构造方法&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;.如果写成&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;的形式,跟以前一样,你创建的其实是个空字典.&lt;/li&gt;
  &lt;li&gt;e.像&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1,2,3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;这种字面量句法相比于构造方法&lt;code class=&quot;highlighter-rouge&quot;&gt;set([1,2,3])&lt;/code&gt;要更快且更易读,原因如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [61]: from dis import dis

In [62]: dis('{1,2,3}')
  1           0 LOAD_CONST               0 (1)
              2 LOAD_CONST               1 (2)
              4 LOAD_CONST               2 (3)
              6 BUILD_SET                3
              8 RETURN_VALUE

In [63]: dis('set([1,2,3])')
  1           0 LOAD_NAME                0 (set)
              2 LOAD_CONST               0 (1)
              4 LOAD_CONST               1 (2)
              6 LOAD_CONST               2 (3)
              8 BUILD_LIST               3
             10 CALL_FUNCTION            1
             12 RETURN_VALUE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;f.python里没有针对frozenset的特殊字面量句法,只能采用构造方法,如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [64]: frozenset([1,2,3])
Out[64]: frozenset({1, 2, 3})

In [69]: frozenset(range(10))
Out[69]: frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})

In [67]: list(range(10))
Out[67]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [68]: set(range(10))
Out[68]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;集合推导用法,如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [70]: {i.upper() for i in 'abc'}
Out[70]: {'A', 'B', 'C'}

In [71]: {i.upper() for i in ['a','b','c']}
Out[71]: {'A', 'B', 'C'}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.dict和set的速度很快,如果在你的程序里有任何的磁盘输入/输出,那么不管查询有多少个元素的字典或集合,所耗费的时间都能忽略不计(前提是字典或集合不超过内存大小)&lt;/p&gt;

&lt;p&gt;9.相比之下,列表慢,列表的背后没有散列表来支持in运算符,每次搜索都需要扫描一次完整的列表,所以慢&lt;/p&gt;

&lt;p&gt;10.字典中的散列表
 python用散列表实现dict类型.散列表其实是一个稀疏数组(总是有空白元素的数组猜测为稀疏数组).在一般的数据结构教材中,散列表里的单元通常叫作表元.在dict的散列表中,每个键值对都占用一个表元,每个表元都有两个部分,一个是对键的引用,另一个是值的引用.因为所有表元的大小一致,所以可以通过偏移量来读取某个表元.如果要把一个对象放入散列表,那么首先要计算这个元素键的散列值.在插入新值时,python可能会按照散列表的拥挤程度来决定是不要重新分配内存为它扩容,如果增加了散列表的大小,那散列值所占的位数和用作索引的位数都会随之增加,这样做的目的是为了减少发生散列冲突的概率&lt;/p&gt;

&lt;p&gt;11.dict的实现及其导致的结果&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1) 键必须是可散列的.一个或散列的对象必须满足以下要求:
    &lt;ul&gt;
      &lt;li&gt;a) 支持hash()函数,并且通过__hash__()方法所得到的散列值是不变的&lt;/li&gt;
      &lt;li&gt;b) 支持通过__eq__()方法来检测相等性&lt;/li&gt;
      &lt;li&gt;c) 若a==b为真,则hash(a)==hash(b)也为真
  所有由用户自定义的对象默认都是可散列的,因为它们的散列值由id()来获取,而且它们都是不相等的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2) 字典在内存上的开销巨大
  由于字典使用了散列表,而散列表又必须是稀疏的,这导致它在空间上的效率低下.举例而言,如果你需要存放数量巨大的记录,那么放在由元组或具名元组构成的列表中会是比较好的选择;最好不要根据json风格,用由字典组成的列表来存放这些记录.用元组取代字典就能节省空间的原因有两个:其一是避免了散列表所耗费的空间,其二是无需把记录中字段的名字在每个元素里都存一遍.不过,如果机器的内存足够用,还是用字典吧.&lt;/li&gt;
  &lt;li&gt;3) 键查询很快.dict的实现是典型的空间换时间(内存换查询速度),字典类型有关巨大的内存开销,但它们提供了无视数据量大小的快速访问–只要字典能被装在内存里&lt;/li&gt;
  &lt;li&gt;4) 键的次序取决于添加顺序.由dict([key1,value1],[key2,value2])和dict([key2,value2],[key1,value1])得到的两个字典,在进行比较的时候,它们是相等的&lt;/li&gt;
  &lt;li&gt;5) 往字典里添加关机键可能会改变已有键的顺序.无论何时往字典里添加新的键,python解释器都可能做出为字典扩容的决定.扩容导致的结果就是要新建一个更大的散列表,并把字典里已有的元素添加到新表里.这个过程可能会发生新的散列冲突,导致新散列表中键的次序变化.如果你在迭代一个字典的所有键的过程中同时对字典进行修改,那么这个循环很有可能会跳过一些键–甚至是跳过那些字典中已经有的键.由此可知,不要对字典同时进行迭代和修改,如果想扫描并修改一个字典,最好分成不同步来进行:首先对字典迭代,以得出需要添加的内容,把这些内容放在一个新字典里;迭代结束之后再对原有字典进行更新.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12.set和frozenset的实现也依赖散列表,但在它们的散列表里存放的只有元素的引用(就像在字典里只存放键而没有相应的值).字典和散列表的特点对集合来说几乎都是适用的,如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;集合里的元素必须是可散列的&lt;/li&gt;
  &lt;li&gt;集合很消耗内存&lt;/li&gt;
  &lt;li&gt;可以很高效地判断元素是不存在于某个集合&lt;/li&gt;
  &lt;li&gt;元素的次序取决于被添加到集合里的次序&lt;/li&gt;
  &lt;li&gt;往集合里添加元素,可能会改变集合里已有元素的次序&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2018/02/26/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2018/02/26/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>老码识途第3章笔记</title>
        <description>&lt;h3 id=&quot;成长-与程序一起茁壮&quot;&gt;成长: 与程序一起茁壮&lt;/h3&gt;

&lt;p&gt;1.局部变量在栈上分配,全局变量在执行文件的数据段中分配&lt;/p&gt;

&lt;p&gt;2.引用计数:每个内存块上有一个字段叫引用计数,存储当前使用该块内存的使用者数目.当一段代码要使用它时,调用一个函数将引用计数加1;不使用时,调用另一个函数将引用计数减1,当该函数判断计数归0时,就释放该内存&lt;/p&gt;

&lt;p&gt;3.便于测试的代码就是良好设计的代码.如果发现程序难以用代码来测试,实际已经发出了警告,可能代码设计不好,如可能是界面控制代码和逻辑层代码”绞”在一起了&lt;/p&gt;

&lt;p&gt;4.c1编译链接命令,编译:&lt;code class=&quot;highlighter-rouge&quot;&gt;c1 /c 1.cpp 2.cpp 3.cpp&lt;/code&gt;,链接:&lt;code class=&quot;highlighter-rouge&quot;&gt;link 1.obj 2.obj 3.obj&lt;/code&gt;,如果c1命令不加”/c”选项,编译和链接将一起完成&lt;/p&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/02/05/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/02/05/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>老码识途</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>高效学习</title>
        <description>&lt;h3 id=&quot;必读&quot;&gt;必读&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/386f38ef0c13&quot;&gt;从”被动学习”到”主动学习”,只需这一个技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b061510789f4&quot;&gt;费曼四步学习法vs哈佛大学 “学习吸收率金字塔”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/learning_pyramid.png&quot; alt=&quot;学习金字塔&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;学习前&quot;&gt;学习前&lt;/h3&gt;

&lt;p&gt;带着问题去学习,为了找到答案而学习.内心拒绝的事不做,做内心想做的事.如果一件事&lt;code class=&quot;highlighter-rouge&quot;&gt;内心不想做&amp;gt;内心想做&lt;/code&gt;,这件事又必须做,则把它变成内心想做的事.例如,此时有时间却不知该学习什么(事先做好学习计划也能让做事变得更内心想做些),于是想想下面2点可做的方向:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a)有没有什么感兴趣的问题可做的[如对ida怎么脱壳的问题感兴趣],如果有则直接做这件事即可&lt;/li&gt;
  &lt;li&gt;b)认为此时该做的事情(如学习书籍的知识)比想做的事(如挖浏览器漏洞)更重要时,但是担心自己学习当前书籍[如书籍&lt;code class=&quot;highlighter-rouge&quot;&gt;老码识途&lt;/code&gt;]是&lt;code class=&quot;highlighter-rouge&quot;&gt;内心不想做&amp;gt;内心想做&lt;/code&gt;,但是这件事又必须做,那么找出内心更多想做它的理由,如自己原来就想把它的重要知识点写成博客记录下来,想到这里,内心想做的程度就又比开始更多了,如果此时内心不想做还是大于内心想做,而这件事又是必须做的,则找找其他更多的理由,直到&lt;code class=&quot;highlighter-rouge&quot;&gt;内心想做&amp;gt;内心不想做&lt;/code&gt;.例如:在决定下次组内分享时就分享今天的必须要做的事的内容,这样,内心想做的程度又多了.再如:写下做了这件事情的好处(越多越好)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;小结:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.做好学习计划&lt;/li&gt;
  &lt;li&gt;2.直接做想做的事&lt;/li&gt;
  &lt;li&gt;3.做&lt;code class=&quot;highlighter-rouge&quot;&gt;不想做&amp;gt;想做&lt;/code&gt;的事时要让它变成&lt;code class=&quot;highlighter-rouge&quot;&gt;想做&amp;gt;不想做&lt;/code&gt;,方法为:找出更多想做的理由,直到&lt;code class=&quot;highlighter-rouge&quot;&gt;想做&amp;gt;不想做&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;学习中&quot;&gt;学习中&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.追究所学知识背后原理&lt;/li&gt;
  &lt;li&gt;2.抽象出所学具体内容,将它提炼成生成形象的描述&lt;/li&gt;
  &lt;li&gt;3.提取重点,加以小结&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;学习后&quot;&gt;学习后&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;1.分享所学,例如
    &lt;ul&gt;
      &lt;li&gt;a.写文章&lt;/li&gt;
      &lt;li&gt;b.在知乎回答问题&lt;/li&gt;
      &lt;li&gt;c.假设自己有个学生&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2.立即应用&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 30 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2018/01/30/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2018/01/30/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>主动学习</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>理解编码</title>
        <description>&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;编码种类&lt;br /&gt;
编码的种类有多种,如
    &lt;ul&gt;
      &lt;li&gt;ascii&lt;/li&gt;
      &lt;li&gt;gbk&lt;/li&gt;
      &lt;li&gt;utf-8&lt;/li&gt;
      &lt;li&gt;…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编码实质&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编码的实质是一张人与计算机之间信息的对照表,如下ascii这种编码,部分内容如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ascii码表.png&quot; alt=&quot;ascii码表&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为什么需要编码&lt;br /&gt;
人只认识字符串,如”你好”,”hello”这样的形式的信息.计算机只”认识”二进制内容,如”001010101010101”这样的信息
    &lt;ul&gt;
      &lt;li&gt;人与人之间:通过字符串交流&lt;/li&gt;
      &lt;li&gt;计算机与计算机之间:通过二进制交流&lt;/li&gt;
      &lt;li&gt;人与计算机之间:通过&lt;strong&gt;翻译&lt;/strong&gt;来交流&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;(这张人与计算机之间信息的对照表)就是这个翻译,编码就是翻译,编码就是翻译&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/人机交流.png&quot; alt=&quot;人机交流&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;理解编码&quot;&gt;理解编码&lt;/h3&gt;

&lt;h4 id=&quot;人与计算机交流&quot;&gt;人与计算机交流&lt;/h4&gt;

&lt;p&gt;计算机在本地存储和通过网络发送的都是二进制的数据(0101010串),人要将信息存储在计算机则需要将人想存的”字符串”通过编辑软件如notepad.exe进行编码后进行存储,notepad.exe等编辑工具会自动进行编码,人也可告诉notepad.exe用什么编码种类(如ascii,gbk)进行编码.人若想读取计算机存储好的内容(二进制数据),需要通过编辑软件如notepad.exe进行解码成”字符串”,人才能读懂自己原来存储的信息.&lt;/p&gt;

&lt;h4 id=&quot;最弱的ascii码&quot;&gt;“最弱”的ascii码&lt;/h4&gt;

&lt;p&gt;ascii编码只懂得英文字符(键盘上的符号)与0101串之间的翻译,其他的编码都”具备”ascii编码这个翻译员的知识,如果英国人将英文编码成0101串后中国人通过gbk编码来翻译是可以翻译成功的,因为gbk编码这个翻译员具备ascii编码这个翻译员的知识,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [2]: &quot;hello&quot;.encode(&quot;ascii&quot;)
Out[2]: b'hello'

In [3]: &quot;hello&quot;.encode(&quot;ascii&quot;).decode(&quot;gbk&quot;)
Out[3]: 'hello'

In [4]: &quot;hello&quot;.encode(&quot;ascii&quot;).decode(&quot;gbk&quot;)
Out[4]: 'hello'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;编码的专一&quot;&gt;编码的”专一”&lt;/h4&gt;

&lt;p&gt;ascii码和gbk码就像英国人的翻译和中国人的翻译(这里的翻译指的是人与计算机之间的交流,而不是英国人和中国人之间的交流),如果中国人通过gbk码(不能将中文通过ascii进行编码,因为ascii编码这个翻译员不知道中文该怎么翻译)将他们的信息进行编码后通过计算机发送给英国人,英国人想通过ascii码将这个信息解码,结果会失败,因为ascii码这个翻译人员的能力有限,ascii码这个翻译员只懂得英文和0101,英国人尝试通过ascii码这个翻译员来将计算机发来的信息(这个信息是通过gbk码翻译员翻译成0101的结果)翻译成英文时,由于ascii码这个翻译员的脑子里不知道看到的0101串对应的是什么英文,于是翻译不来,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [5]: &quot;你好&quot;.encode('ascii')
---------------------------------------------------------------------------
UnicodeEncodeError                        Traceback (most recent call last)
&amp;lt;ipython-input-5-f2b92576099c&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 &quot;你好&quot;.encode('ascii')

UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;特殊的utf-8编码&quot;&gt;“特殊”的utf-8编码&lt;/h4&gt;

&lt;p&gt;utf-8编码这个翻译员能力比较强大,能将中文,日文和其他语言都翻译成0101串,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [7]: &quot;你好&quot;.encode(&quot;utf-8&quot;)
Out[7]: b'\xe4\xbd\xa0\xe5\xa5\xbd'

In [8]: &quot;こんにちは&quot;.encode(&quot;utf-8&quot;)
Out[8]: b'\xe3\x81\x93\xe3\x82\x93\xe3\x81\xab\xe3\x81\xa1\xe3\x81\xaf'

In [9]: &quot;你好&quot;.encode(&quot;utf-8&quot;).decode(&quot;utf-8&quot;)
Out[9]: '你好'

In [10]: &quot;こんにちは&quot;.encode(&quot;utf-8&quot;).decode(&quot;utf-8&quot;)
Out[10]: 'こんにちは'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过,虽然utf-8编码这个翻译员能力比较强,但是如果想把gbk编码的内容通过utf-8来解码,是不行的,因为gbk编码和utf-8编码是两种不同的编码,也即两个不同的翻译员(这两个翻译员能力不同),这两个翻译员除了对英文的知识的掌握是相同的以外,其他各自具备的知识是不同的,utf-8编码这个翻译员只懂得将utf-8自己编码过的内容解码,gbk翻译员也只懂得将gbk自己编码过的内容解码,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;In [11]: &quot;你好&quot;.encode(&quot;gbk&quot;).decode(&quot;utf-8&quot;)
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
&amp;lt;ipython-input-11-161972ecc108&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 &quot;你好&quot;.encode(&quot;gbk&quot;).decode(&quot;utf-8&quot;)

UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc4 in position 0: invalid continuation byte

In [12]: &quot;你好&quot;.encode(&quot;utf-8&quot;).decode(&quot;gbk&quot;)
Out[12]: '浣犲ソ'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 30 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2018/01/30/%E7%90%86%E8%A7%A3%E7%BC%96%E7%A0%81/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2018/01/30/%E7%90%86%E8%A7%A3%E7%BC%96%E7%A0%81/</guid>
        
        <category>encode</category>
        
        <category>decode</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>ida插件mynav</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;原mynav插件详情在&lt;a href=&quot;http://joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/&quot;&gt;这里&lt;/a&gt;,github项目在&lt;a href=&quot;https://github.com/joxeankoret/mynav&quot;&gt;这里&lt;/a&gt;,由于原项目的代码无法在IDA 7.0中运行,笔者将&lt;code class=&quot;highlighter-rouge&quot;&gt;mynav.py&lt;/code&gt;进行了部分修改,使可运行在&lt;code class=&quot;highlighter-rouge&quot;&gt;IDA 7.0&lt;/code&gt;中.修改后的github项目在&lt;a href=&quot;https://github.com/3xp10it/mynav&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;在ida完成对一个目标文件的分析后,&lt;code class=&quot;highlighter-rouge&quot;&gt;File|Script File&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;mynav.py&lt;/code&gt;(或&lt;code class=&quot;highlighter-rouge&quot;&gt;mybrowser.py&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;myexport.py&lt;/code&gt;),然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit|Plugins|MyNav&lt;/code&gt;中可看到如下子菜单&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/mynav.png&quot; alt=&quot;mynav&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中最重要的功能用法如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第1步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|new session&lt;/code&gt;,取一个名字,单击ok后会提示要在所有函数下断点,单击ok,然后ida会自动从暂停状态变成运行状态,在运行的程序中做一些不想记录的操作(或者什么也不做,只是等待2s),然后将运行的程序关闭(不是通过ida关闭)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|new session&lt;/code&gt;,取另一个名字,单击ok后ida会自动从暂停状态变成运行状态,在运行的程序中做关键的操作(如点击某个想知道背后运行了什么函数的重要的按键),然后将运行的程序关闭(不是通过ida关闭)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|trace session&lt;/code&gt;,选择2中的session名字,之后和2中的”取另一个名字”之后的操作一样,也即重现2中的操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|show trace session&lt;/code&gt;,选择3中的session名字&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面前2步的功能就差不多够用了,有3和4更好.笔者认为上面4个步骤对应mynav实现的原理如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第1步中通过在所有函数上下断点,并且设置断点被触发后自动删除,这样在第1步完成后会将所有函数中的非关键操作对应的函数的断点删除,mynav每触发一个函数的断点都会记录这个函数被运行了.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步不会在第1步的基础上再设置新的断点,第2步在安全人员进行了关键的操作后会触发这个关键操作对应的函数,mynav会将在第2步中触发的函数记录下来,并将触发的断点删除,第2步完成后即可得到关键操作对应的函数,到这里需要的东西差不多够了,有后面的3和4更好&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步中mynav会将第2步中的记录的session(每个session记录了运行过的函数,也即触发过的断点)中的函数的断点重新生效,然后安全人员重新做关键操作后ida会再次触发第2步中的相关断点,mynav会再次记录这一步触发的函数,并将触发后的断点删除,这一步可以对运行过的函数流程看地更细&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步中可以辅助记录不同的关键操作对应的函数,可用于对比不同关键操作对应的函数流程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1步操作之前需要确保安全人员没有自行设置断点,如果在使用第1步的功能前已经有断点会导致使用这个功能失败(应该是由于mynav认为如果已经有断点则认为不是在第1步的操作)&lt;/li&gt;
  &lt;li&gt;有时通过usb远程以attach的方式调试app时ida在加载远程手机中的进程列表时会crash,遇到这种情况需要每次重新attach调试app时将usb重新拔插后再attach&lt;/li&gt;
  &lt;li&gt;使用mynav的这种在所有函数下断点的方法在目标可执行文件比较大的时候(&amp;gt;500M)不合适,因为在所有函数下断点可能要下很久,500M以上的文件下断点估计要花2个小时以上.如果是调试ios app,遇到这种情况直接用根据UI找函数的方法较合适&lt;/li&gt;
  &lt;li&gt;mynav可能不会在动态链接库的函数中下断点(这一结论暂未验证),如果关键函数(如判断软件使用者是否是vip的函数)是在动态链接库中(如android的so文件,ios的dylib文件,win的dll文件)则不会被mynav追踪到,这种情况查看&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;即可,&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;以看到动态链接库中的函数调用&lt;/li&gt;
  &lt;li&gt;ida调试可以以加载或附加的方式调试,如果以加载的方式调试,在第2步新建session后如果剩下的断点(所有的函数中除去第1步中触发过的函数外的剩下的函数)较多,有可能会影响目标程序的正常启动(有时候会这样),如果有影响则可考虑在第1步后第2步前先将剩下的断点全部先disable,等目标程序启动后再将剩下的断点enable,然后再开始第2步的&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin|mynav|new session&lt;/code&gt;.或者不使用加载的方式调试,而使用附加的方式调试.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;refer&quot;&gt;Refer&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hex-rays.com/products/ida/support/idapython_docs/&quot;&gt;idapython docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/idapython/src/blob/d99a89369741ce272ba792d6f087d0739a2f8ac7/api_contents.txt&quot;&gt;idapython api&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/keystone-engine/keypatch/blob/master/keypatch.py&quot;&gt;keypatch.py&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/idapython/src/search?utf8=%E2%9C%93&amp;amp;q=replaceAPIhere&amp;amp;type=&quot;&gt;idapython api example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/22/ida%E6%8F%92%E4%BB%B6mynav/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/22/ida%E6%8F%92%E4%BB%B6mynav/</guid>
        
        <category>ida</category>
        
        <category>mynav</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>炒股观点</title>
        <description>&lt;ul&gt;
  &lt;li&gt;买资讯中的股票,不可全买,小公司只有较少股票在短期(1-3天)内会有较小(1%-4%)上升.资讯可在”钠镁股票”或”平安证券”中找到.&lt;/li&gt;
  &lt;li&gt;分析各个股票找抄底股买&lt;/li&gt;
  &lt;li&gt;买最热股前几名(如2017年的最热的茅台)&lt;/li&gt;
  &lt;li&gt;买龙头企业在低价时的股票&lt;/li&gt;
  &lt;li&gt;买股价很低的大公司(如当前农业银行价格很低,3-4块每股)的股票&lt;/li&gt;
  &lt;li&gt;只买信心最大的股票&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 18 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2018/01/18/%E7%82%92%E8%82%A1%E8%A7%82%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%82%92%E8%82%A1/2018/01/18/%E7%82%92%E8%82%A1%E8%A7%82%E7%82%B9/</guid>
        
        <category>炒股</category>
        
        
        <category>炒股</category>
        
      </item>
    
  </channel>
</rss>
