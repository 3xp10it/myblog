<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 25 Jan 2018 18:03:26 +0800</pubDate>
    <lastBuildDate>Thu, 25 Jan 2018 18:03:26 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>ida插件mynav</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;原mynav插件详情在&lt;a href=&quot;http://joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/&quot;&gt;这里&lt;/a&gt;,github项目在&lt;a href=&quot;https://github.com/joxeankoret/mynav&quot;&gt;这里&lt;/a&gt;,由于原项目的代码无法在IDA 7.0中运行,笔者将&lt;code class=&quot;highlighter-rouge&quot;&gt;mynav.py&lt;/code&gt;进行了部分修改,使可运行在&lt;code class=&quot;highlighter-rouge&quot;&gt;IDA 7.0&lt;/code&gt;中.修改后的github项目在&lt;a href=&quot;https://github.com/3xp10it/mynav&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;p&gt;在ida完成对一个目标文件的分析后,&lt;code class=&quot;highlighter-rouge&quot;&gt;File|Script File&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;mynav.py&lt;/code&gt;(或&lt;code class=&quot;highlighter-rouge&quot;&gt;mybrowser.py&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;myexport.py&lt;/code&gt;),然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit|Plugins|MyNav&lt;/code&gt;中可看到如下子菜单&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/mynav.png&quot; alt=&quot;mynav&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中最重要的功能用法如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第1步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|new session&lt;/code&gt;,取一个名字,单击ok后会提示要在所有函数下断点,单击ok,然后ida会自动从暂停状态变成运行状态,在运行的程序中做一些不想记录的操作(或者什么也不做,只是等待2s),然后将运行的程序关闭(不是通过ida关闭)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|new session&lt;/code&gt;,取另一个名字,单击ok后ida会自动从暂停状态变成运行状态,在运行的程序中做关键的操作(如点击某个想知道背后运行了什么函数的重要的按键),然后将运行的程序关闭(不是通过ida关闭)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|trace session&lt;/code&gt;,选择2中的session名字,之后和2中的”取另一个名字”之后的操作一样,也即重现2中的操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步:&lt;code class=&quot;highlighter-rouge&quot;&gt;plugins|mynav|show trace session&lt;/code&gt;,选择3中的session名字&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面前2步的功能就差不多够用了,有3和4更好.笔者认为上面4个步骤对应mynav实现的原理如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第1步中通过在所有函数上下断点,并且设置断点被触发后自动删除,这样在第1步完成后会将所有函数中的非关键操作对应的函数的断点删除,mynav每触发一个函数的断点都会记录这个函数被运行了.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第2步不会在第1步的基础上再设置新的断点,第2步在安全人员进行了关键的操作后会触发这个关键操作对应的函数,mynav会将在第2步中触发的函数记录下来,并将触发的断点删除,第2步完成后即可得到关键操作对应的函数,到这里需要的东西差不多够了,有后面的3和4更好&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第3步中mynav会将第2步中的记录的session(每个session记录了运行过的函数,也即触发过的断点)中的函数的断点重新生效,然后安全人员重新做关键操作后ida会再次触发第2步中的相关断点,mynav会再次记录这一步触发的函数,并将触发后的断点删除,这一步可以对运行过的函数流程看地更细&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第4步中可以辅助记录不同的关键操作对应的函数,可用于对比不同关键操作对应的函数流程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;注意:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1步操作之前需要确保安全人员没有自行设置断点,如果在使用第1步的功能前已经有断点会导致使用这个功能失败(应该是由于mynav认为如果已经有断点则认为不是在第1步的操作)&lt;/li&gt;
  &lt;li&gt;有时通过usb远程以attach的方式调试app时ida在加载远程手机中的进程列表时会crash,遇到这种情况需要每次重新attach调试app时将usb重新拔插后再attach&lt;/li&gt;
  &lt;li&gt;使用mynav的这种在所有函数下断点的方法在目标可执行文件比较大的时候(&amp;gt;500M)不合适,因为在所有函数下断点可能要下很久,500M以上的文件下断点估计要花2个小时以上.如果是调试ios app,遇到这种情况直接用根据UI找函数的方法较合适&lt;/li&gt;
  &lt;li&gt;mynav可能不会在动态链接库的函数中下断点(这一结论暂未验证),如果关键函数(如判断软件使用者是否是vip)是在动态链接库中(如android的so文件,ios的dylib文件,win的dll文件)则不会被mynav追踪到,这种情况查看&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;即可,&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;以看到动态链接库中的函数调用&lt;/li&gt;
  &lt;li&gt;ida调试可以以加载或附加的方式调试,如果以加载的方式调试,在第2步新建session后如果剩下的断点(所有的函数中除去第1步中触发过的函数外的剩下的函数)较多,有可能会影响目标程序的正常启动(有时候会这样),如果有影响则可考虑在第1步后第2步前先将剩下的断点全部先disable,等目标程序启动后再将剩下的断点enable,然后再开始第2步的&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin|mynav|new session&lt;/code&gt;.或者不使用附加的方式调试,而使用加载的方式调试.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;refer&quot;&gt;Refer&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hex-rays.com/products/ida/support/idapython_docs/&quot;&gt;idapython docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/idapython/src/blob/d99a89369741ce272ba792d6f087d0739a2f8ac7/api_contents.txt&quot;&gt;idapython api&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/keystone-engine/keypatch/blob/master/keypatch.py&quot;&gt;keypatch.py&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/idapython/src/search?utf8=%E2%9C%93&amp;amp;q=replaceAPIhere&amp;amp;type=&quot;&gt;idapython api example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 22 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/22/ida%E6%8F%92%E4%BB%B6mynav/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/22/ida%E6%8F%92%E4%BB%B6mynav/</guid>
        
        <category>ida</category>
        
        <category>mynav</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>炒股观点</title>
        <description>&lt;ul&gt;
  &lt;li&gt;买资讯中的股票,不可全买,小公司只有较少股票在短期(1-3天)内会有较小(1%-4%)上升.资讯可在”钠镁股票”或”平安证券”中找到.&lt;/li&gt;
  &lt;li&gt;分析各个股票找抄底股买&lt;/li&gt;
  &lt;li&gt;买最热股前几名(如2017年的最热的茅台)&lt;/li&gt;
  &lt;li&gt;买龙头企业在低价时的股票&lt;/li&gt;
  &lt;li&gt;买股价很低的大公司(如当前农业银行价格很低,3-4块每股)的股票&lt;/li&gt;
  &lt;li&gt;只买信心最大的股票&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 18 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2018/01/18/%E7%82%92%E8%82%A1%E8%A7%82%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/%E7%82%92%E8%82%A1/2018/01/18/%E7%82%92%E8%82%A1%E8%A7%82%E7%82%B9/</guid>
        
        <category>炒股</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>反调试技术库</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.pediy.com/kssd/pediy06/pediy6713.htm&quot;&gt;反(调试/跟踪/脱壳) 技术集锦&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/qq_32400847/article/details/52798050&quot;&gt;详解反调试技术&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/zhangmiaoping23/article/details/44564781&quot;&gt;逆向工程核心原理-静态反调试技术总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/zhangmiaoping23/article/details/44593407&quot;&gt;逆向工程核心原理-动态反调试技术总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/trap0D/article/details/45697607&quot;&gt;一个android反调试的学习&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lolopop.cn/2017/anti-debug-in-malware/&quot;&gt;恶意代码反调试技术总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tk4479.net/whklhhhh/article/details/78787596&quot;&gt;逆向-高级反调试技术&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bbs.pediy.com/thread-212371.htm&quot;&gt;基础反调试技术总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://paper.seebug.org/204/&quot;&gt;深度分析使用高级反调试和反hook的Android Rootnik Malware,Part I:在Native层调试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/iamonion/p/7119085.html&quot;&gt;去除ios反调试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.wjdiankong.cn/android逆向之旅-应用的反调试方案解析附加修改ida调试/&quot;&gt;Android逆向之旅—应用的”反调试”方案解析(附加修改IDA调试端口和修改内核信息)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/a2ed798a7f62&quot;&gt;iOS 应用加固方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%BA%93/</guid>
        
        <category>反调试</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ios应用逆向工程7-10章笔记</title>
        <description>&lt;h3 id=&quot;实战篇&quot;&gt;实战篇&lt;/h3&gt;

&lt;p&gt;1.制作一个app的tweak一般是通过分析这个app的已经的函数的功能和加上自己想实现的一些功能,两者整合得到一个tweak,其中分析app已有的函数功能在制作整个tweak所花的时间上占比较大.一般通过找相关UI的类(controller),分析类中的函数功能,然后再hook相关函数,并在hook时加入自己想实现的功能.分析类中的函数时,一般是分析从View中看到的数据背后可能存在的函数,如分析邮件app时,View中有收件人,则可通过分析找出获取收件人邮箱地址的函数名,这样在写tweak时可人工调用这个函数来获取收件人的邮箱地址&lt;/p&gt;

&lt;p&gt;2.”拿到所有邮件”可以分为2步:一是捕获”刷新完成”事件;二是读取收件箱.其中,”刷新完成”的响应函数一般是定义在protocol里的,在分析class-dump头文件的时候,要留意各种protocol里有没有出现&lt;code class=&quot;highlighter-rouge&quot;&gt;didRefresh&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;didUpdate&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;didReload&lt;/code&gt;之类名字中含有完成时态动词的函数&lt;/p&gt;

&lt;p&gt;3.理解Objective-C中的delegate,&lt;a href=&quot;http://blog.csdn.net/jymn_chen/article/details/9058725&quot;&gt;1st&lt;/a&gt;,&lt;a href=&quot;https://www.zhihu.com/question/19827157&quot;&gt;2nd&lt;/a&gt;.MVC模式中,V(view,也即UI)的delegate(助手,秘书)是C(controller).&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0xUI_obj_address delegate]&lt;/code&gt;可得到一个UI的被委托要实现的功能(function)&lt;/p&gt;

&lt;p&gt;4.在使用theos编写tweak时,如果要调用class-dump出的头文件中的类中的函数,则需要在Tweak.xm的开头&lt;code class=&quot;highlighter-rouge&quot;&gt;#import 人工编写的头文件.h&lt;/code&gt;,这个人工编写的头文件中的所有内容均摘自类对应的头文件,构造它的目的仅仅是通过编译,避免出现任何报错信息和警告&lt;/p&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B7-10%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>ios</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ida用法</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;记录ida的实用功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;items&quot;&gt;Items&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;查看当前函数被哪些地方调用了
    &lt;blockquote&gt;
      &lt;p&gt;在ida view窗口的函数首部或在pseudocode窗口的函数首部右键点击x/^x对应的选项可找出所有调用当前函数的地方&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;查看当前函数调用了哪些地方
    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;查看当前函数调用了哪些函数可在functions window中选中函数,然后通过菜单栏&lt;/td&gt;
            &lt;td&gt;view&lt;/td&gt;
            &lt;td&gt;sub views&lt;/td&gt;
            &lt;td&gt;function calls找到&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ida搜索中文时要在&lt;code class=&quot;highlighter-rouge&quot;&gt;IDA View&lt;/code&gt;中搜索,在&lt;code class=&quot;highlighter-rouge&quot;&gt;strings&lt;/code&gt;窗口中搜索不到中文,应该是个bug&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调试idapython的方法:使用命令行启动ida,并在要调试的idapython脚本中的位置上直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;import pdb\npdb.set_trace()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;有两种方法可快速定位到关键函数的调用
    &lt;ul&gt;
      &lt;li&gt;查看函数调用栈:&lt;code class=&quot;highlighter-rouge&quot;&gt;debugger|debugger windows|stack trace&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;使用&lt;a href=&quot;https://github.com/3xp10it/mynav&quot;&gt;mynav&lt;/a&gt;插件快速定位关键操作对应的函数
  &lt;strong&gt;注意&lt;/strong&gt;:mynav可能不会在动态链接库的函数中下断点(这一结论暂未验证),如果关键函数(如判断软件使用者是否是vip)是在动态链接库中(如android的so文件,ios的dylib文件,win的dll文件)则不会被mynav追踪到,这种情况查看&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;即可,&lt;code class=&quot;highlighter-rouge&quot;&gt;stack trace&lt;/code&gt;以看到动态链接库中的函数调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有时候在一个函数中却无法F5,这时候你需要先按一下”p”键,程序会将这段代码作为函数分析,然后再按一下”F5”,这种情况一般出现在目标程序加载的动态链接文件中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;需要在目标程序中调试动态链接库中的函数一般需要&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?articleid=365&quot;&gt;Ida双开定位&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 17 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/ida%E7%94%A8%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/ida%E7%94%A8%E6%B3%95/</guid>
        
        <category>ida</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>实战ios破解--通过UI找关键函数</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;本文记录破解一个cydia中收费deb软件过程,如下为一个截图,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;所在UI显示&lt;code class=&quot;highlighter-rouge&quot;&gt;未授权&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/crack_deb.png&quot; alt=&quot;权限截图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x1-通过ui找函数的2种方法&quot;&gt;0x1 通过UI找函数的2种方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ios通过cydia安装&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;,并在要破解的软件中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;
这种方法很方便,效率很高,可通过点击app中的&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;功能区的&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;,再点击对应UI再点击&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;按钮,通过&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;中的不同颜色来直接定位对应UI和UI对应的类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过cycript注入要破解的软件,然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;来找到UI后再找函数
这种方法比上面的方法麻烦,需要通过&lt;a href=&quot;https://www.jianshu.com/p/e802b8b76e92&quot;&gt;这里&lt;/a&gt;的命令来查找,一般是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription]&lt;/code&gt;得到的结果逐个元素进行排除来得到目标UI对象.有以下2点注意事项&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;cycript设置查看ui对应函数时用到的?expand命令失效时可以这样弥补&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription].toString()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;cycript查找ui对应的元素可通过找几个主要的大树枝,如果大树枝&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;后发现要找的UI不显示了则说明要找的UI在这个大树枝里面,然后再大树枝里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x... setHidden:YES]&lt;/code&gt;逐渐找到最终的小树枝.通过cycript找UI这条路一般不用,除非用flex_injected找不到(有些app无法使用flex_injected)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x2-破解过程&quot;&gt;0x2 破解过程&lt;/h3&gt;

&lt;h4 id=&quot;step1-找到ui对应的元素&quot;&gt;step1 找到ui对应的元素&lt;/h4&gt;

&lt;p&gt;本文要破解的app是cydia里安装的,可能有一些反破解机制,导致无法直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ida&lt;/code&gt;调试,也无法使用&lt;code class=&quot;highlighter-rouge&quot;&gt;flex_injected&lt;/code&gt;分析ui,于是使用上面的第2种方法,也即通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cycript&lt;/code&gt;注入目标进程来通过排除法查找上图中&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;这个ui对应的函数.&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription]&lt;/code&gt;得到结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UIWindow: 0x1763dd20; frame = (0 0; 375 667); gestureRecognizers = &amp;lt;NSArray: 0x1763d390&amp;gt;; layer = &amp;lt;UIWindowLayer: 0x175c9d90&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITextEffectsWindow: 0x1766ac70; frame = (0 0; 375 667); opaque = NO; autoresize = W+H; layer = &amp;lt;UIWindowLayer: 0x17779950&amp;gt;&amp;gt;&quot;]
cy# [[UIApp keyWindow] recursiveDescription].toString()
`&amp;lt;UIWindow: 0x1763dd20; frame = (0 0; 375 667); gestureRecognizers = &amp;lt;NSArray: 0x1763d390&amp;gt;; layer = &amp;lt;UIWindowLayer: 0x175c9d90&amp;gt;&amp;gt;
   | &amp;lt;UIView: 0x188ca2f0; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &amp;lt;NSArray: 0x188c9dd0&amp;gt;; layer = &amp;lt;CALayer: 0x188ca290&amp;gt;&amp;gt;
      |    | &amp;lt;UIView: 0x188caeb0; frame = (0 0; 375 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x188caf70&amp;gt;&amp;gt;
         |    |    | &amp;lt;UILayoutContainerView: 0x1776c2c0; frame = (0 0; 270 667); hidden = YES; autoresize = RM+H; gestureRecognizers = &amp;lt;NSArray: 0x188c8590&amp;gt;; layer = &amp;lt;CALayer: 0x188a3de0&amp;gt;&amp;gt;
            |    |    |    | &amp;lt;UINavigationTransitionView: 0x17690e60; frame = (0 0; 270 667); clipsToBounds = YES; autoresize = W+H; layer = &amp;lt;CALayer: 0x17690f40&amp;gt;&amp;gt;
               |    |    |    |    | &amp;lt;UIViewControllerWrapperView: 0x17618e30; frame = (0 0; 270 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x177a19d0&amp;gt;&amp;gt;
                  |    |    |    |    |    | &amp;lt;UITableView: 0x18509c00; frame = (0 0; 270 667); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &amp;lt;NSArray: 0x18854560&amp;gt;; layer = &amp;lt;CALayer: 0x188cca20&amp;gt;; contentOffset: {0, 0}; contentSize: {270, 0}&amp;gt;
                     |    |    |    |    |    |    | &amp;lt;UITableViewWrapperView: 0x18509800; frame = (0 0; 270 667); gestureRecognizers = &amp;lt;NSArray: 0x188ca6b0&amp;gt;; layer = &amp;lt;CALayer: 0x1776f3b0&amp;gt;; contentOffset: {0, 0}; contentSize: {270, 667}&amp;gt;
                        |    |    |    |    |    |    | &amp;lt;UIImageView: 0x17650ce0; frame = (264.5 657; 2.5 7); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x188d37b0&amp;gt;&amp;gt;
                           |    |    |    |    |    |    | &amp;lt;UIImageView: 0x17653de0; frame = (260 661.5; 7 2.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x17643050&amp;gt;&amp;gt;
                              |    |    |    | &amp;lt;UINavigationBar: 0x188be470; frame = (0 20; 270 44); opaque = NO; autoresize = W; gestureRecognizers = &amp;lt;NSArray: 0x17607230&amp;gt;; layer = &amp;lt;CALayer: 0x188c8380&amp;gt;&amp;gt;
                                 |    |    |    |    | &amp;lt;_UINavigationBarBackground: 0x17693b10; frame = (0 -20; 270 64); opaque = NO; autoresize = W; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x188c36
                                 `
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x1763dd20 setHidden:YES]&lt;/code&gt;之后发现看不到看不到要找的UI(&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;对应的ui)了,说明目标ui在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1763dd20&lt;/code&gt;的子视图中&lt;/p&gt;

&lt;p&gt;3.查看&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1763dd20&lt;/code&gt;的子视图&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188ca2f0&lt;/code&gt;设置隐藏后的效果,&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188ca2f0 setHidden:YES]&lt;/code&gt;后发现看不到目标UI,说明目标UI还在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188ca2f0&lt;/code&gt;的子视图中&lt;/p&gt;

&lt;p&gt;4.查看&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188ca2f0&lt;/code&gt;的子视图设置隐藏后的效果,&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188caeb0 setHidden:YES]&lt;/code&gt;后发现看不到目标UI,说明目标UI还在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188caeb0&lt;/code&gt;子视图中&lt;/p&gt;

&lt;p&gt;5.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x1776c2c0 setHidden:YES]&lt;/code&gt;之后发现目标UI没有被隐藏,说明目标UI不在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1776c2c0&lt;/code&gt;这条树枝中,但是上面&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription]&lt;/code&gt;的结果中可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188caeb0&lt;/code&gt;的子树枝中只有&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1776c2c0&lt;/code&gt;,而&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1776c2c0&lt;/code&gt;的确不是目标UI的父树枝,也许是目标app做了什么隐藏手段导致这样的结果(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[[UIApp keyWindow] recursiveDescription]&lt;/code&gt;中不能直接看到目标UI)&lt;/p&gt;

&lt;p&gt;6.于是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188caeb0 subviews]&lt;/code&gt;查看,看看能不能看到除了&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1776c2c0&lt;/code&gt;之外的子树枝,结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UILayoutContainerView: 0x1776c2c0; frame = (0 0; 270 667); autoresize = RM+H; gestureRecognizers = &amp;lt;NSArray: 0x188c8590&amp;gt;; layer = &amp;lt;CALayer: 0x188a3de0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;JhAAAYzaNsFTriWR: 0x188cb0c0; frame = (0 0; 375 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x188cb2e0&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188caeb0&lt;/code&gt;除了&lt;code class=&quot;highlighter-rouge&quot;&gt;0x1776c2c0&lt;/code&gt;之外还有&lt;code class=&quot;highlighter-rouge&quot;&gt;0x188cb0c0&lt;/code&gt;这个子树枝&lt;/p&gt;

&lt;p&gt;7.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188cb0c0 subviews]&lt;/code&gt;结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UILayoutContainerView: 0x1763c960; frame = (0 0; 375 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x1763c7d0&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.上面只有一个子视图,肯定不是目标UI(&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;对应UI),继续查看它的子视图,&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x1763c960 subviews]&lt;/code&gt;,结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UITransitionView: 0x1763be80; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; layer = &amp;lt;CALayer: 0x1763bcf0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITabBar: 0x1763c450; frame = (0 618; 375 49); autoresize = W+TM; tintColor = UIDeviceRGBColorSpace 0 0.733333 0.223529 1; layer = &amp;lt;CALayer: 0x1763c2a0&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;9.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x1763be80 setHidden:YES]&lt;/code&gt;之后看不到目标UI&lt;/p&gt;

&lt;p&gt;10.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x1763be80 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UIViewControllerWrapperView: 0x18e19dc0; frame = (0 0; 375 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x18e26d30&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x18e19dc0 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UILayoutContainerView: 0x188ba100; frame = (0 0; 375 667); autoresize = W+H; gestureRecognizers = &amp;lt;NSArray: 0x188bb900&amp;gt;; layer = &amp;lt;CALayer: 0x188ba1d0&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;12.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188ba100 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UINavigationTransitionView: 0x188bac60; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; layer = &amp;lt;CALayer: 0x188bb2b0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UINavigationBar: 0x188ba200; frame = (0 20; 375 44); opaque = NO; autoresize = W; gestureRecognizers = &amp;lt;NSArray: 0x188ba9b0&amp;gt;; layer = &amp;lt;CALayer: 0x188ba320&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;13.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188bac60 setHidden:YES]&lt;/code&gt;后发现看不到目标UI&lt;/p&gt;

&lt;p&gt;14.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188bac60 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UIViewControllerWrapperView: 0x188c2c00; frame = (0 0; 375 667); autoresize = W+H; layer = &amp;lt;CALayer: 0x17604980&amp;gt;&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;15.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x188c2c00 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UITableView: 0x17c0a600; frame = (0 0; 375 667); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &amp;lt;NSArray: 0x188d56d0&amp;gt;; layer = &amp;lt;CALayer: 0x18980810&amp;gt;; contentOffset: {0, -64}; contentSize: {375, 921}&amp;gt;&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;16.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x17c0a600 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UITableViewWrapperView: 0x184f6c00; frame = (0 0; 375 603); gestureRecognizers = &amp;lt;NSArray: 0x177716e0&amp;gt;; layer = &amp;lt;CALayer: 0x177a05b0&amp;gt;; contentOffset: {0, 0}; contentSize: {375, 603}&amp;gt;&quot;,#&quot;&amp;lt;UIImageView: 0x18e64bd0; frame = (3 548.5; 369 2.5); alpha = 0; opaque = NO; autoresize = TM; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x18e64ba0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UILabel: 0x1892a0f0; frame = (0 871; 375 50); text = '\xc2\xa9 361\xe4\xb8\x80\xe9\x94\xae\xe6\x96\xb0\xe6\x9c\xba'; userInteractionEnabled = NO; layer = &amp;lt;_UILabelLayer: 0x1892a200&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewHeaderFooterView: 0x1894ea80; frame = (0 639.5; 375 38); text = '\xe5\xb8\xae\xe5\x8a\xa9'; hidden = YES; autoresize = W; layer = &amp;lt;CALayer: 0x18980ab0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewHeaderFooterView: 0x18f05eb0; frame = (0 276; 375 38); text = '\xe8\xae\xbe\xe7\xbd\xae'; autoresize = W; layer = &amp;lt;CALayer: 0x18f060e0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewHeaderFooterView: 0x18f08bb0; frame = (0 96.5; 375 74); text = '\xe6\x9d\x83\xe9\x99\x90(\xe7\xbd\x91\xe7\xbb\x9c\xe4\xb8\x80\xe7\x9b\xb4\xe5\xa4\x84\xe4\xba\x8e[\xe5\x8a\xa0\xe8\xbd\xbd\xe4\xb8\xad]\xe7\x9a\x84\xe8\xa7\xa3\xe5\x86\xb3\xe6\x96\xb9\xe6\xb3\x95\xef\xbc\x9a1. \xe5\x88\x87\xe6\x8d\xa2...'; autoresize = W; layer = &amp;lt;CALayer: 0x18f08b80&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UIImageView: 0x18e646f0; frame = (369.5 3; 2.5 353.5); alpha = 0; opaque = NO; autoresize = LM; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x18e64960&amp;gt;&amp;gt;&quot;]&quot;')'&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;17.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x184f6c00 setHidden:YES]&lt;/code&gt;发现看不到目标UI&lt;/p&gt;

&lt;p&gt;18.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x184f6c00 subviews]&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@[#&quot;&amp;lt;UITableViewCell: 0x18f37a20; frame = (0 578; 375 44); text = '\xe5\xa4\x87\xe4\xbb\xbd\xe8\xbf\x81\xe7\xa7\xbb'; autoresize = W; layer = &amp;lt;CALayer: 0x18f379f0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x18f3a5a0; frame = (0 534; 375 44); text = 'VPN\xe4\xbb\xa3\xe7\x90\x86'; autoresize = W; layer = &amp;lt;CALayer: 0x18f3a570&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;taNoXRDjKPBbiCJk: 0x18f4d750; baseClass = UITableViewCell; frame = (0 35; 375 44); text = '\xe7\x83\xad\xe9\x97\xa8\xe6\x8e\xa8\xe8\x8d\x90'; autoresize = W; layer = &amp;lt;CALayer: 0x18fbeac0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x18f49aa0; frame = (0 170.5; 375 44); text = '\xe6\x9c\xba\xe5\x99\xa8\xe7\xa0\x81'; autoresize = W; layer = &amp;lt;CALayer: 0x18f49a70&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x17531390; frame = (0 214.5; 375 44); text = '\xe6\x9d\x83\xe9\x99\x90'; autoresize = W; layer = &amp;lt;CALayer: 0x17531580&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x189d7520; frame = (0 314; 375 44); text = '\xe6\x96\xb0\xe6\x9c\xba\xe6\x97\xb6\xe8\x87\xaa\xe5\x8a\xa8\xe5\xa4\x87\xe4\xbb\xbd'; autoresize = W; layer = &amp;lt;CALayer: 0x189d7710&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x189e1250; frame = (0 358; 375 44); text = '\xe6\x96\xb0\xe6\x9c\xba\xe6\x97\xb6\xe6\xb8\x85\xe7\xa9\xba\xe5\x89\xaa\xe8\xb4\xb4\xe6\x9d\xbf'; autoresize = W; layer = &amp;lt;CALayer: 0x189e1440&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x189013c0; frame = (0 809.5; 375 44); text = 'Tinyapps.cn'; hidden = YES; autoresize = W; layer = &amp;lt;CALayer: 0x189186f0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x18e18960; frame = (0 765.5; 375 44); text = '\xe6\xa3\x80\xe6\x9f\xa5\xe6\x96\xb0\xe7\x89\x88\xe6\x9c\xac'; hidden = YES; autoresize = W; layer = &amp;lt;CALayer: 0x18eb08d0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x17530760; frame = (0 721.5; 375 44); text = '\xe8\x84\x9a\xe6\x9c\xac\xe8\xb0\x83\xe7\x94\xa8\xe6\x8c\x87\xe5\x8d\x97'; hidden = YES; autoresize = W; layer = &amp;lt;CALayer: 0x1908b2d0&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x18f3f990; frame = (0 677.5; 375 44); text = '\xe4\xbd\xbf\xe7\x94\xa8\xe8\xaf\xb4\xe6\x98\x8e'; hidden = YES; autoresize = W; layer = &amp;lt;CALayer: 0x18e2b090&amp;gt;&amp;gt;&quot;,#&quot;&amp;lt;UITableViewCell: 0x189e6d40; frame = (0 446; 375 44); text = '\xe8\x87\xaa\xe5\x8a\xa8\xe6\x9b\xb4\xe6\x8d\xa2IP(\)'&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;19.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x18f37a20 setHidden:YES]&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x18f4d750 setHidden:YES]&lt;/code&gt;发现目标UI没有被隐藏&lt;/p&gt;

&lt;p&gt;20.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x18f49aa0 setHidden:YES]&lt;/code&gt;发现待破解app截图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;机器码&lt;/code&gt;对应UI被隐藏&lt;/p&gt;

&lt;p&gt;21.&lt;code class=&quot;highlighter-rouge&quot;&gt;[#0x17531390 setHidden:YES]&lt;/code&gt;发现待破解app截图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;权限&lt;/code&gt;对应UI被隐藏,说明这就是要找的UI元素&lt;/p&gt;

&lt;h4 id=&quot;step2-找到ui元素对应的函数&quot;&gt;step2 找到ui元素对应的函数&lt;/h4&gt;

&lt;p&gt;1.尝试通过&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;ios应用逆向工程&amp;gt;&amp;gt;&lt;/code&gt;或&lt;a href=&quot;https://www.jianshu.com/p/e802b8b76e92&quot;&gt;这里&lt;/a&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;[button_object allTargets]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;[button_object allControlEvent]&lt;/code&gt;的方法没有找到对应的UI函数&lt;/p&gt;

&lt;p&gt;2.于是尝试通过&lt;code class=&quot;highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;找出关键类&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于一个view调用nextResponder,要么返回对应的C,要么返回其superview.我们可以通过recursiveDescription拿到所有view,遍历一遍则必定为出现C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对目标UI元素&lt;code class=&quot;highlighter-rouge&quot;&gt;0x17531390&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;,结果是superview,不是Controller,继续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;0x17531390&lt;/code&gt;的superview的&lt;code class=&quot;highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;,结果不是Controller,继续这样,大概第三次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;时得到Controller,结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#&quot;&amp;lt;DfzeGXHoBCzYUNyG: 0x1884b8c0&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.在&lt;code class=&quot;highlighter-rouge&quot;&gt;ida&lt;/code&gt;中查看这个类有什么函数,内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-[DfzeGXHoBCzYUNyG initWithTitle:]	__text	0028DC58	0000006C	00000018	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG viewDidLoad]	__text	0028DCC4	00000386	0000003C	00000050	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG viewWillAppear:]	__text	0028E076	0000020C	00000028	00000020	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG YnDNWxqNaCCuowFk]	__text	0028E282	00000186	00000028	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG qtuIqLxznDvYaGTr]	__text	0028E408	00000186	00000028	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG getIPAddresses]	__text	0028E58E	000001F2	0000004C	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG DtFVEldRKFDYPxLj]	__text	0028E780	0000013A	00000034	FFFFFFF9	.	.	.	.	.	T	.
sub_28E8BA	__text	0028E8BA	0000017E	00000028	FFFFFFF9	.	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG TAKrPPOSDHgLhdlg:]	__text	0028F054	0000005C	00000018	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG CjBOqjnWPaaJQnAu:]	__text	0028F0B0	0000005C	00000018	FFFFFFF9	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG UNTxpTxBxJoWIeZP:]	__text	0028F10C	0000017E	00000038	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG TVOkxTgmPvvUQgyG]	__text	0028F28A	000000E6	00000014	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG ByPwWewvzRduvJAZ:]	__text	0028F370	000006D0	00000050	0000015C	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG lMMzCjtHIpwhEYDe]	__text	0028FA40	0000008A	00000010	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG lFgomfELMhFbEmAP]	__text	0028FACA	0000045A	00000038	000000A0	.	.	.	.	.	T	.
sub_28FF28	__text	0028FF28	000000EE	00000020	FFFFFFF9	.	.	.	.	.	.	.
sub_290126	__text	00290126	000000EE	00000020	FFFFFFF9	.	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG TsKjfpgzwErnqaRz]	__text	00290326	000003A6	00000088	00000050	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG dFslcfROBneVXIcP]	__text	002906CC	000000F4	00000028	FFFFFFF9	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG gvUiVteWORiIBItH]	__text	002908C2	000001F2	00000030	FFFFFFF9	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG dvgqYNRRWfWlzrMR]	__text	00290AB4	000001F2	00000024	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG cYPTTHyfdZrmlGeJ]	__text	00290CA6	00000442	0000003C	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG qmBOCGqdppELEuhx:]	__text	002910FC	000006AE	00000064	00000014	.	.	.	.	.	T	.
sub_2917AA	__text	002917AA	00000014			.	.	.	.	.	.	.
sub_2917BE	__text	002917BE	00000014			R	.	.	.	.	.	.
sub_2917D2	__text	002917D2	00000002			R	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG xkbtCZfVnlokDiQQ]	__text	002917DE	0000023C	00000058	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG actionSheet:didDismissWithButtonIndex:]	__text	00291A1A	000000B2	0000002C	FFFFFFF9	R	.	.	.	.	T	.
sub_291ACC	__text	00291ACC	00000030			R	.	.	.	.	.	.
sub_291AFC	__text	00291AFC	00000006			R	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG QKcrTsEUijhKlYkK]	__text	00291B08	00000362	00000044	FFFFFFF9	.	.	.	.	.	T	.
sub_291E6A	__text	00291E6A	0000061C	00000068	FFFFFFF9	R	.	.	.	.	.	.
sub_292486	__text	00292486	00000078	00000010	FFFFFFF9	.	.	.	.	.	.	.
sub_2924FE	__text	002924FE	00000008			R	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG numberOfSectionsInTableView:]	__text	00292506	00000004			R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG tableView:numberOfRowsInSection:]	__text	0029250A	00000018			R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG tableView:titleForHeaderInSection:]	__text	00292522	0000037E	00000070	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG tableView:cellForRowAtIndexPath:]	__text	002928A0	00002022	00000060	000005A4	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG OhUMmGPeGwZZDBtc]	__text	002950D6	00000198	00000014	00000034	R	.	.	.	.	T	.
sub_29526E	__text	0029526E	00000028			R	.	.	.	.	.	.
sub_295296	__text	00295296	00000008			R	.	.	.	.	.	.
-[DfzeGXHoBCzYUNyG jmkaknJHAflckoIm]	__text	002952A2	000003BC	00000018	00000008	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG rOOryYkvHSZTcyEr]	__text	002956CC	00000092	00000018	FFFFFFF9	R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG PeRitUKptnhtvumt]	__text	00295762	0000009C	00000014	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG WEGZcpPXhqEpYzTJ:]	__text	0029605E	000000FC	00000018	FFFFFFF9	.	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG VbuxthvxmYrmdAnn]	__text	002962E6	00000012			R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG FtJrvgWmZdeEYCrm]	__text	00296308	00000010			R	.	.	.	.	T	.
-[DfzeGXHoBCzYUNyG setFtJrvgWmZdeEYCrm:]	__text	00296318	00000010			R	.	.	.	.	T	.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现类名和大部分类函数都没有具体的意义,可能是都被混淆了,一个一个函数查看有没有线索,在&lt;code class=&quot;highlighter-rouge&quot;&gt;DfzeGXHoBCzYUNyG tableView:cellForRowAtIndexPath&lt;/code&gt;函数中发现一些字符串&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;v25 = objc_msgSend(v24, &quot;localizedStringForKey:value:table:&quot;, CFSTR(&quot;License&quot;), &amp;amp;stru_657918, 0);
v46 = objc_msgSend(v45, &quot;localizedStringForKey:value:table:&quot;, CFSTR(&quot;valid till %@&quot;), &amp;amp;stru_657918, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以及一些其他的在截图中被打码部分的对应字符串,到这里,想到应该把手机的系统语言设置成&lt;code class=&quot;highlighter-rouge&quot;&gt;English&lt;/code&gt;,这样破解起来更清晰,将手机系统语言设置成英文后,app截图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/crack_deb2.png&quot; alt=&quot;English&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;step3-暴破&quot;&gt;step3 暴破&lt;/h4&gt;

&lt;p&gt;上图可看到对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;License&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Unauthorized&lt;/code&gt;,由于这里的函数大多被混淆了,现在尝试通过关键字进行破解,在&lt;code class=&quot;highlighter-rouge&quot;&gt;ida&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;strings&lt;/code&gt;窗口中搜索Unauthorized,找到后双击,在&lt;code class=&quot;highlighter-rouge&quot;&gt;IDA view&lt;/code&gt;窗口中右键查看调用了此处的代码,没有找到什么有用的信息.后来通过在app中点击使用正常功能的对应按钮,弹出警告窗口如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/alert.png&quot; alt=&quot;alert&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中显示”License not activated,please purchase”,在strings窗口中搜索这串字符,找到调用这串字符相关的代码,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/purchase_ref.png&quot; alt=&quot;purchase_ref&quot; /&gt;&lt;/p&gt;

&lt;p&gt;涉及3个函数,分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;+[UrsUiQqCjhigLsxP bYYENZFgIdldmiUx]&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_ACB60&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;-[UrsUiQqCjhigLsxP tableView:didSelectRowAtIndexPath:]&lt;/code&gt;,将这3处分别patch(if xxx jump xxx,改成if not xxx jump xxx),将patch后的文件替换手机中的对应文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;find / -name &quot;appname&quot;&lt;/code&gt;),重新在手机中运行app,验证成功破解&lt;/p&gt;

&lt;p&gt;如果需要将破解后的app保留以备后用,可将deb文件重新打包,可参考&lt;a href=&quot;http://blog.csdn.net/yygydjkthh/article/details/36695243&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x3-后记&quot;&gt;0x3 后记&lt;/h3&gt;

&lt;p&gt;后来尝试重新动态调试破解,有以下绕过反调试过程&lt;/p&gt;

&lt;h4 id=&quot;绕过反调试&quot;&gt;绕过反调试&lt;/h4&gt;

&lt;p&gt;这个app直接使用ida远程调试时会发现无法调试,为了找到反调试代码,在app入口&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;函数处下断点(可在ida的&lt;code class=&quot;highlighter-rouge&quot;&gt;Exports&lt;/code&gt;视图中快速找到&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;函数),内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int __fastcall start(int a1, int a2)
{
  int v2; // r5
  int v3; // r6
  int v4; // r0
  int v5; // r8
  void *v6; // r0
  int v7; // r0
  int v8; // r4
  int v9; // r5

  v2 = a2;
  v3 = a1;
  v4 = sub_2E3686();
  v5 = objc_autoreleasePoolPush(v4);
  v6 = objc_msgSend(&amp;amp;OBJC_CLASS___JefhStRvMGfrygNL, &quot;class&quot;);
  v7 = NSStringFromClass(v6);
  v8 = objc_retainAutoreleasedReturnValue(v7);
  v9 = UIApplicationMain(v3, v2, 0, v8);
  objc_release(v8);
  objc_autoreleasePoolPop(v5);
  return v9;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在start函数里&lt;code class=&quot;highlighter-rouge&quot;&gt;step over&lt;/code&gt;单步调试,发现运行到&lt;code class=&quot;highlighter-rouge&quot;&gt;sub_2e3686&lt;/code&gt;函数中有个&lt;code class=&quot;highlighter-rouge&quot;&gt;ptrace&lt;/code&gt;调用,这是一种反调试方法(其他反调试方法可参考&lt;a href=&quot;http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/17/%E5%8F%8D%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF%E5%BA%93/&quot;&gt;这里&lt;/a&gt;).于是将ptrace的调用nop掉,然后patch原可执行文件后重新远程调试&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.这里由于是远程调试,ida可能在将patch内容写入到原文件时有个bug.因为远程调试时在调试设置中的可执行文件的路径是远程手机上的路径,如这里的路径是&lt;code class=&quot;highlighter-rouge&quot;&gt;/Applications/xxx.app/xxx&lt;/code&gt;,在ida中&lt;code class=&quot;highlighter-rouge&quot;&gt;edit|patch program|apply patches to input file&lt;/code&gt;时无法将修改的内容写入到远程手机上的app,需要在patch前将input file的路径设置为ida所在pc本地的已经存在的可执行文件,但是这个设置不能在&lt;code class=&quot;highlighter-rouge&quot;&gt;edit|patch program|apply patches to input file&lt;/code&gt;弹出的对话框中设置,在这里设置后发现没有成功path,需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;debugger|process option&lt;/code&gt;这里设置,设置好后再去&lt;code class=&quot;highlighter-rouge&quot;&gt;edit|patch program|apply patches to input file&lt;/code&gt;可成功patch到IDA所在pc的可执行文件,patch完成后再将本地所在的可执行文件拷贝到远程手机中,再重新进行远程调试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.在远程调试时,ida默认不勾选下图中的&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend on debugging start&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;suspend on process entry point&lt;/code&gt;,这两个选项要手动勾上,因为如果被调试的程序有&lt;code class=&quot;highlighter-rouge&quot;&gt;反调试机制&lt;/code&gt;而没有勾选这两个选项,则不能在反调试代码运行前将被调试程序中断下来,因为这里是远程调试,一般需要rebase program,只有rebase program后断点才会正常中断.如果没有勾选这两个选项则会在人工rebase program前(也即正常调试目标程序前)就发生了反调试代码的运行,这样就无法调试了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.cydia中的deb有些是32位的,要根据具体情况选择用32位的ida还是用64位的ida,如果app的位数与ida的位数不一致会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;hex-rays decompiler&lt;/code&gt;插件会不起作用&lt;/strong&gt;,或者在rebase program时出问题.如果发现ida使用remote ios debugger+usb调试时ida还经常是”卡”的状态,很有可能是因为app的位数与ida位数不一致造成(如64位的app用到了32位的ida调试)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/anti_anti_debug.png&quot; alt=&quot;反调试要勾选&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/16/%E5%AE%9E%E6%88%98ios%E7%A0%B4%E8%A7%A3-%E9%80%9A%E8%BF%87UI%E6%89%BE%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/16/%E5%AE%9E%E6%88%98ios%E7%A0%B4%E8%A7%A3-%E9%80%9A%E8%BF%87UI%E6%89%BE%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0/</guid>
        
        <category>ios</category>
        
        <category>UI</category>
        
        <category>cycript</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ios应用逆向工程5-6章笔记</title>
        <description>&lt;h3 id=&quot;理论篇&quot;&gt;理论篇&lt;/h3&gt;

&lt;p&gt;1.依据维基百科的定义,tweak指的是对电子系统进行轻微调整来增强其功能的工具;在iOS中,tweak特指那些能够增强基他进程功能的dylib,是越狱iOS的最重要组成部分.这种增强原有工具功能的方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;进程注入&lt;/code&gt;实现的,就像书籍的知识注入大脑的,让大脑变得更强&lt;/p&gt;

&lt;p&gt;2.一般来说,编写tweak会用到C,C++和Objective-C三种语言&lt;/p&gt;

&lt;p&gt;3.iOS是个封闭的系统,它暴露给我们的中是冰山一角,有太多太多的功能还有待我们进一步挖掘.每次越狱发布后,都会有人把最新的头文件发布出来,google一下&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS private headers&lt;/code&gt;即可轻松找到下载链接,省去了自己class-dump的麻烦&lt;/p&gt;

&lt;p&gt;4.定位目标文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;固定位置
  我们的逆向目标一般是dylib,bundle或daemon,它们在系统中的位置几乎是固定的:
    &lt;ul&gt;
      &lt;li&gt;基于CydiaSubstrate的dylib全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/MobileSubstrate/DynamicLibraries/&lt;/code&gt;下,几乎不费吹灰之力就可以轻松定位&lt;/li&gt;
      &lt;li&gt;bundle主要分为App和framework两类,其中Appstore App全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile/Containers/Bundle/Application&lt;/code&gt;下,系统App全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/Applications&lt;/code&gt;下,framework全部位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/Frameworks&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/PrivateFrameworks&lt;/code&gt;下&lt;/li&gt;
      &lt;li&gt;daemon的配置文件均位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/System/Library/LaunchDaemons/&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchDaemons&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/LaunchAgents/&lt;/code&gt;下,是一个plist格式的文件.其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ProgramArguments&lt;/code&gt;字段,即是daemon可执行文件的绝对路径&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;cydia
  通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg -i&lt;/code&gt;安装的的deb包,内容会被cydia如实记录,可在cydia中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Filesystem Content&lt;/code&gt;中找到路径&lt;/li&gt;
  &lt;li&gt;PreferenceBundle
  PreferenceBundle是寄生在Settings应用里的App,它的功能界定有些模糊,既可以作为单纯的配置文件,由别的进程读取后执行,也可以估计有实际功能,自己来执行一些操作.来自AppStore的第三方PreferenceBundle仅可作为配置文件存在,不会含有实际功能;来自Cydia的也不是问题,可通过上面的定位方式找到路径;但对于iOS自带的PreferenceBundle来说,定位的过程就要复杂一些.PreferenceBundle的界面可以用代码编写,也可以用固定格式的plist文件构造.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cycript&lt;/code&gt;可快速测试函数功能,比theos方便&lt;/p&gt;

&lt;p&gt;6.解析函数参数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getClassName&lt;/code&gt;函数能够把对象的类名表示成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;char*&lt;/code&gt;,如&lt;code class=&quot;highlighter-rouge&quot;&gt;object_getClassName(arg1)&lt;/code&gt;获取arg1这个对象的的对象类名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;函数能够把对象的内容表示成一个NSString,如&lt;code class=&quot;highlighter-rouge&quot;&gt;[arg1 description]&lt;/code&gt;获取arg1这个对象的对象内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%hook SBScreenFlash
- (void)flashColor:(id)arg1 withCompletion:(id)arg2
{
    %orig;
    NSLog(@&quot;iOSRE: flashColor: %s, %@&quot;, object_getClassName(arg1),arg1);//[arg1 description]可以直接写成arg1
}
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的示例中打印的结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;iOSRE: flashColor: UICachedDeviceWhiteColor, UIDeviceWhiteColorSpace 1 1&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;UICachedDeviceWhiteColor&lt;/code&gt;是对象类名,&lt;code class=&quot;highlighter-rouge&quot;&gt;UIDeviceWhiteColorSpace 1 1&lt;/code&gt;是对象内容&lt;/p&gt;

&lt;p&gt;7.书籍作者强烈建议大家通览class-dump出的头文件,把那些语义明显,自己感兴趣的函数放到iOS上实测一下,这个过程能极大地增加对iOS底层的熟悉程度&lt;/p&gt;

&lt;p&gt;8.ARM处理器中的特殊用途的寄存器&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;R0-R3     传递参数与返回值&lt;/li&gt;
  &lt;li&gt;R7        帧指针,指向母函数与被调用子函数在栈中的交界(相当于ebp?)&lt;/li&gt;
  &lt;li&gt;R9        在ios3.0以前被系统保留&lt;/li&gt;
  &lt;li&gt;R12       内部过程调用寄存器,dynamic linker会用到它&lt;/li&gt;
  &lt;li&gt;R13       SP寄存器(相当于esp?)&lt;/li&gt;
  &lt;li&gt;R14       LR寄存器,保存函数返回地址(居然有一个单独的寄存器用来保存函数返回地址)&lt;/li&gt;
  &lt;li&gt;R15       PC寄存器(相当于eip?)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9.ARM调用规则
在执行一块代码时,其前后栈地址应该是不变的.这个操作是通过被执行代码块的前言和后记完成的.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;前言
    &lt;ul&gt;
      &lt;li&gt;将LR入栈&lt;/li&gt;
      &lt;li&gt;将R7入栈(push ebp)&lt;/li&gt;
      &lt;li&gt;R7=SP&lt;/li&gt;
      &lt;li&gt;将需要保留的寄存器原始值入栈&lt;/li&gt;
      &lt;li&gt;为本地变量开辟空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;后记
    &lt;ul&gt;
      &lt;li&gt;释放本地变量占用的空间&lt;/li&gt;
      &lt;li&gt;将需要保留的原始值出栈&lt;/li&gt;
      &lt;li&gt;将R7出栈&lt;/li&gt;
      &lt;li&gt;将LR出栈,PC=LR&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;10.函数调用&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;32位ARM函数调用时,函数的前4个参数存放在R0到R3中,其他参数存放在栈中;返回值放在R0中&lt;/li&gt;
  &lt;li&gt;ARM64汇编语言函数前8个参数使用x0-x7寄存器(或w0-w7寄存器)传递,多于8个的参数均通过堆栈传递,并且返回值通过x0寄存器(或w0寄存器)返回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11.ARM处理器用到的指令集分为ARM和THUMB两种;ARM指令长度均为32bit,THUMB指令长度均为16bit.THUMB指令比ARM指令更节省空间,且在16位数据总线上的传输效率更高,相对于ARM指令,THUMB指令的缺点如下&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;指令数量减少&lt;/li&gt;
  &lt;li&gt;没有条件执行&lt;/li&gt;
  &lt;li&gt;所有指令默认附带”s”&lt;/li&gt;
  &lt;li&gt;桶式移位无法结合其他指令执行&lt;/li&gt;
  &lt;li&gt;寄存器使用受限&lt;/li&gt;
  &lt;li&gt;立即数和第二操作数使用受限&lt;/li&gt;
  &lt;li&gt;不支持数据写回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12.ARM32位处理器的所有指令可大致分为3类,分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;数据操作指令&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;内存操作指令&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;分支指令&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数据操作指令
所有操作数均为32位,所有的结果均为32位,且只能存放在寄存器中
    &lt;ul&gt;
      &lt;li&gt;算术操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ADD R0,R1,R2        ;R0=R1+R2
  ADC R0,R1,R2        ;R0=R1+R2+C(arry)
  SUB R0,R1,R2        ;R0=R1-R2
  SBC R0,R1,R2        ;R0=R1-R2-!C
  RSB R0,R1,R2        ;R0=R2-R1
  RSC R0,R1,R2        ;R0=R2-R1-!C
  以&quot;C&quot;(即Carry)结尾的变种代表有进位和借位的加减法,当产生进位或没有借位时,将Carry flag置1
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;逻辑操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  AND R0,R1,R2        ;R0=R1&amp;amp;R2
  ORR R0,R1,R2        ;R0=R1|R2
  EOR R0,R1,R2        ;R0=R1^R2
  BIC R0,R1,R2        ;R0=R1&amp;amp;~R2
  MOV R0,R2           ;R0=R2
  MVN R0,R2           ;R0=~R2
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;比较操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  CMP R1,R2           ;执行R1-R2并依据结果设置flag
  CMN R1,R2           ;执行R1+R2并依据结果设置flag
  TST R1,R2           ;执行R1&amp;amp;R2并依据结果设置flag
  TEQ R1,R2           ;执行R1^R2并依据结果设置flag
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;乘法操作
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  MUL R4,R3,R2        ;R4=R3*R2
  MLA R4,R3,R2,R1     ;R4=R3*R2+R1
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;内存操作指令
ARM内存操作只有2个基础指令,&lt;code class=&quot;highlighter-rouge&quot;&gt;LDR&lt;/code&gt;(load register)将内存中的数据存到寄存器(cpu),&lt;code class=&quot;highlighter-rouge&quot;&gt;STR&lt;/code&gt;(store register)将寄存器(cpu)中的数据保存到内存.除了LDR和STR外,还可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;LDM(load multiple)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;STM(store multiple)&lt;/code&gt;进行块传输,一次性操作多个寄存器.需要特别注意的是,LDM和STM的操作方向与LDR和STR完全相反:LDM是把从Rd开始,地址连续的内存数据存入reglist中,STM是把reglist中的值存入从Rd开始,地址连续的内存中.
    &lt;ul&gt;
      &lt;li&gt;LDR
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  LDR Rt,[Rn{,#offset}]       ;Rt=*(Rn{+offset}),{}代表可选
  LDR Rt,[Rn,#offset]!        ;Rt=*(Rn+offset);Rn=Rn+offset
  LDR Rt,[Rn,#offset]         ;Rt=*Rn;Rn=Rn+offset
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;STR
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  STR Rt,[Rn{,#offset}]       ;*(Rn{+offset})=Rt
  STR Rt,[Rn,#offset]!        ;*(Rn{+offset})=Rt;Rn=Rn+offset
  STR Rt,[Rn],#offset         ;*Rn=Rt;Rn=Rn+offset
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分支指令
    &lt;ul&gt;
      &lt;li&gt;无条件分支
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  B label             ;PC=label
  BL label            ;LR=PC-4;PC=label
  BX Rd               ;PC=Rd并切换指令集
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;条件分支
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  EQ                  ;Z=1
  NE                  ;Z=0
  CS                  ;C=1
  HS                  ;C=1
  CC                  ;C=0
  LO                  ;C=0
  MI                  ;N=1
  PL                  ;N=0
  VS                  ;V=1
  VC                  ;V=0
  HI                  ;C=1 &amp;amp; Z=0
  LS                  ;C=0 | Z=1
  GE                  ;N=V
  LT                  ;N!=V
  GT                  ;Z=0 &amp;amp; n=V
  LE                  ;Z=1 | N!=V
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;例如&lt;a href=&quot;http://blog.csdn.net/marc07/article/details/62885832&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://blog.csdn.net/qq1084283172/article/details/47296931&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;13.函数和UI之间的关联非常紧密,如果能拿到感兴趣的UI对象,就可以找到它所对应的函数,我们称该函数为UI函数.这个过程,一般是利用cycript,结合UIView中的神奇私有函数&lt;code class=&quot;highlighter-rouge&quot;&gt;recursiveDescription&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;nextResponder&lt;/code&gt;来实现的.注意,游戏一般不是采用UIKit来构建UI的,recursiveDescription和nextResponder不适用于游戏.&lt;/p&gt;

</description>
        <pubDate>Wed, 10 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/10/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B5-6%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2018/01/10/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B5-6%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>ios</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>frida用法</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;记录适用于ios的objective-c的类中函数的frida的用法&lt;/p&gt;

&lt;h3 id=&quot;0x1-必读&quot;&gt;0x1 必读&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.frida.re/docs/home/&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.frida.re/docs/javascript-api/&quot;&gt;API&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.voidcn.com/article/p-cuytgsnz-w.html&quot;&gt;官方文档部分翻译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/85758&quot;&gt;利用FRIDA攻击Android应用程序1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/85759&quot;&gt;利用FRIDA攻击Android应用程序2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;如何在iOS应用程序中用Frida来绕过”越狱检测”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;使用Frida配合Burp Suite追踪API调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/sectool/142928.html&quot;&gt;利用Frida从TeamViewer内存中提取密码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/sectool/143360.html&quot;&gt;Brida:使用Frida进行移动应用渗透测试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/86567&quot;&gt;联合Frida和BurpSuite的强大扩展–Brida&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24020686&quot;&gt;Object-C测试工具与Frida&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x2-安装&quot;&gt;0x2 安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install frida
或
从这里下载 https://build.frida.re/frida/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x3-frida的常见用法&quot;&gt;0x3 frida的常见用法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;0xa hook函数(ios中theos具备的功能)&lt;/li&gt;
  &lt;li&gt;0xb 记录函数执行日志(ios中theos具备的功能)&lt;/li&gt;
  &lt;li&gt;0xc 调用函数(ios中&lt;a href=&quot;http://www.cycript.org/&quot;&gt;cycript&lt;/a&gt;具备的功能)&lt;/li&gt;
  &lt;li&gt;0xd 读写内存(类似于调试器的功能)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用frida有两种方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;命令行[实现简单功能推荐]:
  &lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l xxx.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;api调用[实现复杂功能推荐]:
  例如使用python调用frida的python api来写python脚本实现相应功能,使用python调用api时,推荐阅读api实现细节&lt;a href=&quot;https://github.com/frida/frida-python/blob/master/src/frida/core.py&quot;&gt;frida/core.py&lt;/a&gt;,&lt;a href=&quot;https://github.com/frida/frida-python/blob/master/src/frida/tracer.py&quot;&gt;frida/tracer.py&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的4种用法可能会涉及到如下js&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/classes.js&quot;&gt;classes.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (var className in ObjC.classes)
    {
        if (ObjC.classes.hasOwnProperty(className))
        {
            console.log(className);
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/methodsofclass.js&quot;&gt;methodofclass.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(&quot;[*] Started: Find All Methods of a Specific Class&quot;);
if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var methods = eval('ObjC.classes.' + className + '.$methods');
        for (var i = 0; i &amp;lt; methods.length; i++)
        {
            try
            {
                console.log(&quot;[-] &quot;+methods[i]);
            }
            catch(err)
            {
                console.log(&quot;[!] Exception1: &quot; + err.message);
            }
        }
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
console.log(&quot;[*] Completed: Find All Methods of a Specific Class&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/record.js&quot;&gt;record.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var funcName = &quot;- xxx&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            //注意:有时args参数值在这里会是一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //这里假设args[2]是要记录的参数
            //ObjC.classes.NSString.stringWithString_(args[2])或者args[2].toString()或者ObjC.classes.NSString.stringWithString_(args[2]).toString()
            //具体情况需要测试下是上面这3种的哪种写法
            console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]);
          },
          onLeave: function(retval) {
            //注意:retval一般会返回一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //ObjC.classes.NSString.stringWithString_(retval)或者retval.toString()或者ObjC.classes.NSString.stringWithString_(retval).toString()
            //具体情况需要测试下是上面这3种的哪种写法
            console.log(&quot;Return value-&amp;gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/3xp10it/mytools/blob/master/overwrite.js&quot;&gt;overwrite.js&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;PARSPedometerInfo&quot;;
        var funcName = &quot;- integratedSteps&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;Original args0-&amp;gt; (type:&quot;+typeof args[0]+&quot;,value:&quot;+args[0]+&quot;)&quot;);
            newargs0=ptr('xxx')
            args[0]=newargs0
            console.log(&quot;New args0-&amp;gt; (type:&quot;+typeof args[0]+&quot;,value:&quot;+args[0]+&quot;)&quot;);
          },
          onLeave: function(retval) {
            //注意:retval永远是一个对象,如果函数返回值是字符串类型,为了更好理解则要这样写
            //string_value=ObjC.classes.NSString.stringWithString_(retval)
            //console.log(&quot;Original return value-&amp;gt; (type:&quot;+typeof string_value+&quot;,value:&quot;+string_value+&quot;)&quot;);
            //newretval=ObjC.classes.NSString.stringWithString_(&quot;xxxx&quot;)
            //retval.replace(newretval)
            //console.log(&quot;New return value-&amp;gt; (type:&quot;+typeof newretval+&quot;,value:&quot;+newretval+&quot;)&quot;);

            console.log(&quot;Origin return value-&amp;gt; (type:&quot;+typeof retval&quot;,value:&quot;+retval+&quot;)&quot;);
            newretval=ptr(&quot;xxxx&quot;)
            retval.replace(newretval)
            console.log(&quot;New return value-&amp;gt; (type:&quot;+typeof newretval&quot;,value:&quot;+newretval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xa-hook函数&quot;&gt;0xa hook函数&lt;/h4&gt;

&lt;p&gt;frida的hook函数功能在ios逆向中相当于theos的hook函数时修改函数的功能(theos相当于打补丁),但是比theos更方便,不用打包成deb安装,缺点是hook函数的语法没有theos简单.hook函数可通过命令行实现(可通过js热切换功能),也可通过其他语言调用frida的api来实现,通过其他语言(如python)调用api来实现时可做到更加”自动化”.在hook函数前要先找到要hook的函数名,可以通过frida枚举类中所有方法来查找或是通过ida反汇编后查看&lt;code class=&quot;highlighter-rouge&quot;&gt;functions窗口&lt;/code&gt;得到,其中&lt;strong&gt;通过frida得到的类中的函数名比通过ida得到的类中的函数名更全&lt;/strong&gt;,因为frida会得到父类的函数,而ida的functions窗口看不到父类的函数名,如果只看ida中类的函数则会错失很多从父类继承的函数名.为了hook一个类中的函数,首先要找到这个类名和函数名,一般找类名是通过ida来分析得出,找到类名后再找未知的函数名时建议通过frida查找(这里是指静态分析时根据函数名猜测实现的对应功能,如果是动态调试则不用根据函数名来猜测对应功能).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;找类&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l classes.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;找类函数&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l methodofclass.js&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;hook函数&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l overwrite.js&lt;/code&gt;,也可通过python api如下实现,其中js通过&lt;code class=&quot;highlighter-rouge&quot;&gt;send()&lt;/code&gt;传递内容到python中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前由于在测试时发现ios objective-c的函数如果有参数,打印参数发现不是真的参数,在hook时修改函数参数也会不成功,&lt;a href=&quot;https://github.com/frida/frida/issues/399&quot;&gt;详情&lt;/a&gt;,于是以为frida有bug,后来发现是参数序号写错了,ida中该函数如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __cdecl -[PARSPedometerInfo setIntegratedSteps:](PARSPedometerInfo *self, SEL a2, signed __int64 a3)
{
  self-&amp;gt;_integratedSteps = a3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面函数中,a3参数正确的序号是2,(虽然在theos中hook这个函数时只需填写一个参数,[&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments&lt;/code&gt;]),最后代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(797)
script_string = &quot;&quot;&quot;
if (ObjC.available)
{
    try
    {
        var className = &quot;PARSPedometerInfo&quot;;
        var funcName = &quot;- integratedSteps&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;Original args0-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0])

            newargs0=ptr('xxx')
            args[0]=newargs0
            console.log(&quot;New args0-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0]&quot;)
            send(args[0]);
          },
          onLeave: function(retval) {
            console.log(&quot;Original retval-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+args[0])

            newretval=ptr(&quot;xxxx&quot;)
            retval.replace(newretval)
            console.log(&quot;New retval-&amp;gt; type:&quot;+typeof args[0]+&quot; value:&quot;+newretval)
            send(newretval)
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[i] &quot; + message['payload'])
    else:
        print(message)


script.on('message', on_message)
script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xb-记录函数执行日志&quot;&gt;0xb 记录函数执行日志&lt;/h4&gt;

&lt;p&gt;frida的记录函数执行日志功能在ios逆向中相当于theos的hook函数时记录函数参数和返回值的功能(theos相当于打补丁),优缺点同上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;0xa hook函数&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;frida -U -p pid -l record.js&lt;/code&gt;,或用如下python脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(797)
script_string = &quot;&quot;&quot;

if (ObjC.available)
{
    try
    {
        var className = &quot;xxx&quot;;
        var funcName = &quot;- xxx&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;param:&quot;+args[0]+&quot; type:&quot;+typeof args[0]);
          },
          onLeave: function(retval) {
            console.log(&quot;retval:&quot;+retval+&quot; type:&quot;+typeof retval);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;

script = session.create_script(script_string)
script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xc-调用函数&quot;&gt;0xc 调用函数&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;号开头的函数要&lt;a href=&quot;https://www.frida.re/docs/javascript-api/#objc&quot;&gt;这样&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id __cdecl +[NSString stringWithStrings:](NSString_meta *self, SEL a2, id a3)
{
  __int64 v3; // x20
  void *v4; // x0
  void *v5; // x19
    ...
}


[NSString stringWithString:@&quot;Hello World&quot;] 
becomes 
var NSString = ObjC.classes.NSString; NSString.stringWithString_(&quot;Hello World&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的函数要这样:&lt;/p&gt;

&lt;p&gt;如下代码中调用了PARSHealthPedometer10thHomeViewController类中的requestUploadWithSure函数,这里的requestUploadWithSure函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的函数,其中函数的参数为1,如果requestUploadWithSure函数没有参数,则写法为&lt;code class=&quot;highlighter-rouge&quot;&gt;my_obj[&quot;- requestUploadWithSure&quot;]()&lt;/code&gt;,如果要调用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号开头的类的函数,有2种情况:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内存中还没有类的一个实例(对象)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况需要手动生成一个实例,用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjC.classes.类名.alloc()&lt;/code&gt;,在下面的代码中对应&lt;code class=&quot;highlighter-rouge&quot;&gt;var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;alloc()&lt;/code&gt;的作用是生成一个类的对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在内存中已经有类的实例(对象)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种情况需要先找出一个类的实例,使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var tmp=ObjC.chooseSync(ObjC.classes.类名)&lt;/code&gt;,在下面的代码中对应&lt;code class=&quot;highlighter-rouge&quot;&gt;var tmp=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]&lt;/code&gt;,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;[0]&lt;/code&gt;表示取找到的实例中的第一个实例,可根据实际情况换成其他的实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys

session = frida.get_usb_device().attach(897)
script_string = &quot;&quot;&quot;

if (ObjC.available)
{
    try
    {
        //var my_obj=ObjC.chooseSync(ObjC.classes.PARSHealthPedometer10thHomeViewController)[0]
        var my_obj=ObjC.classes.PARSHealthPedometer10thHomeViewController.alloc()
        my_obj[&quot;- requestUploadWithSure:&quot;](1)
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[i] &quot; + message['payload'])
    else:
        print(message)


script.on('message', on_message)
script.load()
sys.stdin.read()
&quot;&quot;&quot;


script = session.create_script(script_string)

script.load()
sys.stdin.read()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xd-读写内存&quot;&gt;0xd 读写内存&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;获取模块加载基址&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可在ida调试ios app时替代vmmap获取加载基址.获取ios app加载基址用法如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
#session = frida.get_usb_device().attach(pid_int_value)
session = frida.get_usb_device().attach(&quot;PALxxx&quot;)
print(session.enumerate_modules())

或者

import frida
#session = frida.get_usb_device().attach(pid_int_value)
session = frida.get_usb_device().attach(&quot;PALxxx&quot;)
base_addr=session.find_base_address(&quot;PALxxx&quot;)
print('0x%x' % base_addr)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;枚举内存范围&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.enumerate_ranges('rw-')&lt;/code&gt;:可找出可读可写的内存
&lt;code class=&quot;highlighter-rouge&quot;&gt;s.enumerate_ranges('rwx')&lt;/code&gt;:可找出可读可写可执行的内存&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;read/write memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.read_bytes(4468416512, 5)&lt;/code&gt;,等同于&lt;code class=&quot;highlighter-rouge&quot;&gt;s.read_bytes(0x10a56a000, 5)&lt;/code&gt;:在0x10a56a000上读5个字节
&lt;code class=&quot;highlighter-rouge&quot;&gt;s.write_bytes(4468416512, &quot;frida&quot;)&lt;/code&gt;:在0x10a56a000上写入”frida”&lt;/p&gt;

&lt;p&gt;一个读内存应用实例&lt;a href=&quot;http://www.freebuf.com/sectool/142928.html&quot;&gt;利用Frida从TeamViewer内存中提取密码&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x4-实战&quot;&gt;0x4 实战&lt;/h3&gt;

&lt;h4 id=&quot;0xa-理解brida&quot;&gt;0xa 理解brida&lt;/h4&gt;

&lt;p&gt;为了理解brida,需要理解pyro,参考这两个个连接(&lt;a href=&quot;http://blog.csdn.net/xiaolewennofollow/article/details/52155457&quot;&gt;1&lt;/a&gt;,&lt;a href=&quot;http://python.blog.163.com/blog/static/183010453201201145855429/&quot;&gt;2&lt;/a&gt;)可理解pyro.理解pyro后再理解brida,理解brida后再看看brida中用到的pyro与&lt;a href=&quot;http://5alt.me/2017/11/我是如何用hrida自动生成签名的/&quot;&gt;这里的hrida&lt;/a&gt;,发现只是区别如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brida:通过pyro开启rpc
hrida:通过http服务开rpc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里brida和hrida开rpc的意义在于可以给网络上的其他用户使用本地的frida提供的的调用app中函数的的接口,但是frida已经有了rpc,为什么brida和hrida还要重新开rpc呢?因为frida的rpc只能给本地的其他程序使用(frida的rpc功能也可通过动态修改js内容和send修改后的js的执行结果给python来实现,因为frida加载js会热更新,这样修改js时可修改函数调用,并将函数执行结果发送给python),不能给网络上的其他程序使用,brida开rpc的意义不是很大,因为brida开rpc后是给本地的安全人员写的burp插件使用的,除非安全人员有几个好友,这样这些好友之间就可只要求其中一个人开启brida的rpc服务,其他人使用这个人的brida的rpc即可.frida注入app后可通过开rpc给网络上的其他用户提供调用app函数的接口,例如可通过本地frida注入某上传步数的App后将上传步数的接口通过rpc提供给网络上的人使用&lt;/p&gt;

&lt;p&gt;brida工作原理如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/brida.png&quot; alt=&quot;brida原理图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也即,brida调用frida的rpc后通过pyro开启一个rpc给安全人员写的burp插件用,目前笔者认为brida只能用于辅助对称加密(如aes)的加密后的数据,也即brida工作时,人工调用brida的解密功能解密数据后再修改数据,然后将修改后的数据再用brida的加密功能加密好,加密好之后再通过burpsuite发送给正常的远程服务器.如果要通过burpsuite来修改非对称加密(如rsa)的加密后的数据需要使用下面的方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/web/125260.html&quot;&gt;使用Frida配合Burp Suite追踪API调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面这个链接里的思路是这样的:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;App(frida)在数据加密前将明文发给burp,burp在人为修改数据后发给回显服务程序,回显服务程序打印burp发来的修改后的数据后,将这个数据发给App(frida).App(frida)收到回显服务程序发来的数据后看看这个数据是哪来的,如果是app没加密之前的数据就发给burp,如果是回显服务程序发来的数据就进行加密,然后再发给正常的服务器进行正常的请求.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面链接里的方法看上去只能用于&lt;code class=&quot;highlighter-rouge&quot;&gt;整个post的data部分被加密&lt;/code&gt;的情况,不能用于&lt;code class=&quot;highlighter-rouge&quot;&gt;部分get或post的参数值被加密&lt;/code&gt;的情况,后来笔者写了一个工具&lt;a href=&quot;https://github.com/3xp10it/xenc&quot;&gt;xenc&lt;/a&gt;,可用于2种情况下的加密测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1.get或post内容形如&lt;code class=&quot;highlighter-rouge&quot;&gt;mobilePhone=Nns7415cyOT0FkzwbjiXmahxvFt6tfw1Dda8id=1&amp;amp;a=2&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;2.post的整个data部分内容形如&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ÜñCHÁ*'-»84}_9Óûû84}_9Óûû884}_9Óûû84}_9Óû_9Óûû&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;0xb-实战绕过rsa&quot;&gt;0xb 实战”绕过rsa”&lt;/h4&gt;

&lt;p&gt;这里用&lt;a href=&quot;https://github.com/3xp10it/xenc&quot;&gt;xenc&lt;/a&gt;来测试&lt;code class=&quot;highlighter-rouge&quot;&gt;部分get或post的参数值被加密&lt;/code&gt;的情况&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:手机不要黑屏,app要保证在前台不能在后台运行,黑屏或app进了后台会导致python调用ios app中的加密函数会超时,超时后可将手机打开可继续使用app的加密函数,最好保持手机不自动黑屏并保证app不进后台&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;js文件如下,其中&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;函数是一个rsa加密函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'use strict';

rpc.exports = {
    encrypt: function (plain) {
        var result=ObjC.classes.PARSCryptDataUtils.encryptWithServerTimestamp_(plain)
        return result.toString()
    },
    add: function (a, b) {
            return a + b;
        }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;burpsuite的repeater中的request内容如下(其中mobilePhone在正常通信时被加密):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /xxx.do HTTP/1.1
Host: 127.0.0.1:8888
Real-Host: xxx.xxx.xxx
Connection: close
Accept: */*
User-Agent: PALxxx/4.11.0 (iPhone; iOS 9.0; Scale/2.00)
Accept-Language: zh-Hans-CN;q=1
X-Tingyun-Id: s8-utloiNb8;c=2;r=736688779
Content-Type: application/x-www-form-urlencoded
Content-Length: 993

mobilePhone=17634526787&amp;amp;id=1&amp;amp;b=2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行xenc.py后设置要加密的参数为mobilePhone,且它的加密函数为&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;函数(在上面的js中有两个加密函数&lt;code class=&quot;highlighter-rouge&quot;&gt;encrypt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;),运行完python3 xenc.py后从burpsuite的repeater中发上面的包并右键通过burpsuite测试有没有漏洞,或者将上面的request内容提供给sqlmap等工具进行测试&lt;/p&gt;

</description>
        <pubDate>Fri, 29 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/29/frida%E7%94%A8%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/29/frida%E7%94%A8%E6%B3%95/</guid>
        
        <category>frida</category>
        
        <category>inject</category>
        
        <category>js</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>ida插件使用备忘录</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;记录ida插件使用&lt;/p&gt;

&lt;h3 id=&quot;items&quot;&gt;Items&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/deresz/funcap&quot;&gt;funcap&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;funcap是一个分析函数参数和函数返回值的插件&lt;/li&gt;
      &lt;li&gt;支持的cpu架构:x86,amd64,arm(32)&lt;/li&gt;
      &lt;li&gt;不支持64位的arm(现在的ios设备几乎都是arm64,ios设备cpu类型在&lt;a href=&quot;http://blakespot.com/ios_device_specifications_grid.html&quot;&gt;这里&lt;/a&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/fjh658/article/details/52268907&quot;&gt;keypatch&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;支持arm处理器的assemble patch(ida默认不支持),一般用于手机app的patch&lt;/li&gt;
      &lt;li&gt;使用方法在&lt;a href=&quot;http://blog.csdn.net/fjh658/article/details/52268907&quot;&gt;这里&lt;/a&gt;,也即如下&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  brew install cmake
  pip install keystone-engine
  git clone https://github.com/keystone-engine/keypatch.git
  cp -r /usr/local/lib/python2.7/site-packages/keystone /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/python/
  cp keypatch/keypatch.py /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/plugins/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/3xp10it/mynav&quot;&gt;mynav&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;类似binnavi的函数追踪功能,可快速找到一个操作对应的函数,功能详情在&lt;a href=&quot;http://joxeankoret.com/blog/2010/05/02/mynav-a-python-plugin-for-ida-pro/&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;使用方法是在ida分析完成后直接在ida中&lt;code class=&quot;highlighter-rouge&quot;&gt;File|Script File&lt;/code&gt;,选择&lt;code class=&quot;highlighter-rouge&quot;&gt;mynav.py&lt;/code&gt;,然后可在&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit|Plugins|MyNav&lt;/code&gt;中得到需要功能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 27 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/27/ida%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/27/ida%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>ida</category>
        
        <category>plugin</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>lldb命令</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lldb.llvm.org/lldb-gdb.html&quot;&gt;lldb与gdb对照&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/29687504/lldb-breakpoint-on-all-methods-in-class-objective-c&quot;&gt;lldb在object-c类对象所有函数上设置断点&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;breakpoint set -r '\[ClassName .*\]$'&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lldb在object-c类对象具体函数上设置断点(未验证) &lt;code class=&quot;highlighter-rouge&quot;&gt;breakpoint set [ClassName functionName]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/alanzeino/82713016fd6229ea43a8&quot;&gt;lldb常用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;breakpoint set --name &amp;lt;method-name&amp;gt;
    &quot;sets a breakpoint on a given function name, globally. e.g., 
    breakpoint set --name viewDidLoad 
    or 
    breakpoint set --name &quot;-[UIView setFrame:]&quot;
breakpoint set --selector &amp;lt;selector-name&amp;gt;
    &quot;sets a breakpoint on a selector, globally. e.g., 
    breakpoint set --selector dealloc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 25 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/lldb%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/25/lldb%E5%91%BD%E4%BB%A4/</guid>
        
        <category>lldb</category>
        
        <category>ios</category>
        
        <category>debug</category>
        
        
        <category>二进制</category>
        
      </item>
    
  </channel>
</rss>
