<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://3xp10it.cc/</link>
    <atom:link href="http://3xp10it.cc/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 12 Oct 2019 08:42:58 +0800</pubDate>
    <lastBuildDate>Sat, 12 Oct 2019 08:42:58 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>macOS中英文输入法自动切换方案</title>
        <description>&lt;h3 id=&quot;0x1-vim中英文自动切换&quot;&gt;0x1 vim中英文自动切换&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;vim使用&lt;a href=&quot;https://github.com/CodeFalling/fcitx-vim-osx&quot;&gt;fcitx-vim-osx&lt;/a&gt;插件,添加&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+shift+z&lt;/code&gt;为切换英文&lt;/td&gt;
      &lt;td&gt;百度五笔输入法快捷键&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/mRzx6z.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x2-系统输入法设置&quot;&gt;0x2 系统输入法设置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用百度五笔输入法并设置百度五笔输入法中只能使用中文输入,在将百度五笔切换成中文输入后如下设置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/gS9K8I.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;keyboard maestro设置英文&lt;/td&gt;
          &lt;td&gt;百度五笔输入法的切换快捷键为&lt;code class=&quot;highlighter-rouge&quot;&gt;command_left&lt;/code&gt;,如下:&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/z76Tjb.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 12 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2019/10/12/macOS%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://3xp10it.cc/auxilary/2019/10/12/macOS%E4%B8%AD%E8%8B%B1%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E6%96%B9%E6%A1%88/</guid>
        
        <category>输入法</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>诱多</title>
        <description>&lt;h3 id=&quot;0x1-诱多的目的&quot;&gt;0x1 诱多的目的&lt;/h3&gt;

&lt;p&gt;主力一般通过诱多与诱空来达到操控股价的目的,如通过诱多来出货,通过诱空来吃货.&lt;code class=&quot;highlighter-rouge&quot;&gt;诱空的目的是:吃货或洗盘&lt;/code&gt;,是好事,证明主力将要做多股票;而&lt;code class=&quot;highlighter-rouge&quot;&gt;诱多的目的有:护盘/活跃股性/减轻拉升压力/出货&lt;/code&gt;,以出货为目的的诱多是坏事,而以护盘/活跃股性/减轻拉升压力为目的的诱多不是坏事.诱多有可能出现在拉升的不同阶段:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拉升前期的诱多是为了提高股票活跃度便于后续出货&lt;/li&gt;
  &lt;li&gt;拉升中期的诱多是为了减轻拉升压力,这时主力和散户一起推升股价&lt;/li&gt;
  &lt;li&gt;拉升后期的诱多是为了出货,主力拉升后马上出货&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x2-诱多的方法&quot;&gt;0x2 诱多的方法&lt;/h3&gt;

&lt;p&gt;诱多的方法有2种:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;向上对倒&lt;/li&gt;
  &lt;li&gt;托单推升股价&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x3-诱多实例&quot;&gt;0x3 诱多实例&lt;/h3&gt;

&lt;h3 id=&quot;0x4-小结&quot;&gt;0x4 小结&lt;/h3&gt;
</description>
        <pubDate>Thu, 10 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/10/10/%E8%AF%B1%E5%A4%9A/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/10/10/%E8%AF%B1%E5%A4%9A/</guid>
        
        <category>对倒</category>
        
        <category>主力</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>怎样找出对倒</title>
        <description>&lt;h3 id=&quot;0x1-对倒的因果&quot;&gt;0x1 对倒的因果&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;所有对倒的&quot;因&quot;都是某价位大挂单的出现,大挂单可以是一笔挂上去的大挂单,也可以是多笔小单累积成的大挂单;
所有对倒的&quot;果&quot;都是该价位大挂单被成交,大挂单被成交可以是被一笔大单成交掉,也可以是被多笔小单分批成交掉;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对倒的本质是&lt;code class=&quot;highlighter-rouge&quot;&gt;果&lt;/code&gt;,也即某价位大挂单被成交,在对倒的”果”出现之前必然会先出现”因”,也即某价位大挂单的出现.如果只有”因”而没有”果”则是对应着&lt;code class=&quot;highlighter-rouge&quot;&gt;压单/托单/夹单&lt;/code&gt;,压单/托单/夹单得到成交就变成了对倒.&lt;code class=&quot;highlighter-rouge&quot;&gt;空中成交&lt;/code&gt;形式的对倒算是一种特殊的”出现大挂单和大挂单被成交”,只是速度快到交易软件来不及在委托栏显示.另外还有一种特殊的大挂单不容易被发现,也即在买卖十档以上的委托位置出现的大挂单,例如在卖二十位置突然出现一手价值100W的大挂单,这种情况人眼无法看到,可以通过同花顺&lt;code class=&quot;highlighter-rouge&quot;&gt;超级盘口&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;总买量&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;总卖量&lt;/code&gt;数值的突变来感知,或通过稍后的大单成交来发现(如果是有效的对倒,那么卖二十处的大单后面肯定会被成交).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注:大挂单的出现和大挂单被成交是对倒的必要不充分条件,也即非庄家大户的动作也可能产生这两个现象,如果一个疑似对倒的现象不具备庄家对倒的意义,则应判断为该现象是非庄家大户的正常买入或卖出行为.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ddyg.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x2-找出对倒&quot;&gt;0x2 找出对倒&lt;/h3&gt;

&lt;p&gt;可根据对倒的”因”和”果”的特点来找出对倒.&lt;/p&gt;

&lt;h4 id=&quot;0xa-找因&quot;&gt;0xa 找”因”&lt;/h4&gt;

&lt;p&gt;“因”可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;开盘啦&lt;/code&gt;的压单托单夹单辅助找出.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/kpltyjd.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于开盘啦的压单/托单/夹单是固定的指标,要求在一定的金额以上的挂单才会被识别,导致可能会漏掉一些真实的压单/托单/夹单.这种被漏掉的可通过同花顺分时图的委买委卖相关的”买卖力道”指标找出,通过它找出委买和委卖突然大幅增加/减少的点(突然增加很有可能是为对倒做准备,突然减少则有可能是刚发生完对倒),再通过超级盘口进行分析.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/mmld.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于分时图是1分钟级别的图,而对倒有可能只出现在1s内,所以分时图中的”买卖力道”指标会漏掉1分钟内部的对倒对应的大挂单.&lt;/p&gt;

&lt;h4 id=&quot;0xb-找果&quot;&gt;0xb 找”果”&lt;/h4&gt;

&lt;p&gt;超级盘口中短时间异常的放量可辅助找出对倒的果,包含2种情况:一是超级盘口中单根大量,二是超级盘口中短时间范围内的密集小量,如下图所示,这2种都情况都需分析.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/yccjl.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外,异常的分时图如&lt;code class=&quot;highlighter-rouge&quot;&gt;一字过马路&lt;/code&gt;(价格基本不变而成交量却较活跃)和&lt;code class=&quot;highlighter-rouge&quot;&gt;锯齿心电图&lt;/code&gt;(疑似在不断地进行对倒+出货[要求超级盘口看到较多”小草”])等也可用于辅助发现对倒.&lt;/p&gt;

&lt;h4 id=&quot;0xc-小结&quot;&gt;0xc 小结&lt;/h4&gt;

&lt;p&gt;小结分析盘口对倒的步骤如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.开盘啦压单/托单/夹单情况分析
2.分时图买卖力道指标委买/委卖突变分析
3.超级盘口短时间异常放量情况分析
4.异常分时图情况分析
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 22 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/22/%E6%80%8E%E6%A0%B7%E6%89%BE%E5%87%BA%E5%AF%B9%E5%80%92/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/22/%E6%80%8E%E6%A0%B7%E6%89%BE%E5%87%BA%E5%AF%B9%E5%80%92/</guid>
        
        <category>对倒</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>主力出货迹象汇编</title>
        <description>&lt;h4 id=&quot;0x1-牛短熊长&quot;&gt;0x1 牛短熊长&lt;/h4&gt;

&lt;p&gt;日k线牛短熊长,涨少跌多,主力利用更长的(跌)时间来进行出货,利用较小的代价来维持股价&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/rkndxc.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分时图牛短熊长,分时图中短时间对倒拉升(或吃货),利用更长的时间进行出货&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/fsndxc.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面的例子中603218当天拉阳线,且大单统计显示大单流入,而实际主力在出货:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ddlrch1.png&quot; data-action=&quot;zoom&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ddlrch2.png&quot; data-action=&quot;zoom&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ddlrch3.png&quot; data-action=&quot;zoom&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ddlrch4.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x2-逆势下跌&quot;&gt;0x2 逆势下跌&lt;/h4&gt;

&lt;p&gt;大盘涨时个股跌&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/nsxd.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x3-早盘冲高尾盘回落&quot;&gt;0x3 早盘冲高尾盘回落&lt;/h4&gt;

&lt;p&gt;早盘冲高后一天剩下大部分时间用来慢慢出货,如果到了尾盘才出货则当天出不了多少货&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/cghl.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x4-拉午盘拉尾盘&quot;&gt;0x4 拉午盘拉尾盘&lt;/h4&gt;

&lt;p&gt;拉尾盘一般对应第二天冲高回落出货,或低位没实力的拉升&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/lwp.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/klwp.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x5-夹单一字过马路出货&quot;&gt;0x5 夹单一字过马路出货&lt;/h4&gt;

&lt;p&gt;夹单并通过小单不断啃食压单,目的是诱多出货.如果是夹单并通过小单不断打到托单上那就是诱空吃货.&lt;/p&gt;

&lt;video width=&quot;100%&quot; height=&quot;100%&quot; controls=&quot;controls&quot; src=&quot;https://github.com/3xp10it/pic/raw/master/%E5%A4%B9%E5%8D%95%E5%87%BA%E8%B4%A7.mp4&quot;&gt;&lt;/video&gt;

&lt;h4 id=&quot;0x6-跌停板出货&quot;&gt;0x6 跌停板出货&lt;/h4&gt;

&lt;p&gt;主力在跌停板出货,出货特征是跌停时委卖队列中的的大单一直被成交,说明主力是有效的卖出,且结合委卖队列和卖一的总卖量看大单没有明显撤单行为.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dtbch.mp4&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x7-涨停板出货&quot;&gt;0x7 涨停板出货&lt;/h4&gt;

&lt;p&gt;主力封板时不在买一封,而是在买一之后(如买二/买三)价位处挂大托单,目的是吸引散户在买一处封板,然后大单砸给散户,砸盘时只会砸到买一(散户的挂单),因为如果把主力自己的挂单也砸掉了则容易引起恐慌,而留下主力自己的大托单则会吸引散户往买一价位挂单.一般情况下,如果散户不在买一挂单则主力会带头在买一挂大单,吸引散户在买一挂单后主力会撤单.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/ztbch.gif&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x8-锯齿形出货&quot;&gt;0x8 锯齿形出货&lt;/h4&gt;

&lt;p&gt;不断”对倒+出货”,在维护股价的基础上一直出货.注:锯齿形态需要对应有成交量,如果有锯齿但基本没有成交量则是由于成交不活跃导致的,这种不能简单判断为在出货.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/jcch.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x9-拆单小草出货&quot;&gt;0x9 拆单小草出货&lt;/h4&gt;

&lt;h4 id=&quot;0x10-分时图拉升规律突变&quot;&gt;0x10 分时图拉升规律突变&lt;/h4&gt;

&lt;p&gt;拉升规律突然变化,意味着主力不想再拉了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/lstb.jpg&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x11-无穷成本均线下横盘&quot;&gt;0x11 无穷成本均线下横盘&lt;/h4&gt;

&lt;p&gt;股价处于高位时个股在无穷成本均线下方横盘,或围绕着无穷成本均线振荡且横盘期间多数时间处于无穷成本均线下方,是主力出货迹象&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/xxhp.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;0x12-下跌放量上涨缩量&quot;&gt;0x12 下跌放量上涨缩量&lt;/h4&gt;

&lt;p&gt;日k线下跌放量上涨缩量&lt;/p&gt;

&lt;p&gt;分时图下跌放量上涨缩量&lt;/p&gt;

&lt;h4 id=&quot;0x13-大单拉升小单出货&quot;&gt;0x13 大单拉升小单出货&lt;/h4&gt;
</description>
        <pubDate>Thu, 19 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/19/%E4%B8%BB%E5%8A%9B%E5%87%BA%E8%B4%A7%E8%BF%B9%E8%B1%A1%E6%B1%87%E7%BC%96/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/19/%E4%B8%BB%E5%8A%9B%E5%87%BA%E8%B4%A7%E8%BF%B9%E8%B1%A1%E6%B1%87%E7%BC%96/</guid>
        
        <category>出货</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>主力怎样在保持收盘大阳线的情况下出货</title>
        <description>&lt;h3 id=&quot;0x1-about&quot;&gt;0x1 About&lt;/h3&gt;

&lt;p&gt;对狂龙十八段一篇«怎样识别拉升出货法»的思考&lt;/p&gt;

&lt;h3 id=&quot;0x2-拉升出货实例&quot;&gt;0x2 拉升出货实例&lt;/h3&gt;

&lt;embed src=&quot;https://drive.google.com/viewerng/viewer?embedded=true&amp;amp;url=https://raw.githubusercontent.com/3xp10it/pic/master/怎样识别拉升出货法.pdf&quot; width=&quot;100%&quot; height=&quot;1100&quot; /&gt;

&lt;blockquote&gt;
  &lt;p&gt;“上涨未明显放量,上涨最快速的阶段,也基本上,全由小单拉升构成”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从中可以看出当时主力拉升的成本很低,而要通过小单就可以成功拉升,背后需要对应着较小的抛压,较小的抛压意味着个股有利好或大盘情况良好,如下示例,000876在无穷成本均线上方横盘,且有逆势对抗(大盘下跌而个股上涨 ),博弈k线无量长阳的表现,初看主力应该没出货且依旧保持高控盘状态:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/3xp10it/pic/raw/master/xxw.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新希望这波主升浪维持到现在,期间对应的板块利好是猪瘟行情,查看这期间股东人数变化,如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/xxwgdrs.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从股东人数上看主力是在出货的,且没有换庄,因为如果换庄,股东人数应该对应着变化不大而不会导致股东人数上升(老庄到新庄股东人数大概不变),说明该股是利用利好出货,且出货相当具备迷惑性(因为利好足够大,散户疯抢接盘人数多),这样的出货是很成功的出货.&lt;/p&gt;

&lt;p&gt;于是得出以下结论:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ 主力最好的出货方式是边拉升边出货,利用拉升缩量下跌放量达到拉升出货的目的
+ 主力最好的出货时机是个股有利好或大盘情况良好
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x3-主力操盘推演&quot;&gt;0x3 主力操盘推演&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/dapanjieduan.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大盘不好的时候(上图E,F段)主力一般都会被套,如果主力不在大盘良好的情况下就开始拉升,而是等到大盘到了E/F段才开始拉升,这种主力太傻了,不值得跟随.主力最佳的操盘策略应该是:C段之前完成吸货,B段末判断大盘要开始转成上升走势,于是C段开始拉升,D段开始出货(或E段借利好也能出货).&lt;/p&gt;

&lt;p&gt;到了D/E段还因洗盘而没有开始拉升的主力是笨庄,因为&lt;code class=&quot;highlighter-rouge&quot;&gt;1.A股是牛短熊长&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;2.现在市场逐渐由单庄变成混庄&lt;/code&gt;,主力对个股走势操纵的话语权在逐渐下降,主力越来越需要看大盘吃饭了,大盘的好时机难得,不在难得的时机下拉升,而一再拖延到大盘开始走坏才想拉升,这时候已经不是主力想拉就能拉的动了,大量聪明的主力在这时(D/E段)已经在出货而导致大盘加快走坏,散户也在恐慌性抛盘,笨庄只能”满仓”被套,跟了这样的庄是很难盈利的.&lt;/p&gt;

&lt;p&gt;想赚钱必须充分利用大盘环境良好的时间(B/C段),如果个股在大盘处于B/C/D段还没有表现必须放弃,大盘好而个股不拉的庄股要放弃,得出以下结论:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ 选股的最佳时机是大盘处于B段的时候
+ 选股的最佳标的是大盘走好时个股一定会启动拉升的个股,例如处于缠论买3的庄股
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Wed, 18 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/18/%E4%B8%BB%E5%8A%9B%E6%80%8E%E6%A0%B7%E5%9C%A8%E4%BF%9D%E6%8C%81%E6%94%B6%E7%9B%98%E5%A4%A7%E9%98%B3%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%87%BA%E8%B4%A7/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/09/18/%E4%B8%BB%E5%8A%9B%E6%80%8E%E6%A0%B7%E5%9C%A8%E4%BF%9D%E6%8C%81%E6%94%B6%E7%9B%98%E5%A4%A7%E9%98%B3%E7%BA%BF%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%87%BA%E8%B4%A7/</guid>
        
        <category>出货</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>看盘细节笔记</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/看盘细节.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/17/%E7%9C%8B%E7%9B%98%E7%BB%86%E8%8A%82%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/17/%E7%9C%8B%E7%9B%98%E7%BB%86%E8%8A%82%E7%AC%94%E8%AE%B0/</guid>
        
        <category>细节</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>盘面细节分析笔记</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/盘面细节分析.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/15/%E7%9B%98%E9%9D%A2%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/15/%E7%9B%98%E9%9D%A2%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0/</guid>
        
        <category>盘口</category>
        
        <category>细节</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>主力行为盘口解密1,2,3,4,5,6笔记</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://to_add&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1-3电子版在&lt;a href=&quot;https://pan.baidu.com/s/1j7kqp8SleY6DFxW1AfEfNQ&quot;&gt;这里&lt;/a&gt;,密码&lt;code class=&quot;highlighter-rouge&quot;&gt;b4p9&lt;/code&gt;,4-6册需要购买实体书&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/15/%E4%B8%BB%E5%8A%9B%E8%A1%8C%E4%B8%BA%E7%9B%98%E5%8F%A3%E8%A7%A3%E5%AF%861,2,3,4,5,6%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/15/%E4%B8%BB%E5%8A%9B%E8%A1%8C%E4%B8%BA%E7%9B%98%E5%8F%A3%E8%A7%A3%E5%AF%861,2,3,4,5,6%E7%AC%94%E8%AE%B0/</guid>
        
        <category>盘口</category>
        
        
        <category>炒股</category>
        
      </item>
    
      <item>
        <title>frida开启ios app签名服务</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;一般情况下,app因为安全性会有签名机制,大多数服务器上重要的接口都需要签名算法验证通过后才可访问,一般情况下,服务器上的验证算法是通过校验客户端请求时间戳达到防重放的目的(签名机制也可用于提升攻击难度),校验算法示例可参考&lt;a href=&quot;https://blog.csdn.net/koastal/article/details/53456696&quot;&gt;这里&lt;/a&gt;,简单的校验伪代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;客户端请求如下:

POST /jiekou HTTP/1.1
Host: www.baidu.com
content: text/html; charset=UTF-8
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Accept-Encoding: gzip, deflate
Accept: */*
User-Agent: xxx/5.4.7 (iPhone; iOS 11.1.1; Scale/2.00)
Accept-Language: zh-Hans-CN;q=1
Content-Length: 376
Connection: close

a=1&amp;amp;b=2&amp;amp;reqTime=20190813160148620&amp;amp;sign_value=Q980XOWEJ7658799ZX90876876O

其中reqTime是客户端请求携带的请求时间戳,sign_value是客户端签名算法的签名结果


服务端校验如下:

if request_value.reqTime+60s &amp;lt; serverTime:
    deny
if get_sign_value(request_value)!=request_value.sign_value:
    deny
normal_response()

其中request_value是客户端提交的请求包数据,request_value.reqTime是请求包中的reqTime参数的值,serverTime是服务器接收到请求的时间戳,request_value.sign_value是请求包中的sign_value参数的值
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本文记录通过frida开启ios app客户端的签名算法的rpc调用服务&lt;/p&gt;

&lt;h3 id=&quot;0x1-分析签名函数&quot;&gt;0x1 分析签名函数&lt;/h3&gt;

&lt;p&gt;ios app通过Cluth脱壳后通过ida反编译,正常测试时抓包发现大多请求都带有&lt;code class=&quot;highlighter-rouge&quot;&gt;openapi_sign=xxxxxxxxxxxxx&lt;/code&gt;,推断app的签名结果会赋值到openapi_sign参数中,在ida中搜索openapi_sign,结果如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/goldsun1.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在汇编区中按f5得到object-c风格的代码,显示是&lt;code class=&quot;highlighter-rouge&quot;&gt;signRequestUrlWithParameters:secret:signMethod:&lt;/code&gt;函数实现的签名,在ida的函数窗口区搜索这个函数,如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/goldsun2.png&quot; data-action=&quot;zoom&quot; /&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/goldsun3.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;signRequestUrlWithParameters:secret:signMethod:&lt;/code&gt;代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id __cdecl +[GSNetworkUtils signRequestUrlWithParameters:secret:signMethod:](GSNetworkUtils_meta *self, SEL a2, id a3, id a4, id a5)
{
  id v5; // x20
  id v6; // x21
  void *v7; // x19
  __int64 v8; // x1
  void *v9; // x22
  __int64 v10; // x1
  __int64 v11; // x1
  void *v12; // x26
  void *v13; // x21
  void *v14; // x24
  void *v15; // x21
  __int64 v16; // x20
  void *v17; // x0
  __int64 v18; // x21
  int v19; // w25
  __int64 v20; // x1
  void *v21; // x27
  __int64 v22; // x24
  unsigned __int64 v23; // x22
  void *v24; // x26
  __int64 v25; // x19
  void *v26; // x25
  void *v27; // x19
  const __CFString *v28; // x20
  id result; // x0
  void *v30; // [xsp+10h] [xbp-150h]
  void *v31; // [xsp+18h] [xbp-148h]
  struct objc_object *v32; // [xsp+28h] [xbp-138h]
  void *v33; // [xsp+30h] [xbp-130h]
  GSNetworkUtils_meta *v34; // [xsp+38h] [xbp-128h]
  void *v35; // [xsp+40h] [xbp-120h]
  __int128 v36; // [xsp+48h] [xbp-118h]
  __int128 v37; // [xsp+58h] [xbp-108h]
  __int128 v38; // [xsp+68h] [xbp-F8h]
  __int128 v39; // [xsp+78h] [xbp-E8h]
  char v40; // [xsp+88h] [xbp-D8h]
  __int64 v41; // [xsp+108h] [xbp-58h]

  v5 = a5;
  v6 = a4;
  v34 = self;
  v7 = (void *)objc_retain(a3, a2);
  v9 = (void *)objc_retain(v6, v8);
  v12 = (void *)objc_retain(v5, v10);
  v35 = v7;
  if ( !v7 )
    goto LABEL_19;
  objc_msgSend(v7, &quot;allKeys&quot;);
  v13 = (void *)objc_retainAutoreleasedReturnValue();
  if ( !objc_msgSend(v13, &quot;count&quot;) )
  {
    objc_release(v13);
    goto LABEL_19;
  }
  v14 = objc_msgSend(v9, &quot;length&quot;);
  objc_release(v13);
  if ( !v14 )
  {
LABEL_19:
    v28 = &amp;amp;stru_1020C2DD0;
    objc_retain(&amp;amp;stru_1020C2DD0, v11);
    goto LABEL_20;
  }
  objc_msgSend(v7, &quot;allKeys&quot;);
  v15 = (void *)objc_retainAutoreleasedReturnValue();
  objc_msgSend(v15, &quot;sortedArrayUsingSelector:&quot;, &quot;compare:&quot;);
  v16 = objc_retainAutoreleasedReturnValue();
  objc_release(v15);
  v17 = objc_msgSend(&amp;amp;OBJC_CLASS___NSMutableString, &quot;alloc&quot;);
  v32 = (struct objc_object *)objc_msgSend(v17, &quot;init&quot;);
  if ( !objc_msgSend(v12, &quot;length&quot;)
    || (objc_msgSend(v12, &quot;lowercaseString&quot;),
        v18 = objc_retainAutoreleasedReturnValue(),
        v19 = (unsigned __int64)objc_msgSend(CFSTR(&quot;md5&quot;), &quot;isEqualToString:&quot;, v18),
        objc_release(v18),
        v19) )
  {
    objc_msgSend(v32, &quot;appendString:&quot;, v9);
  }
  v30 = v12;
  v31 = v9;
  v39 = 0u;
  v38 = 0u;
  v37 = 0u;
  v36 = 0u;
  v33 = (void *)objc_retain(v16, v20);
  v21 = objc_msgSend(v33, &quot;countByEnumeratingWithState:objects:count:&quot;, &amp;amp;v36, &amp;amp;v40, 16LL);
  if ( v21 )
  {
    v22 = *(_QWORD *)v37;
    do
    {
      v23 = 0LL;
      do
      {
        if ( *(_QWORD *)v37 != v22 )
          objc_enumerationMutation(v33);
        v24 = *(void **)(*((_QWORD *)&amp;amp;v36 + 1) + 8 * v23);
        objc_msgSend(v35, &quot;objectForKey:&quot;, *(_QWORD *)(*((_QWORD *)&amp;amp;v36 + 1) + 8 * v23));
        v25 = objc_retainAutoreleasedReturnValue();
        objc_msgSend(v34, &quot;urlDecodedString:&quot;, v25);
        v26 = (void *)objc_retainAutoreleasedReturnValue();
        objc_release(v25);
        if ( objc_msgSend(v24, &quot;length&quot;) &amp;amp;&amp;amp; objc_msgSend(v26, &quot;length&quot;) )
        {
          objc_msgSend(v32, &quot;appendString:&quot;, v24);
          objc_msgSend(v32, &quot;appendString:&quot;, v26);
        }
        objc_release(v26);
        ++v23;
      }
      while ( v23 &amp;lt; (unsigned __int64)v21 );
      v21 = objc_msgSend(v33, &quot;countByEnumeratingWithState:objects:count:&quot;, &amp;amp;v36, &amp;amp;v40, 16LL);
    }
    while ( v21 );
  }
  objc_release(v33);
  v9 = v31;
  objc_msgSend(v32, &quot;appendString:&quot;, v31);
  ((void (__cdecl *)(GSNetworkUtils_meta *, SEL, id))objc_msgSend)(
    (GSNetworkUtils_meta *)&amp;amp;OBJC_CLASS___GSNetworkUtils,
    &quot;md5:&quot;,
    v32);
  v27 = (void *)objc_retainAutoreleasedReturnValue();
  objc_msgSend(v27, &quot;uppercaseString&quot;);
  v28 = (const __CFString *)objc_retainAutoreleasedReturnValue();
  objc_release(v27);
  objc_release(v32);
  objc_release(v33);
  v12 = v30;
LABEL_20:
  objc_release(v12);
  objc_release(v9);
  result = (id)objc_release(v35);
  if ( __stack_chk_guard == v41 )
    result = (id)objc_autoreleaseReturnValue(v28);
  return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;暂不确定这个函数的参数是怎么用的,从上面objec-c代码中可以看出这个函数总共有3个参数,最后一个参数是字符串”md5”,前两个参数还不确定分别是什么,于是通过frida hook这个函数的调用,注入代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;GSNetworkUtils&quot;;
        var funcName = &quot;+ signRequestUrlWithParameters:secret:signMethod:&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]);
			console.log(&quot;param:&quot;+ObjC.classes.NSString.stringWithString_(args[3])+&quot; type:&quot;+typeof args[3]);
			console.log(&quot;param:&quot;+ObjC.classes.NSString.stringWithString_(args[4])+&quot; type:&quot;+typeof args[4]);
          },
          onLeave: function(retval) {
            console.log(&quot;Return value-&amp;gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;结果如下:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[*] Class Name: GSNetworkUtils
[*] Method Name: + signRequestUrlWithParameters:secret:signMethod:
param:0x1c462af00 type:object
param:96UI5F7H9W9N46FFA7196D109C2768UI type:object
param:md5 type:object
Return value-&amp;gt; (type:object,value:0x1c0845970)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过frida hook这个函数的调用和上面的object-c代码分析得出这个函数的第1个参数应该是与请求包参数相关的变量,猜测是字典形式,第2个参数应该是加密算法里的一个固定密钥值,尝试以字典形式打印第1个参数,注入代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (ObjC.available)
{
    try
    {
        var className = &quot;GSNetworkUtils&quot;;
        var funcName = &quot;+ signRequestUrlWithParameters:secret:signMethod:&quot;;
        var hook = eval('ObjC.classes.' + className + '[&quot;' + funcName + '&quot;]');
        console.log(&quot;[*] Class Name: &quot; + className);
        console.log(&quot;[*] Method Name: &quot; + funcName);
        Interceptor.attach(hook.implementation, {
          onEnter: function(args) {
            //console.log(&quot;param:&quot;+args[2]+&quot; type:&quot;+typeof args[2]);
			var arg2 = new ObjC.Object(args[2]);
			console.log(arg2.allKeys());
			console.log(arg2.allValues());
			console.log(&quot;param:&quot;+ObjC.classes.NSString.stringWithString_(args[3])+&quot; type:&quot;+typeof args[3]);
			console.log(&quot;param:&quot;+ObjC.classes.NSString.stringWithString_(args[4])+&quot; type:&quot;+typeof args[4]);
          },
          onLeave: function(retval) {
            console.log(&quot;Return value-&amp;gt; (type:&quot;+typeof retval+&quot;,value:&quot;+retval+&quot;)&quot;);
          }
        });
    }
    catch(err)
    {
        console.log(&quot;[!] Exception2: &quot; + err.message);
    }
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
    &quot;conn_style&quot;,
    imsi,
    &quot;device_model&quot;
)
(
    &quot;1.460.01..&quot;,
    46001,
    &quot;iPhone7,2&quot;
)
param:96UI5F7H9W9N46FFA7196D109C2768UI type:object
param:md5 type:object
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明第1个参数&lt;code class=&quot;highlighter-rouge&quot;&gt;args[2]&lt;/code&gt;的确是字典的形式,且字典的内容就是http请求包里的参数值(frida js里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;args[0]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;args[1]&lt;/code&gt;分别对应object-c代码里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;GSNetworkUtils_meta *self, SEL a2&lt;/code&gt;,它们不是这个函数的调用参数,相当于self指针),也即这个函数的三个参数分别是:请求包参数构成的字典,签名算法密钥,字符串”md5”.&lt;/p&gt;

&lt;h3 id=&quot;0x2-开启rpc签名服务&quot;&gt;0x2 开启rpc签名服务&lt;/h3&gt;

&lt;p&gt;经过上面对这个函数的分析,可通过frida js构造rpc函数提供签名算法服务给python调用,代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import frida
import sys
import urllib.parse
import re
import pdb

session = frida.get_usb_device().attach(&quot;应用名&quot;)
script_string = &quot;&quot;&quot;
if (ObjC.available)
{
    rpc.exports = {
        signrequesturlwithparameters: function (param_string,secret,signMethod) {			
/*
		尝试python中的dict类型传入js代码的rpc函数中(string-&amp;gt;dict),没成功
		var param_dict_nsstring=ObjC.classes.NSString.stringWithString_(param_dict)
		var jsonData=param_dict_nsstring.dataUsingEncoding_(4)
		var err=ptr(ObjC.classes.NSError.alloc())
		//下面这个函数最终没调用成功
		var dic=ObjC.classes.NSJSONSerialization.JSONObjectWithData_options_error_(jsonData,0,err)
		console.log(dic)
		console.log(err.localizedDescription())
*/
		
		//console.log(param_string)
		var param_dict = ObjC.classes.NSMutableDictionary.alloc().init(); 
		var param_list=param_string.split(&quot;&amp;amp;&quot;)
		for (var i = 0; i &amp;lt; param_list.length; i++) { 
			var param=param_list[i].split(&quot;=&quot;)[0]
			var param_value=param_list[i].substr(param.length+1,param_list[i].length)
			if (param!=&quot;openapi_sign&quot;) {
				param_dict.setObject_forKey_(param_value,param);
				} 				
		}
		var result=ObjC.classes.GSNetworkUtils.signRequestUrlWithParameters_secret_signMethod_(param_dict,secret,signMethod);
		return String(ObjC.classes.NSString.stringWithString_(result));
        }
    };

	
}
else
{
    console.log(&quot;Objective-C Runtime is not available!&quot;);
}
&quot;&quot;&quot;


script = session.create_script(script_string)


def on_message(message, data):
    if message['type'] == 'error':
        print(&quot;[!] &quot; + message['stack'])
    elif message['type'] == 'send':
        print(&quot;[!] &quot; + message['payload'])
    else:
        print(message)



script.on('message', on_message)
script.load()
signrequesturlwithparameters= getattr(script.exports, 'signrequesturlwithparameters')
secret=&quot;96UI5F7H9W9N46FFA7196D109C2768UI&quot;; 
signMethod=&quot;md5&quot;;


def start_transfer_server():
    from http.server import BaseHTTPRequestHandler, HTTPServer

    class S(BaseHTTPRequestHandler):
        def _set_headers(self):
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()

        def do_GET(self):
            try:
                param_string=re.search(r&quot;param_string=([\s\S]*)&quot;,self.path).group(1)
                param_string=urllib.parse.unquote(param_string)
                return_value=signrequesturlwithparameters(param_string,secret,signMethod)
                self._set_headers()
                self.wfile.write(bytes(return_value, &quot;utf-8&quot;))
            except:
                pass

    def run(server_class=HTTPServer, handler_class=S, port=8888):
        server_address = ('', port)
        httpd = server_class(server_address, handler_class)
        print('Starting httpd...')
        httpd.serve_forever()

    run()


start_transfer_server()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;session = frida.get_usb_device().attach(&quot;应用名&quot;)&lt;/code&gt;这里的应用名需要在连接手机的电脑上运行&lt;code class=&quot;highlighter-rouge&quot;&gt;frida-ps -U&lt;/code&gt;得到,在windows上运行时如果手机运行的进程名中有中文字符则会有个编码的bug,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[C:\~]$ frida-ps -U
 PID  Name
----  -----------------------------------------------
 446  InCallService
Exception in thread Thread-1:
Traceback (most recent call last):
  File &quot;c:\python37\lib\threading.py&quot;, line 917, in _bootstrap_inner
    self.run()
  File &quot;c:\python37\lib\threading.py&quot;, line 865, in run
    self._target(*self._args, **self._kwargs)
  File &quot;c:\python37\lib\site-packages\frida_tools\application.py&quot;, line 428, in _run
    work()
  File &quot;c:\python37\lib\site-packages\frida_tools\application.py&quot;, line 277, in _try_start
    self._start()
  File &quot;c:\python37\lib\site-packages\frida_tools\ps.py&quot;, line 69, in _start
    self._print(line_format % (process.pid, process.name))
  File &quot;c:\python37\lib\site-packages\frida_tools\application.py&quot;, line 343, in _print
    print(*encoded_args, **kwargs)
  File &quot;c:\python37\lib\site-packages\colorama\ansitowin32.py&quot;, line 41, in write
    self.__convertor.write(text)
  File &quot;c:\python37\lib\site-packages\colorama\ansitowin32.py&quot;, line 162, in write
    self.write_and_convert(text)
  File &quot;c:\python37\lib\site-packages\colorama\ansitowin32.py&quot;, line 190, in write_and_convert
    self.write_plain_text(text, cursor, len(text))
  File &quot;c:\python37\lib\site-packages\colorama\ansitowin32.py&quot;, line 195, in write_plain_text
    self.wrapped.write(text[start:end])
UnicodeEncodeError: 'gbk' codec can't encode character '\xd0' in position 6: illegal multibyte sequence
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据报错信息可以看出是由于ps.py的&lt;code class=&quot;highlighter-rouge&quot;&gt;self._print&lt;/code&gt;出了问题:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  File &quot;c:\python37\lib\site-packages\frida_tools\ps.py&quot;, line 69, in _start
    self._print(line_format % (process.pid, process.name))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将这行代码修改下可正常运行&lt;code class=&quot;highlighter-rouge&quot;&gt;frida-ps -U&lt;/code&gt;来得到进程名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#self._print(line_format % (process.pid, process.name))
print(line_format % (process.pid, process.name))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x3-后记&quot;&gt;0x3 后记&lt;/h3&gt;

&lt;p&gt;通过上面的分析,容易联想到ios app里的签名函数大多用的是同一个类的同一个函数(因为开发都习惯直接用市面上已有的代码),变量在于不同app在使用这个签名函数时会有不同的第2个参数和第3个参数,也即密钥值和加密算法(对应上面的96UI5F7H9W9N46FFA7196D109C2768UI和”md5”),分析其他ios app时估计可同样直接分析出密钥值(可通过hook内存)和第3个参数值(本例是”md5”,ida静态分析可得到),然后直接构造rpc函数就可以用了.此外,也可通过把这个签名函数封装成其他语言(如python,php)来得到更稳定的rpc服务,也即不用hook app即可提供rpc签名服务.&lt;/p&gt;

&lt;h3 id=&quot;0x4-参考&quot;&gt;0x4 参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/frida/frida-core/issues/7&quot;&gt;frida js打印字典内容&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/57458375/how-to-pass-a-dict-parameter-from-python-to-frida-rpc-javascript-function&quot;&gt;在rpc调用时怎样将python函数的字典传递到frida js的函数中&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 13 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2019/08/13/frida%E5%BC%80%E5%90%AFios-app%E7%AD%BE%E5%90%8D%E6%9C%8D%E5%8A%A1/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2019/08/13/frida%E5%BC%80%E5%90%AFios-app%E7%AD%BE%E5%90%8D%E6%9C%8D%E5%8A%A1/</guid>
        
        <category>frida</category>
        
        <category>ios</category>
        
        <category>rpc</category>
        
        <category>sign</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>盘口</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/盘口.png&quot; data-action=&quot;zoom&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.5xcg.com/&quot;&gt;宋磊盘口&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject_search?search_text=%E4%B8%BB%E5%8A%9B%E8%A1%8C%E4%B8%BA%E7%9B%98%E5%8F%A3%E8%A7%A3%E5%AF%86&amp;amp;cat=1001&quot;&gt;翁富主力行为盘口解密1-6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 09 Aug 2019 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/09/%E7%9B%98%E5%8F%A3/</link>
        <guid isPermaLink="true">http://3xp10it.cc/%E7%82%92%E8%82%A1/2019/08/09/%E7%9B%98%E5%8F%A3/</guid>
        
        <category>盘口</category>
        
        
        <category>炒股</category>
        
      </item>
    
  </channel>
</rss>
