<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 25 Dec 2017 07:59:03 +0800</pubDate>
    <lastBuildDate>Mon, 25 Dec 2017 07:59:03 +0800</lastBuildDate>
    <generator>Jekyll v3.5.2</generator>
    
      <item>
        <title>快速理解yield</title>
        <description>&lt;h3 id=&quot;0x0-必读link&quot;&gt;0x0 必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.deeplearn.me/231.html&quot;&gt;Python-yield理解篇&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://foofish.net/understanding-yield.html&quot;&gt;如何理解Python关键字yield&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x1-理解&quot;&gt;0x1 理解&lt;/h3&gt;

&lt;p&gt;理解下面2个脚本的运行结果&lt;/p&gt;

&lt;p&gt;脚本1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def a():
    print(111)

def b():
    flag='od'
    print(&quot;test&quot;)
    yield 1
    flag='ida'
    print(&quot;nihao&quot;)
    yield 2
    print(&quot;wohao&quot;)
    print(flag)

f1=a()
f2=b()

print(&quot;before for loop&quot;)

for i in f2:
    print(i,type(i))
    print(666)

print(&quot;after for loop&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;111
before for loop
test
1 &amp;lt;class 'int'&amp;gt;
666
nihao
2 &amp;lt;class 'int'&amp;gt;
666
wohao
ida
after for loop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;脚本2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def h():
    print('Wen Chuan')
    m = yield 5  # Fighting!
    print(999999999999)
    d = yield 12
    print('We are together!')

c = h()
tmp=next(c)  #相当于c.send(None)
print(11111111111)
print(tmp)
print(222)
tmp=c.send('Fighting!')  #(yield 5)表达式被赋予了'Fighting!'
print(3333)
print(tmp)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Wen Chuan
11111111111
5
222
999999999999
3333
12
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 21 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/12/21/%E7%90%86%E8%A7%A3yield/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/12/21/%E7%90%86%E8%A7%A3yield/</guid>
        
        <category>yield</category>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>实用shell命令</title>
        <description>&lt;h3 id=&quot;0x0-预备知识&quot;&gt;0x0 预备知识&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;之所以能用到xargs这个命令,是由于很多命令不支持&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;管道来传递参数&lt;/li&gt;
  &lt;li&gt;ack中:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-r&lt;/code&gt;代表在当前目录的子目录中递归查找&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;代表列出符合匹配内容的文件名&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-i&lt;/code&gt;代表在正则查找时忽略大小写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;for用法:
&lt;code class=&quot;highlighter-rouge&quot;&gt;for each in $(command1);do command2;done&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;find中:
    &lt;ul&gt;
      &lt;li&gt;正则查找文件名时查找的文件名是包含完整路径的,也即正则表达式要匹配完整路径&lt;/li&gt;
      &lt;li&gt;macOS下的正则查找文件名和普通linux下的正则查找文件名用法不同
        &lt;ul&gt;
          &lt;li&gt;macOS中正则查找文件名用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;find -E . -regex &quot;正则&quot;&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;普通linux中正则查找文件名用法为&lt;code class=&quot;highlighter-rouge&quot;&gt;find . -regextype posix-extended -regex &quot;正则&quot;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;find查找时不想显示Permission denied的信息可这样&lt;code class=&quot;highlighter-rouge&quot;&gt;find ... 2&amp;gt;&amp;amp;1 | grep -v &quot;Permission denied&quot;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;find正则查找文件名时忽略大小写用法为:将&lt;code class=&quot;highlighter-rouge&quot;&gt;-regex&lt;/code&gt;替换成&lt;code class=&quot;highlighter-rouge&quot;&gt;-iregex&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;中:
    &lt;ul&gt;
      &lt;li&gt;0,1,2分别代表标准输入,标准输出,标准错误&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;1&lt;/code&gt;的写法是为了区别&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;1&lt;/code&gt;这个重定向到文件名为1的文件,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;1&lt;/code&gt;表示重定向到标准输出&lt;/li&gt;
      &lt;li&gt;find命令查找文件名时会在终端中显示标准输出和标准错误的信息,也即&lt;code class=&quot;highlighter-rouge&quot;&gt;find ... == find ... 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;find命令遇到没有权限的文件会显示权限不足,显示权限不足的信息是标准错误&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;/dev/null&lt;/code&gt;的功能是将标准错误重定向到/dev/null&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;grep -v&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;表示查找不匹配的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x1-items&quot;&gt;0x1 Items&lt;/h3&gt;

&lt;p&gt;1.查找当前目录下包括子目录内所有的包含’def’字符串的python文件,并删除这些文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;find . -name &quot;*.py&quot; | xargx ack -ri 'def' | xargs rm
或者
for file in $(find . -name &quot;*.py&quot;);do ack -il 'def' $file &amp;amp;&amp;amp; rm $file;done
或者
for file in $(find . -name &quot;*.py&quot; | xargs ack -li 'def');do rm $file;done
或者
for file in $(find . -name &quot;*.py&quot;);do ack -il 'def' $file;doen | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.查找当前目录下包括子目录内所有的临时文件(.swp,.swm,.swn,.swo等,但不包括.swf),并删除这些文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;macOS下:

find -E . -regex &quot;.+\.sw[^f]$&quot; 2&amp;gt;/dev/null | xargs rm
或
find -E . -regex &quot;.+\.sw[^f]$&quot; | grep -v &quot;Permission denied&quot; | xargs rm
或
find -E . -regex &quot;.+\.sw[^f]$&quot; 2&amp;gt;&amp;amp;1 | grep -v &quot;Permission denied&quot; | xargs rm


普通linux下:
find . -regextype posix-extended -regex &quot;.+\.sw[^f]$&quot; | grep -v &quot;Permission denied&quot; | xargs rm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.to be continue…&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/linux/2017/12/21/%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2017/12/21/%E5%AE%9E%E7%94%A8shell%E5%91%BD%E4%BB%A4/</guid>
        
        <category>shell</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>ios的css调试</title>
        <description>&lt;h3 id=&quot;0x0-about&quot;&gt;0x0 About&lt;/h3&gt;

&lt;p&gt;css调试中,ios设备比较特殊(具备高清显示屏),物理像素和css像素值不相同,调试css时方法特殊&lt;/p&gt;

&lt;h3 id=&quot;0x1-必读link&quot;&gt;0x1 必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/35221839&quot;&gt;现在手机分辨率这么大,如何写响应式布局&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stephen.io/mediaqueries/&quot;&gt;CSS Media Queries for 
iPads &amp;amp; iPhones&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/needim/d15fdc2ac133d8078f7c&quot;&gt;Device Specific CSS Media Queries Collection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;0x2-solution&quot;&gt;0x2 Solution&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* porttrait是标准显示 */
/* landscape是放大显示 */
/* 这里用的是iPhone 6 portrait,iphone6标准显示*/
@media only screen and (min-device-width: 375px)
  and (max-device-width: 667px)
  and (orientation: portrait)
  and (-webkit-min-device-pixel-ratio: 2)
{...}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;p&gt;使用ios上的safari真机调试css,具体步骤如下&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;macOS|safari|偏好设置|高级选项|打开在菜单栏中显示开发功能&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ios上打开设置|safari|高级|web检查器&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;手机usb连接上mac,点mac上的safari的菜单栏上的开发,里面有手机子选项,打开它&lt;/li&gt;
  &lt;li&gt;然后在mac上的safari中修改css文件并查看手机上safari的显示效果&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;p&gt;chrome手机模式中选择iphone,并在chrome中直接调试css&lt;/p&gt;

&lt;p&gt;&lt;em&gt;css需要用对应ios设备的标准显示对应的media query,也即用portrait对应的media query&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x3-其它&quot;&gt;0x3 其它&lt;/h3&gt;

&lt;p&gt;jekyll的css调试可参考如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/css.png&quot; alt=&quot;调试图&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 20 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/auxilary/2017/12/20/ios%E7%9A%84css%E8%B0%83%E8%AF%95/</link>
        <guid isPermaLink="true">http://localhost:4000/auxilary/2017/12/20/ios%E7%9A%84css%E8%B0%83%E8%AF%95/</guid>
        
        <category>css</category>
        
        <category>ios</category>
        
        
        <category>auxilary</category>
        
      </item>
    
      <item>
        <title>vim写markdown</title>
        <description>&lt;h3 id=&quot;必读link&quot;&gt;必读link&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.lequochung.me/2016/11/11/better-markdown-writing-experience-on-vim.html&quot;&gt;Better Writing Markdown Experience on Vim&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://vim.wikia.com/wiki/Move_cursor_by_display_lines_when_wrapping&quot;&gt;Move cursor by display lines when wrapping&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.swamphogg.com/2015/vim-setup/&quot;&gt;Vim Setup for Markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why&quot;&gt;Why&lt;/h3&gt;

&lt;p&gt;几乎所有markdown编辑器在编辑markdown的一个段落时都是不换行的,也即一段不换行,一段就是一行,不过在这些编辑器中眼睛看到的是”换行的”,实际上是没有换行的,可通过使用记事本等文本工具打开来验证这一点.为什么这些markdown编辑器不将一个段落的内容进行换行呢?&lt;em&gt;在markdown中,可通过连续的两个空格加上换行符实现段内换行&lt;/em&gt;,笔者认为只有不进行换行才能达到自适应不同屏幕的好的显示效果,如果在段落中按照每行一个合理的固定长度(如79个字符长度)进行自动换行,那么在不同大小的屏幕上显示这个markdown的段落时会有一些多余的空格符,因为markdown在渲染成html后将一个单独的换行符(\n)变成一个空格符,这样写出的markdown不是最好的markdown,这种情况的详情在&lt;a href=&quot;https://github.com/iamcco/markdown-preview.vim/issues/54&quot;&gt;这里&lt;/a&gt;,渲染后的效果如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/markdown.png&quot; alt=&quot;换行变成空格&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以在用vim写markdown时要向markdown编辑器学习,一段不换行.可通过vim的set wrap实现,不过这样设置后vim编辑的时候用默认的设置会有”不适”,如j/k的使用,0/$的使用等.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How&lt;/h3&gt;

&lt;p&gt;为解决vim开启wrap写markdown时的一些”不适”,可在vimrc中设置如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;markdown setting
au BufNewFile,BufReadPost *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=markdown
au BufNewFile,BufReadPost,BufWrite *.{md,mdown,mkd,mkdn,markdown,mdwn} syntax match Comment /\%^---\_.\{-}---$/
au FileType markdown setlocal linebreak    &quot; Avoid wrap breaking words
au FileType markdown setlocal nolist       &quot; Make sure linebreak work as expected
au FileType markdown setlocal textwidth=0 &quot; Remove text width limit

&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; k gk
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; j gj
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; 0 g0
&quot; for wrap is on
noremap  &amp;lt;buffer&amp;gt; &amp;lt;silent&amp;gt; $ g$

inoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
&quot; for wrap is on
inoremap &amp;lt;c-j&amp;gt; &amp;lt;esc&amp;gt;gjli
&quot; for wrap is on
inoremap &amp;lt;c-k&amp;gt; &amp;lt;esc&amp;gt;gkli
inoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
cnoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
cnoremap &amp;lt;c-j&amp;gt; &amp;lt;down&amp;gt;
cnoremap &amp;lt;c-k&amp;gt; &amp;lt;up&amp;gt;
cnoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是不用插件的方法,也可使用&lt;a href=&quot;https://github.com/reedes/vim-pencil&quot;&gt;vim-pencil&lt;/a&gt;插件实现这个功能,此外vim-pencil插件还有其他的功能,使用vim-pencil插件后适应markdown的wrap开启状态的编写设置如下,其中vim-pencil已具备jk0$自动换成&lt;code class=&quot;highlighter-rouge&quot;&gt;gj/gk/g0/g$&lt;/code&gt;的功能,此外上面的设置中其他功能尚未测试,于是同样保留在vimrc中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Plugin 'reedes/vim-pencil'  &quot;安装这个插件,放在较靠前位置
...
...
let g:pencil#wrapModeDefault = 'soft'   &quot; default is 'hard'

&quot;markdown setting
au BufNewFile,BufReadPost *.{md,mdown,mkd,mkdn,markdown,mdwn} set filetype=markdown
au BufNewFile,BufReadPost,BufWrite *.{md,mdown,mkd,mkdn,markdown,mdwn} syntax match Comment /\%^---\_.\{-}---$/
au FileType markdown setlocal linebreak    &quot; Avoid wrap breaking words
au FileType markdown setlocal nolist       &quot; Make sure linebreak work as expected
au FileType markdown setlocal textwidth=0 &quot; Remove text width limit

augroup pencil
  autocmd!
  autocmd FileType markdown,mkd call pencil#init()
  autocmd FileType text         call pencil#init({'wrap': 'hard'})
augroup END

inoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
&quot; for wrap is on
inoremap &amp;lt;c-j&amp;gt; &amp;lt;esc&amp;gt;gjli
&quot; for wrap is on
inoremap &amp;lt;c-k&amp;gt; &amp;lt;esc&amp;gt;gkli
inoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
cnoremap &amp;lt;c-h&amp;gt; &amp;lt;left&amp;gt;
cnoremap &amp;lt;c-j&amp;gt; &amp;lt;down&amp;gt;
cnoremap &amp;lt;c-k&amp;gt; &amp;lt;up&amp;gt;
cnoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 19 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/vim/2017/12/19/vim%E5%86%99markdown/</link>
        <guid isPermaLink="true">http://localhost:4000/vim/2017/12/19/vim%E5%86%99markdown/</guid>
        
        <category>markdown</category>
        
        <category>vim</category>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>ios应用逆向工程1-4章笔记</title>
        <description>&lt;h3 id=&quot;概念篇工具篇&quot;&gt;概念篇+工具篇&lt;/h3&gt;

&lt;p&gt;1.bundle的概念来源于NeXTSTEP,它不是一个文件,而是一个按某种标准结构来组织的目录,其中包含了二进制文件及运行所需的资源.正向开发中常见的App和framework都是以bundle的形式存在的;framework也是bundle,但framework的bundle中存放的是一个dylib,而不是可执行文件.相对来说,framework的地位比App更高,因为一个App的绝大多数功能都是通过调用framework提供的接口来实现的.将某个bundle确立为逆向目标后,绝大多数逆向线索都可以在bundle内找到,这大大降低了逆向工程的复杂度&lt;/p&gt;

&lt;p&gt;2.Xcode自带的plutil工具可查看plist文件,命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;plutil -p xxx.plist&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.ios的app目录中的lproj目录下存放的是各种本地化的字符串(.strings),是ios逆向工程的重要线索,也可以用plutil查看&lt;/p&gt;

&lt;p&gt;4.storeapp的数据目录在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile/Containers/Data&lt;/code&gt;下,以mobile权限运行的系统app的数据目录在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/mobile/&lt;/code&gt;下,而以root权限运行的系统app的数据目录在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/root/&lt;/code&gt;下&lt;/p&gt;

&lt;p&gt;5.cydia app的安装包格式一般是deb,storeapp的安装包格式一般是ipa,其中deb的属主属组是root:admin,能够以root权限运行,而ipa是苹果为ios推出的专属app安装包格式,属主用户和属组都是mobile,只能以mobile权限运行&lt;/p&gt;

&lt;p&gt;6.通俗地说,ios中的沙盒就是一种访问限制机制,我们可以把它看作是权限的一种表现形式,授权文件也是沙盒的一部分.总的来说,沙盒会将app的文件访问范围限制在这个app内部,一个app一般不知道其他app的存在,更别说访问它们了,沙盒还会限制app的功能,例如对icloud接口的调用就必须经过沙盒的允许.越狱本身已经破除了ios的绝大多数安全限制,并对沙盒进行了一定程度的扩充,因此我们往往很容易忽略sandbox的存在,从而碰到一些看似很奇怪的问题.比如某个tweak不能写文件,调用了某个函数却没有出现应有的效果,在确保自己的代码没有问题的前提下,就要回过头来检查这些问题是不是因为权限不够,或者沙盒限制造成的&lt;/p&gt;

&lt;p&gt;7.cydia里的各种tweak无一不是以dylib的形式工作的&lt;/p&gt;

&lt;p&gt;8.ios实际上存在真正的后台多任务,如接听电话时ios会第一时间将接听电话界面呈现在我们面前.不过,对于storeapp来说,当用户按下home键时,进程就进入后台了,大多数功能都会被暂停&lt;/p&gt;

&lt;p&gt;9.在theos新建的工程目录文件夹中,可以创建一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;的文件夹,然后把工程打包成deb并安装到ios中,此时&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;中的所有文件会被解包到ios文件系统的相同位置(这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;相当于ios中的根目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;),这极大扩充了deb包的什么用范围&lt;/p&gt;

&lt;p&gt;10.命令行安装theos生成的deb到手机的方法:在makefile的最上一行加上本机ip地址&lt;code class=&quot;highlighter-rouge&quot;&gt;THEOS_DEVICE_IP=...&lt;/code&gt;,然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;make package install&lt;/code&gt;命令完成编译打包安装一条龙服务&lt;/p&gt;

&lt;p&gt;11.免ssh输密码&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;删除本机~/.ssh/known_hosts中目标ip对应条目&lt;/li&gt;
  &lt;li&gt;在本机生成ida_rsa.pub文件:&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen -t rsa&lt;/code&gt;,生成的文件为&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在目标机器终端中&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-keygen&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在本机中执行&lt;code class=&quot;highlighter-rouge&quot;&gt;scp ~/.ssh/id_rsa.pub user@目标ip:~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12.&lt;/p&gt;
</description>
        <pubDate>Mon, 18 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/18/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B1-4%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/18/ios%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B1-4%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>ios</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>记一次爬虫绕过</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;在一次数据采集(爬虫)中,目标服务器比较特殊,似乎是数据库服务器设置了一定时间内有查询次数上限,导致多次尝试没有成功爬
取大量数据.目标网站防爬虫特点:&lt;/p&gt;

&lt;p&gt;1.关键的元素页数(下面的pageNo)用的是js动态生成再显示到网页上的&lt;/p&gt;

&lt;p&gt;2.没带cookie请求时,请求不同页数(下面的pageNo)的html内容时,返回的html相同&lt;/p&gt;

&lt;p&gt;3.一个cookie似乎查询5000项数据次以后就不能再请求了,要过10min或更多的时间才可以访问&lt;/p&gt;

&lt;p&gt;4.换ip不换cookie的情况下查询次数也是5000项左右&lt;/p&gt;

&lt;h3 id=&quot;0x01-solution&quot;&gt;0x01 Solution&lt;/h3&gt;

&lt;p&gt;1.用phantomjs(通过js脚本)发送请求,使目标的js可在phantomjs中运行成功&lt;/p&gt;

&lt;p&gt;2.用ip代理池(IPProxyPool)&lt;/p&gt;

&lt;p&gt;3.每次请求带cookie且每个不同的请求用不同的cookie&lt;/p&gt;

&lt;p&gt;4.多线程查询,下面代码中涉及多线程写同一个文件时要事先加锁&lt;/p&gt;

&lt;h3 id=&quot;0x02-code&quot;&gt;0x02 Code&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import requests
import re
import random
import os
from exp10it import get_string_from_command

IPProxyPoolUrl = &quot;http://192.168.8.240:8000/?types=0&amp;amp;count=100&quot;


def get_random_proxy():
    IPPOOL = eval(requests.get(IPProxyPoolUrl).text)
    random_choose = random.choice(IPPOOL)
    proxy_addr = &quot;http://&quot; + \
        str(random_choose[0]) + &quot;:&quot; + str(random_choose[1])
    return proxy_addr


qihao_list = [
    '201502',
    '201503',
    '201504',
    '201505',
    '201506',
    '201507',
    '201508',
    '201509',
    '201510',
    '201511',
    '201512',
    '201601',
    '201602',
    '201603',
    '201604',
    '201605',
    '201606',
    '201607',
    '201608',
    '201609',
    '201610',
    '201611',
    '201612',
    '201701',
    '201702',
    '201703',
    '201704',
    '201705',
    '201706',
    '201707',
    '201708',
    '201709',
    '201710',
    '201711'
]

url = &quot;http://xxx.xxx.xxx&quot;
headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:51.0) Gecko/20100101 Firefox/51.0',
           'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
           'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',
           'Cookie': 'JSESSIONID=EA6DCEF9BA7D4ED7EA25B0377C20C092-n2.Tomcat1',
           'Connection': 'close',
           'Upgrade-Insecure-Requests': '1',
           'Content-Type': 'application/x-www-form-urlencoded',
           'Content-Length': '38'
           }
import threading
mutex = threading.Lock()
for qihao in qihao_list:
    i = 0
    post_js_content = '''
&quot;use strict&quot;;
var page = require('webpage').create(),
    server = 'http://xxx.xxx.xxx',
    data = 'pageNo=1&amp;amp;issueNumber=%s&amp;amp;applyCode=';

page.settings.resourceTimeout = 9999999999999;
page.settings.userAgent = &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.%s Safari/537.36&quot;;

page.open(server, 'post', data, function (status) {
    if (status !== 'success') {
        console.log('Unable to post!');
    } else {
        console.log(page.content);
    }
    phantom.exit();
});
    ''' % (qihao, ++i)
    while True:
        os.system(&quot;rm post.js&quot;)
        with open(&quot;post.js&quot;, &quot;a+&quot;) as f:
            f.write(post_js_content)
        proxy_addr = get_random_proxy()
        print(proxy_addr)
        html = get_string_from_command(
            &quot;phantomjs post.js --proxy=%s&quot; % proxy_addr)
        has_page_no = re.search(r&quot;/(\d+)页&quot;, html)
        if has_page_no:
            break
        else:
            print(&quot;没有获取到页数,尝试再次获取...&quot;)
            continue

    pageNo = has_page_no.group(1)
    print(&quot;期号:%s,页数:%s&quot; % (qihao, pageNo))
    page_list = []
    for page in range(1, int(pageNo) + 1):
        page_list.append(str(page))

    def get_page_content(page):
        data = &quot;pageNo=%s&amp;amp;issueNumber=%s&amp;amp;applyCode=&quot; % (page, qihao)
        print(&quot;正在请求第%s期,第%s页...&quot; % (qihao, page))
        rsp = requests.get(url, timeout=60)
        cookie = rsp.headers['Set-Cookie']
        # print(cookie)
        headers['Cookie'] = cookie
        proxy_addr = get_random_proxy()
        proxies = {}
        proxies_1 = proxy_addr.split(&quot;:&quot;)[0]
        proxies[proxies_1] = proxy_addr
        # print(proxies)
        html = requests.post(url, data.encode(&quot;utf-8&quot;),
                             headers=headers, proxies=proxies, timeout=60).text
        a = re.findall(
            r'''class=&quot;content_data&quot;[\s\S]*?&amp;lt;td\s*&amp;gt;(\d+)&amp;lt;/td&amp;gt;[\s\S]*?&amp;lt;td\s*&amp;gt;(.+)&amp;lt;/td&amp;gt;''', html)
        mutex.acquire()
        for each in a:
            with open(&quot;x.txt&quot;, &quot;a+&quot;) as f:
                string_to_write = qihao + &quot;    &quot; + \
                    each[0] + &quot;    &quot; + each[1] + &quot;\n&quot;
                print(string_to_write)
                f.write(string_to_write)
        mutex.release()

    from concurrent import futures
    with futures.ThreadPoolExecutor(max_workers=20) as executor:
        executor.map(get_page_content, page_list)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;code can be download &lt;a href=&quot;https://raw.githubusercontent.com/3xp10it/mytools/master/xban.py&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 15 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/12/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%95%E8%BF%87/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/12/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%88%AC%E8%99%AB%E7%BB%95%E8%BF%87/</guid>
        
        <category>spider</category>
        
        <category>phantomjs</category>
        
        <category>IPProxyPool</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>pycharm调试包含scrapy框架的项目</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pdb调试python文件方法:
import pdb
pdb.set_trace()

pdb调试好处很多,但是不支持多线程调试和远程调试
于是通过pycharm调试scrapy中的爬虫脚本
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;refer:&lt;/p&gt;

&lt;p&gt;http://www.jianshu.com/p/eda047ac5c89&lt;/p&gt;

&lt;h3 id=&quot;0x01-项目结构&quot;&gt;0x01 项目结构&lt;/h3&gt;

&lt;p&gt;在pycharm中新建项目时默认会为新建的项目新建一个python虚拟环境&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/root/PycharmProjects为pycharm默认存放项目的目录
scanner为新建的项目的项目名
venv是pycharm新建的python虚拟环境目录

/root/PycharmProjects
└── scanner
    └── venv
        ├── bin
        ├── include
        ├── lib
        ├── pip-selfcheck.json
        └── selenium

项目包含两个文件夹,分别为/root/3xp10it和/root/mypypi

其中/root/3xp10it目录如下,其中/root/3xp10it/3xp10it.py为项目启动文件,项目通过python3 3xp10it.py运行

/root/3xp10it
├── 3xp10it.py
├── debug.py
├── develop.md
├── ghostdriver.log
├── ipproxypool_scrapysplash_server.py
├── pannel
│   ├── manage.py
│   ├── models.py
│   ├── pages
│   └── pannel
├── readme.md
├── targets.py
├── uninstall.py
└── web.py


/root/mypypi中的爬虫模块相关目录如下,其中/root/mypypi/crawler/crawler/spiders/exp10it_spider.py为scrapy爬虫脚本,单独启动爬虫的命令为cd /root/mypypi/crawler &amp;amp;&amp;amp; python3 -m scrapy crawl exp10it

├── crawler                 
│   ├── crawler                  
│   │   ├── ghostdriver.log
│   │   ├── __init__.py   
│   │   ├── items.py    
│   │   ├── middlewares.py    
│   │   ├── pipelines.py                 
│   │   ├── settings.py    
│   │   └── spiders       
│   │       ├── exp10it_spider.py
│   │       ├── __init__.py
│   ├── ghostdriver.log        
│   ├── scrapy.cfg                     
│   └── start.py                 
├── xxx
├── dicts           

其中exp10it_spider.py内容大致如下:

class Exp10itSpider(scrapy.Spider):
    name = &quot;exp10it&quot;
    collected_urls = []
    domain = &quot;&quot;
    start_url = &quot;&quot;

    def add_url_templet_to_collected_urls(self, url):
        url=re.sub(r&quot;(#[^\?]*)$&quot;,&quot;&quot;,url)
        parsed = urlparse(url)
        if len(parsed)&amp;lt;4:


三个文件夹的关系:
/root/3xp10it/3xp10it.py中的funcA调用了/root/mypypi/exp10it.py中的funcB
/root/mypypi/exp10it.py中的funcB调用了/root/PycharmProject/scanner/venv/lib/site-packages/scrapy模块进行爬虫
,funcB相关代码如下(funB为下面的scrapy_splash_crawl_url):

def scrapy_splash_crawl_url(url):
    # replace crawl_url method
    url=re.sub(r&quot;\s+$&quot;,&quot;&quot;,url)
    spider_file=ModulePath+&quot;/crawler/crawler/spiders/exp10it_spider.py&quot;
    parsed=urlparse(url)
    if re.search(r&quot;/\S+\.\S{1,4}$&quot;,parsed.path):
        path=re.sub(r&quot;(?&amp;lt;=/)[^/\s\.]+\.\S{1,4}&quot;,&quot;&quot;,parsed.path)
    else:
        if parsed.path==&quot;&quot; or parsed.path[-1]!=&quot;/&quot;:
            path=parsed.path+&quot;/&quot;
        else:
            path=parsed.path
    modify_url=parsed.scheme+&quot;://&quot;+parsed.netloc+path
    cmd='''sed -i 's#target_url_to_crawl=&quot;.*&quot;#target_url_to_crawl=&quot;%s&quot;#g' %s''' % (modify_url,spider_file)
    os.system(cmd)
    from scrapy import cmdline
    cmdline.execute('scrapy crawl exp10it'.split())

上面funB中调用scrapy关键代码为:
    cmdline.execute('scrapy crawl exp10it'.split())

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-解决办法&quot;&gt;0x02 解决办法&lt;/h3&gt;

&lt;p&gt;方法1:&lt;/p&gt;

&lt;p&gt;设置/root/3xp10it/3xp10it.py(项目运行文件)的工作目录为与爬虫目录中的scrapy.cfg文件同目录的/root/mypypi/crawler,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/pycharm_scrapy.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;方法2(推荐):&lt;/p&gt;

&lt;p&gt;将方法1中的在pycharm中为/root/3xp10it/3xp10it.py设置的工作目录为/root/mypypi/crawler通过代码实现,在
&lt;code class=&quot;highlighter-rouge&quot;&gt;cmdline.execute('scrapy crawl exp10it'.split())&lt;/code&gt;前通过代码切换工作目录:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.chdir(&quot;/root/mypypi/crawler&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 14 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/12/14/pycharm%E8%B0%83%E8%AF%95%E5%8C%85%E5%90%ABscrapy%E6%A1%86%E6%9E%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/12/14/pycharm%E8%B0%83%E8%AF%95%E5%8C%85%E5%90%ABscrapy%E6%A1%86%E6%9E%B6%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
        
        <category>pycharm</category>
        
        <category>scrapy</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Android软件安全与逆向分析第3章笔记</title>
        <description>&lt;h3 id=&quot;进入android-dalvik虚拟机&quot;&gt;进入Android Dalvik虚拟机&lt;/h3&gt;

&lt;p&gt;1.虽然Android平台使用了Java语言来开发应用程序,但Android程序却不是运行在标准Java虚拟机上的,可能是为了解决移动设备
上软件运行效率的问题,也可能是为了规避与Oracle公司的版权纠纷.Google为Android平台专门设计了一套虚拟机来运行Android
程序,它就是Dalvik Virtual Machine(Dalvik虚拟机)&lt;/p&gt;

&lt;p&gt;2.Dalvik虚拟机作为Android平台的核心组件,拥有如下几个特点:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;体积小,占用内存空间小&lt;/li&gt;
  &lt;li&gt;专有的DEX可执行文件格式,体积更小,执行速度更快&lt;/li&gt;
  &lt;li&gt;常量池采用32位索引值,寻址类方法名,字段名,常量更快&lt;/li&gt;
  &lt;li&gt;基于寄存器架构,并拥有一套完整的指令系统&lt;/li&gt;
  &lt;li&gt;提供了对象生命周期管理,堆栈管理,线程管理,安全和异常管理以及垃圾回收等重要功能&lt;/li&gt;
  &lt;li&gt;所有的Android程序都运行在Android系统进程里,每个进程对应着一个Dalvik虚拟机实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.Dalvik虚拟机与Java虚拟机的区别&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;java虚拟机运行的是Java字节码,Dalvik虚拟机运行的是Dalvik字节码&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;传统的Java程序经过编译,生成Java字节码保存在class文件中,Java虚拟机通过解码class文件中的内容来运行程序.而Dalvik虚拟机运行的是Dalvik字节码,所有的Dalvik字节码由Java字节码转换而来,并被打包到一个DEX(Dalvik Executable)可执行文件中.Dalvik虚拟机通过解释DEX文件来执行这些字节码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Dalvik可执行文件体积更小&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码.dx工具对Java类文件重新排列,消除在类文件中出现的所有冗余信息,避免虚拟机在初始化时出现反复的文件加载与解析过程.dx将所有的Java类文件中的常量池进行分解,消除其中的冗余信息,重新组合形成一个常量池,所有的类文件共享同一个常量池&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Java虚拟机与Dalvik虚拟机虚拟机架构不同&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java虚拟机基于栈架构.程序在运行时虚拟机需要频繁的从栈上读取或写入数据.Dalvik虚拟机基于寄存器架构,数据的访问通过寄存器直接传递,这样的访问方式比基于栈方式要快很多,基于寄存器架构的Dalvik虚拟机与基于栈架构的Java虚拟机相比,由于生成的代码指令减少了,程序执行速度会更快一些&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4.Android系统由Linux内核,函数库,Android运行时,应用程序框架以及应用程序组成.Dalvik虚拟机属于Android运行时环境,它与
一些核心库共同承担Android应用程序的运行工作&lt;/p&gt;

&lt;p&gt;5.JIT(Just-in-time Compilation,即时编译),双称为动态编译,是一种在运行时将字节码翻译为机器码的技术,使得程序的执行速
度更快.主流的JIT包含两种字节码编译方式:&lt;/p&gt;

&lt;p&gt;method方式:以函数或方法为单位进行编译,耗费更多的内存
trace方式:以trace为单位进行编译,耗费内存少,目前Dalvik虚拟机默认采用trace方式编译代码&lt;/p&gt;

&lt;p&gt;6.Dalvik虚拟机基于寄存器架构,在代码中大量地使用到了寄存器,Dalvik中用到的寄存器都是32位的,支持任何类型,64位类型用2
个相信寄存器表示,Dalvik支持2^16-1=65535个寄存器,寄存器采用v0作起始值,因此它的取值范围是v0~v65535.Dalvik虚拟机为每
个进程维护一个调用栈,这个调用栈其中一个作用就是用来”虚拟”寄存器,每个函数都在函数头部使用.registers指令指定函数用
到的寄存器数目,当虚拟机执行到这个函数时,会可以接收寄存器的数目分配适当的栈空间,这些栈空间就是用来存放寄存器实际的
值的.虚拟机通过处理字节码,对寄存器进入读与写的操作&lt;/p&gt;

&lt;p&gt;7.在Android4.0系统以前,每个指令的字节码只占用一个字节,范围是0x0~0xff.在Android4.0系统中,又扩充了一部分指令,这些指
令被称为扩展指令&lt;/p&gt;

&lt;p&gt;8.编译smali文件命令:&lt;code class=&quot;highlighter-rouge&quot;&gt;java -jar smali.jar -o output.dex input.smali&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/08/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/08/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>Android</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>理解重定位</title>
        <description>&lt;h3 id=&quot;0x00-必读link&quot;&gt;0x00 必读link&lt;/h3&gt;

&lt;p&gt;1.书籍&lt;code class=&quot;highlighter-rouge&quot;&gt;程序员的自我修养&lt;/code&gt;中第4.2和7.3和7.4和7.5章节&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://www.zhihu.com/question/21249496&quot;&gt;Linux动态链接为什么要用PLT和GOT表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/&quot;&gt;共享库加载时重定位&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24231428&quot;&gt;pie/pic/aslr的理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/&quot;&gt;共享库中的PIC&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-预备知识&quot;&gt;0x01 预备知识&lt;/h3&gt;

&lt;p&gt;1.硬件对变量和函数的寻址方式不同,寻找变量要求绝对地址,寻找函数要求相对地址.&lt;/p&gt;

&lt;p&gt;call指令的偏移量计算方法:偏移量=跳转到的地址-call指令后一条指令的起始地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00413766    e8 7a da ff ff      call 00411e5
0041376b    ...                 ...

e8代表call,7a da ff ff代表偏移量0xffffda7a,对应负数-0x2586,0x0041376b+(-0x2586)=0x00411e5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.程序由编译(成汇编代码),链接(组合.o文件)得到可执行文件,重定位有链接时重定位+装载时重定位(上面必读link中叫load time
relocate),装载时重定位完成后得到的地址是虚拟存储器的虚拟地址,实际与内存交互时,需要由内核再完成虚拟存储器的虚拟
地址到真实物理内存地址的转换.&lt;/p&gt;

&lt;p&gt;4.编译阶段,.o文件的全局变量位置不确定,因为这时无法确定还有其它哪些.o文件,以及链接器将来会按什么顺序”排列”这些.o文
件,所以编译阶段没有重定位,链接阶段,如果elf没有调用so中的符号,则可以在链接时重定位所有符号的地址(因为这时所有的.o
文件的数据段代码段都组合完成了,所有符号的偏移都是确定的),如果elf调用了so中的符号,则由于so文件的符号位置不确定,因为
这时不知道.so文件将来被加载到进程空间的什么位置,所以与so中符号有关的地址需要装载时重定位.&lt;/p&gt;

&lt;p&gt;5.在没有开启pie的情况下:elf如果没有调用so则不用装载时重定位.elf如果没有调用so则没有plt表(有got表).so(elf)通过
plt+got来实现pic(pie).plt表中的内容是代码,got表中的内容是数据(各种符号的地址)&lt;/p&gt;

&lt;p&gt;6.一般情况下,exe的期望加载基址为0x400000(4M),dll为0x1000000(16M),elf为0x8048000(约128M),so为0x40000000(1G),期望加
载基址由编译器指定,在可执行文件中有一个位置存放这个值&lt;/p&gt;

&lt;p&gt;7.查看elf有没有开pie可简单通过readelf -l elffile看出,对应如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Elf 文件类型为 DYN (共享目标文件)       ===&amp;gt;对应开启了pie
Elf 文件类型为 EXEC (可执行文件)        ===&amp;gt;对应未开启pie
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.实际情况中,对有PIE保护的elf,ida静态分析时会以加载基址=0加载,angr在加载这样的elf时会以加载基址=0x400000加载到虚
拟内存中进行符号执行,也即angr会强制将有pie保护的elf加载到0x400000处去,这样就相当于去掉了pie的每次加载基址不同
(aslr)的特性&lt;/p&gt;

&lt;p&gt;9.plt和got示例(linux下这样叫,macOS下有其他名字)&lt;/p&gt;

&lt;p&gt;如下图中printf函数是外部so文件中的函数,于是需要有plt和got,从左边的printf,puts,atoi等函数看出,一般只有外部so文件中
的函数调用才会用到plt,在下图ida中,发现plt段在.init段之后,.text段之前&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;printf函数的plt表中内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:080483C0
.plt:080483C0 ; =============== S U B R O U T I N E =======================================
.plt:080483C0
.plt:080483C0 ; Attributes: thunk
.plt:080483C0
.plt:080483C0 ; int printf(const char *format, ...)
.plt:080483C0 _printf         proc near               ; CODE XREF: main+2C↓p
.plt:080483C0
.plt:080483C0 format          = dword ptr  4
.plt:080483C0
.plt:080483C0                 jmp     ds:off_804A000
.plt:080483C0 _printf         endp
.plt:080483C0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;printf函数对应的got表中内容如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的got表被ida解析了,ida指出0x804A000处的内容是printf函数的偏移,实际在16进制模式下的内容如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也即在0x804A000这个地址中的值为0x804A030,也即got表中对应内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x804A000:0x804A030
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个0x804A030在运行后会被因为重定位被修改成其他值,因为实际运行时printf函数的地址应该会变成不再是0x404A030了&lt;/p&gt;

&lt;h3 id=&quot;0x02-链接时重定位&quot;&gt;0x02 链接时重定位&lt;/h3&gt;

&lt;p&gt;如果没涉及so函数调用,则只通过链接时重定位即可完成重定位,不需要装载时重定位,由链接器单独完成重定位,下面进入操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;works in x86 kali linux

vi a.c

    /* a.c */
    extern int shared;

    int main()
    {
        int a = 100;
        swap(&amp;amp;a,&amp;amp;shared);
    }

vi b.c

    /* b.c */
    int shared = 1;

    void swap(int* a,int* b)
    {
        *a ^= *b ^= *a ^= *b;
    }

gcc -c a.c b.c 
    编译得到a.o和b.o目标文件

ld a.o b.o -e main -o ab
    链接a.o和b.o,设置输出文件为ab,设置main函数为入口

objdump -h a.o
    a.o:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         0000004a  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000000  00000000  00000000  00000086  2**0
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000086  2**0

objdump -h b.o
    b.o:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         00000043  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000004  00000000  00000000  00000080  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000084  2**0

objdump -h ab
    ab:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .text         00000091  08048094  08048094  00000094  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
      1 .eh_frame     00000080  08048128  08048128  00000128  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
      2 .got.plt      0000000c  0804a000  0804a000  00001000  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .data         00000004  0804a00c  0804a00c  0000100c  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      4 .comment      00000026  00000000  00000000  00001010  2**0

      VMA表示虚拟存储器的虚拟地址,由上可以看出,在链接之前,所有段的VMA都是0,在链接后出现了got表.且got表中的内容全
      为0,如下:
            .got.plt:0804A000 ; ===========================================================================
            .got.plt:0804A000
            .got.plt:0804A000 ; Segment type: Pure data
            .got.plt:0804A000 ; Segment permissions: Read/Write
            .got.plt:0804A000 _got_plt        segment dword public 'DATA' use32
            .got.plt:0804A000                 assume cs:_got_plt
            .got.plt:0804A000                 ;org 804A000h
            .got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd 0              ; DATA XREF: LOAD:0804805C↑o
            .got.plt:0804A000                                         ; swap+10↑r ...
            .got.plt:0804A004                 db    0
            .got.plt:0804A005                 db    0
            .got.plt:0804A006                 db    0
            .got.plt:0804A007                 db    0
            .got.plt:0804A008                 db    0
            .got.plt:0804A009                 db    0
            .got.plt:0804A00A                 db    0
            .got.plt:0804A00B                 db    0
            .got.plt:0804A00B _got_plt        ends
            .got.plt:0804A00B
            .data:0804A00C ; ===========================================================================
      如果在链接前就产生了got表的话,可以通过在编译时直接在需要重定位的地方写上got表项的地址中的指针指向的值来达到
      plt表的功能,如:
      mov var,[[0x0804A000]]   
      其中0x0804A000是一个got表项的地址.这样的话(在链接前就产生了got表)就可以省去plt表了,因为plt表的作用就是找到
      got表中的地址.当然这里的elf文件ab没有plt表,因为不涉及so文件中符号的使用.

objdump -d a.o
    a.o:     文件格式 elf32-i386
    Disassembly of section .text:
    00000000 &amp;lt;main&amp;gt;:
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	e8 fc ff ff ff       	call   13 &amp;lt;main+0x13&amp;gt;
      17:	05 01 00 00 00       	add    $0x1,%eax
      1c:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
      23:	83 ec 08             	sub    $0x8,%esp
      26:	8b 90 00 00 00 00    	mov    0x0(%eax),%edx   ===&amp;gt;shared变量
      2c:	52                   	push   %edx
      2d:	8d 55 f4             	lea    -0xc(%ebp),%edx
      30:	52                   	push   %edx
      31:	89 c3                	mov    %eax,%ebx
      33:	e8 fc ff ff ff       	call   34 &amp;lt;main+0x34&amp;gt;   ===&amp;gt;swap函数
      38:	83 c4 10             	add    $0x10,%esp
      3b:	b8 00 00 00 00       	mov    $0x0,%eax
      40:	8d 65 f8             	lea    -0x8(%ebp),%esp
      43:	59                   	pop    %ecx
      44:	5b                   	pop    %ebx
      45:	5d                   	pop    %ebp
      46:	8d 61 fc             	lea    -0x4(%ecx),%esp
      49:	c3                   	ret    

      如上反汇编代码中,在a.c编译成a.o时,编译器不知道shared变量和swap函数的地址,因为它们定义在其他目标文件中
      (b.o),所以编译器就暂时把地址0看作是shared的地址,同样将call指令的目标地址的位置当作call的目标地址
      (0xfffffffc=-4,0x38-0x4=0x34,相当于call自己),也即在编译阶段,编译器把这两个待重定位的值分别写成0x00000000和
      0xfffffffc,把真正的地址计算工作留给了链接器,链接器在完成地址和空间分配之后就已经可以确定所有符号的虚拟地址
      了(因为这里未涉及so的调用),那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正.

objdump -d ab
    ab:     文件格式 elf32-i386
    Disassembly of section .text:

    08048094 &amp;lt;main&amp;gt;:
     8048094:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     8048098:	83 e4 f0             	and    $0xfffffff0,%esp
     804809b:	ff 71 fc             	pushl  -0x4(%ecx)
     804809e:	55                   	push   %ebp
     804809f:	89 e5                	mov    %esp,%ebp
     80480a1:	53                   	push   %ebx
     80480a2:	51                   	push   %ecx
     80480a3:	83 ec 10             	sub    $0x10,%esp
     80480a6:	e8 33 00 00 00       	call   80480de &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
     80480ab:	05 55 1f 00 00       	add    $0x1f55,%eax
     80480b0:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
     80480b7:	83 ec 08             	sub    $0x8,%esp
     80480ba:	c7 c2 0c a0 04 08    	mov    $0x804a00c,%edx      ===&amp;gt;shared变量
     80480c0:	52                   	push   %edx
     80480c1:	8d 55 f4             	lea    -0xc(%ebp),%edx
     80480c4:	52                   	push   %edx
     80480c5:	89 c3                	mov    %eax,%ebx
     80480c7:	e8 16 00 00 00       	call   80480e2 &amp;lt;swap&amp;gt;       ===&amp;gt;swap函数
     80480cc:	83 c4 10             	add    $0x10,%esp
     80480cf:	b8 00 00 00 00       	mov    $0x0,%eax
     80480d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
     80480d7:	59                   	pop    %ecx
     80480d8:	5b                   	pop    %ebx
     80480d9:	5d                   	pop    %ebp
     80480da:	8d 61 fc             	lea    -0x4(%ecx),%esp
     80480dd:	c3                   	ret    

     由ab文件的反汇编代码可以看出,经过链接阶段的修正后,shared变量和swap函数的地址分别为0x804a00c和0x00000016.
     链接器通过重定位表来对shared和swap的地址重定位,对于每个要重定位的elf段都有一个对应的重定位段(重定位表),比如
     代码段.text如有要重定位的地方,那么会有一个相应叫.rel.text的段保存了代码段的重定位表,如果代码段.data有要重定
     位的地方,那么会有一个相应叫.rel.data的段保存了数据段的重定位表,可以通过objdump -r或readelf -r查看目标文件的
     重定位表,objdump -r可查看.o文件的重定位位,无法查看elf文件的重定位表,如果要查看elf文件的重定位表要使用readelf
     -r elffile,在.o文件中重定位段分别为.rel.text和.rel.data的段在elf(so)文件中的名称为.rel.plt和.rel.dyn,其中
     .rel.plt是对函数的引用的修正,它所修正的位置位于.got.plt;其中.rel.dyn是对数据引用的修正,它所修正的位置位于
     .got以及数据段.

     .o文件:(查看方法:objdump|readelf -r xxx.o)
     .rel.text&amp;lt;===&amp;gt;代码段重定位表
     .rel.data&amp;lt;===&amp;gt;数据段重定位表

     elf(so)文件:(查看方法:readelf -r elffile)
    .rel.plt&amp;lt;===&amp;gt;代码段重定位表,对函数引用的修正,修正的位置位于.got.plt
    .rel.dyn&amp;lt;===&amp;gt;数据段重定位表,对数据引用的修正,修正的位置位于.got以及数据段

objdump -r a.o
    a.o:     文件格式 elf32-i386
    RELOCATION RECORDS FOR [.text]:
    OFFSET   TYPE              VALUE 
    00000013 R_386_PC32        __x86.get_pc_thunk.ax
    00000018 R_386_GOTPC       _GLOBAL_OFFSET_TABLE_
    00000028 R_386_GOT32X      shared
    00000034 R_386_PLT32       swap

    由上看出shared和swap是不同的重定位类型,下面是不同重定位类型的不同计算重定位值的方法.
    容易想到,变量和函数的计算重定位值的算法是不同的,因为函数一般用相对地址,变量用绝对地址.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc4.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab文件不涉及so的调用,所以链接时重定位就可以完成重定位的工作了,证明如下,在gdb加载ab文件后,分别查看main的地址
,main+0x28,main+0x34中的内容发现与运行前(链接后)链接器认为的地址一致,具体如下:

gdb ab
p main
    $1 = {&amp;lt;text variable, no debug info&amp;gt;} 0x8048094 &amp;lt;main&amp;gt;
x main+0x28
    (gdb) x main+0x28
    0x80480bc &amp;lt;main+40&amp;gt;:	0x0804a00c
x main+0x34
    (gdb) x main+0x34
    0x80480c8 &amp;lt;main+52&amp;gt;:	0x00000016
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-装载时重定位&quot;&gt;0x03 装载时重定位&lt;/h3&gt;

&lt;p&gt;1.场景&lt;/p&gt;

&lt;p&gt;以上链接时重定位可以完成没有调用so文件的代码的重定位工作,如果涉及到so中符号的调用,则需要装载时重定位来完成与调用
so符号相关代码的重定位工作,因为在可执行文件加载so前是不知道so的加载基址的,重定位与so符号相关的值这项工作需要装载
时重定位完成.&lt;/p&gt;

&lt;p&gt;实例:(works in kali x64)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* test.c */
#include &amp;lt;stdio.h&amp;gt;

void print_banner()
{
    printf(&quot;Welcome to World of PLT and GOT\n&quot;);
}

int main(void)
{
    print_banner();

    return 0;
}

由于实验在x64的kali系统下进行,要编译32位的elf需要先安装依赖,上面的链接时重定位的内容是在x86的kali上做的实验,而这
里是在x64上做的实验,原因是做这个实验时旁边没有x86的机器.
    apt-get install gcc-multilib
    apt-get install g++-multilib

编译:gcc -Wall -g -o test.o -c test.c -m32
链接:gcc -o test test.o -m32
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.普通的装载时重定位&lt;/p&gt;

&lt;p&gt;为了能够使so可以在任意地址装载,可以通过在链接时对所有绝对地址的引用不作重定位,而把这一步推迟到装载时再完成.一旦
模块装载地址确定,即目标地址确定,那么系统就对程序中所有的绝对地址引用进行重定位.假设函数foobar相对于代码段的起始地
址是0x100,当模块被装载到0x10000000时,假设代码段位于模块的最开始,那么可以确定foobar的地址为0x10000100,这时候,系统
遍历模块中的重定位表,把所有对foobar的地址引用都重定位到0x10000100.但是由于这种普通的装载时重定位存在一些问题,现在
的操作系统一般使用pie|pic技术&lt;/p&gt;

&lt;p&gt;3.PIC(特殊的装载时重定位)&lt;/p&gt;

&lt;p&gt;PIC:程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变,通过把指令中的那些需要修改的部分分离出来,跟数据
部分放在一起,这样指令部分就可以保持不变,而数据部分可以在每个进程中拥有一个副本,这种方案就是目前被称为
&lt;code class=&quot;highlighter-rouge&quot;&gt;地址无关代码&lt;/code&gt;技术,PIC是对动态链接库(so)而言的,可执行文件(elf)对应的技术叫PIE.&lt;/p&gt;

&lt;p&gt;在test.c得到的test文件,查看test文件有没有使用到pie(现在gcc一般默认开启了pie选项):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./checksec -f test
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FORTIFY Fortified Fortifiable  FILE
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   No      0       0test

说明开启了pie
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用ida打开test,双击print_banner函数,可以看到对应的反汇编代码如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双击其中的so中的put函数(也即对应test.c中的printf函数),可以看到ida中的注释&lt;code class=&quot;highlighter-rouge&quot;&gt;PIC mode&lt;/code&gt;,说明printf对应的so库采用了PIC
技术:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.怎样实现PIC?&lt;/p&gt;

&lt;p&gt;a)模块内部的函数调用,跳转&lt;/p&gt;

&lt;p&gt;这种情况下是最简单的,直接使用相对地址调用或者基于寄存器的相对调用即可,所以对于这种指令是不需要重定位的&lt;/p&gt;

&lt;p&gt;b)模块内部数据访问&lt;/p&gt;

&lt;p&gt;指令中不能直接包含数据的绝对地址,于是只能用相对寻址.&lt;code class=&quot;highlighter-rouge&quot;&gt;__i686.get_pc_thunk.cx&lt;/code&gt;函数可以获取当前汇编指令的下一条指令
的地址,会将这个地址放到ecx寄存器,即把&lt;code class=&quot;highlighter-rouge&quot;&gt;call __i686.get_pc_thunk.cx&lt;/code&gt;下一条指令的地址放到ecx中.由于任何一条指令与它
需要访问的模块内部的数据之间的距离是确定的,结合这个函数,可实现模块内部数据访问的相对寻址.如下在test文件中的
&lt;code class=&quot;highlighter-rouge&quot;&gt;__x86_get_pc_thunk_ax&lt;/code&gt;函数,作用是将下一条指令的地址放到ax中.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push    ebp
mov     ebp, esp
push    ebx
sub     esp, 4
call    __x86_get_pc_thunk_ax
add     eax, 1AD7h
sub     esp, 0Ch
lea     edx, (aWelcomeToWorld - 2000h)[eax] ; &quot;Welcome to World of PLT and GOT&quot;
push    edx             ; s
mov     ebx, eax
call    _puts
add     esp, 10h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__x86_get_pc_thunk_ax&lt;/code&gt;的实现很简单,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public __x86_get_pc_thunk_ax
__x86_get_pc_thunk_ax proc near
; __unwind {
mov     eax, [esp+0]
retn
; } // starts at 576
__x86_get_pc_thunk_ax endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c)模块间数据访问&lt;/p&gt;

&lt;p&gt;由于模块间的数据访问目标地址要等到装载时才知道,只好通过got表来实现.elf的做法是数据段里面建立一个指向这些变量的指
针数组,也被称为全局偏移表(GOT),当代码需要引用模块间的数据时,可以通过GOT中相对应的项间接引用.(任何一条指令与GOT表
的距离是确定的,于是可通过上面b中相同方法找到GOT的地址,再根据GOT中变量对应的项找到变量的目标地址)&lt;/p&gt;

&lt;p&gt;d)模块间调用,跳转&lt;/p&gt;

&lt;p&gt;与上面c相同,只不过GOT中对应的内容由变量地址变成函数地址&lt;/p&gt;

&lt;p&gt;5.延迟绑定PLT&lt;/p&gt;

&lt;p&gt;在一个程序运行过程中,可能很多函数在程序执行完成时都不会被用到,比如一些错误处理函数或者是一些用户很少用到的功能模
块等,如果一开始就把所有函数都链接好实际上是一种浪费,所以elf采用了一种叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;延迟绑定&lt;/code&gt;的做法,基本思想就是当函数第一
次被用到时才进行绑定(符号查找,重定位),如果没有用到则不进行绑定,所以程序开始执行时,模块间的函数调用都没有进行绑定,
而是需要用到时才由动态链接器来钢表绑定,一般PLT是针对可执行文件(elf)而言的.&lt;/p&gt;

&lt;p&gt;在运行test前,test文件的put函数的plt内容很简单,直接jmp,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:000003B0                 jmp     ds:off_200C     ; PIC mode
.plt:000003B0 _puts           endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际运行test时,put函数的plt内容会发生变化,变成下面的样子:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565843B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565843B0 _puts endp
.plt:565843B0
.plt:565843B6
.plt:565843B6 ; =============== S U B R O U T I N E =======================================
.plt:565843B6
.plt:565843B6
.plt:565843B6 sub_565843B6 proc near                  ; CODE XREF: _puts↑j
.plt:565843B6                                         ; DATA XREF: .got.plt:5658600C↓o
.plt:565843B6 push    0
.plt:565843BB jmp     sub_565843A0

.plt:565843A0 push    dword ptr [ebx+4]
.plt:565843A6 jmp     dword ptr [ebx+8]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也即由jmp ds:off_200c变成jmp dword ptr [ebx+0ch],对应的机器码的变化是:
由ff 25 0c 20 00 00变成ff a3 0c 00 00 00
现在感到迷惑了,怎么会这样,plt表中的内容按道理不会变才对(plt表中的内容是代码),按理只有got表中的内容才会改变,使用
objdump查看下,发现与ida不同&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objdump -D test
    其中puts函数反汇编内容如下:
    000003b0 &amp;lt;puts@plt&amp;gt;:                                 
     3b0:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)
     3b6:   68 00 00 00 00          push   $0x0
     3bb:   e9 e0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;     

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明puts函数的plt表项内容没变,而ida中却在test运行前解析成其他内容了,这应该是ida的bug吧(实验中用的是macOS下的ida加
载的test文件,动态调试时用的是ida远程调试kali x64下的test),但是ida怎么会将[ebx+0ch]解析成ds:off_200c呢?用readelf查
看下test文件的重定位表如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;readelf -r test

重定位节 '.rel.dyn' 位于偏移量 0x328 含有 8 个条目:
 偏移量     信息    类型              符号值      符号名称
00001ef4  00000008 R_386_RELATIVE   
00001ef8  00000008 R_386_RELATIVE   
00001ff8  00000008 R_386_RELATIVE   
00002018  00000008 R_386_RELATIVE   
00001fec  00000106 R_386_GLOB_DAT    00000000   _ITM_deregisterTMClone
00001ff0  00000206 R_386_GLOB_DAT    00000000   __cxa_finalize@GLIBC_2.1.3
00001ff4  00000406 R_386_GLOB_DAT    00000000   __gmon_start__
00001ffc  00000606 R_386_GLOB_DAT    00000000   _ITM_registerTMCloneTa

重定位节 '.rel.plt' 位于偏移量 0x368 含有 2 个条目:
 偏移量     信息    类型              符号值      符号名称
0000200c  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
00002010  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出,其中puts函数的重定位项的偏移量是200c,猜测由于这个elf文件(test文件)有pie属性,而ida加载有pie属性的elf时是以
&lt;code class=&quot;highlighter-rouge&quot;&gt;加载基址=0&lt;/code&gt;加载的,于是ida解析出这个具有pie属性文件test的代码jmp [ebx+0ch]实际在运行时是jmp到与文件头初始处偏移
200c中存放的地址,从而ida将这里解析成jmp ds:200c了,并将机器码变成了ff 25 0c 20 00 00,实际上这里的机器码在运行前是
ff a3 0c 00 00 00.实际上从后面的分析可以知道,test在运行时会有第一次调用puts函数时的对puts函数的重定位,在重定位时
jmp [ebx+0ch]实际上是跳到下一条汇编指令的地址,而重定位后,jmp [ebx+0ch]指令不变,跳转到的位置会变成不再是下一条指
令的位置,而是完成重定位后的puts函数的地址,也即test文件偏移200c处(这个地方在.got.plt段中)的puts函数的.got.plt表项中
存放的内容,ida在test运行前就这样解析,可能是为了给用户忽略掉puts函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT延迟绑定&lt;/code&gt;的过程,让用户看起来程序在运行时
“更简洁”&lt;/p&gt;

&lt;p&gt;动态调试时ida的内容没问题.上面的plt中内容由于是在test未运行时在ida中加载看出的,这种情况”有误”,需要重新查看真实的
plt表中内容,直接查看运行后的ida中的test文件的plt表的内容:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3A0 ; ===========================================================================
.plt:565CC3A0
.plt:565CC3A0 ; Segment type: Pure code
.plt:565CC3A0 ; Segment permissions: Read/Execute
.plt:565CC3A0 _plt segment para public 'CODE' use32
.plt:565CC3A0 assume cs:_plt
.plt:565CC3A0 ;org 565CC3A0h
.plt:565CC3A0 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.plt:565CC3A0
.plt:565CC3A0 ; =============== S U B R O U T I N E =======================================
.plt:565CC3A0
.plt:565CC3A0
.plt:565CC3A0 sub_565CC3A0 proc near                  ; CODE XREF: sub_565CC3B6+5↓j
.plt:565CC3A0                                         ; .plt:565CC3CB↓j
.plt:565CC3A0 push    dword ptr [ebx+4]
.plt:565CC3A6 jmp     dword ptr [ebx+8]
.plt:565CC3A6 sub_565CC3A0 endp
.plt:565CC3A6
.plt:565CC3A6 ; ---------------------------------------------------------------------------
.plt:565CC3AC align 10h
.plt:565CC3B0
.plt:565CC3B0 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B0
.plt:565CC3B0 ; Attributes: thunk
.plt:565CC3B0
.plt:565CC3B0 ; int puts(const char *s)
.plt:565CC3B0 _puts proc near                         ; CODE XREF: print_banner+1D↓p
.plt:565CC3B0
.plt:565CC3B0 s= dword ptr  4
.plt:565CC3B0
.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
.plt:565CC3B0
.plt:565CC3B6
.plt:565CC3B6 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B6
.plt:565CC3B6
.plt:565CC3B6 sub_565CC3B6 proc near                  ; CODE XREF: _puts↑j
.plt:565CC3B6                                         ; DATA XREF: .got.plt:565CE00C↓o
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
.plt:565CC3BB sub_565CC3B6 endp
.plt:565CC3BB
.plt:565CC3C0 ; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
.plt:565CC3C6 ; ---------------------------------------------------------------------------
.plt:565CC3C6 push    8
.plt:565CC3CB jmp     sub_565CC3A0
.plt:565CC3CB _plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;objdump -D test中查看更简洁,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Disassembly of section .plt:               
                                                
000003a0 &amp;lt;.plt&amp;gt;:                                                  
 3a0:   ff b3 04 00 00 00       pushl  0x4(%ebx)   
 3a6:   ff a3 08 00 00 00       jmp    *0x8(%ebx)
 3ac:   00 00                   add    %al,(%eax)        
        ...                                
                                                
000003b0 &amp;lt;puts@plt&amp;gt;:                                 
 3b0:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)
 3b6:   68 00 00 00 00          push   $0x0
 3bb:   e9 e0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;     
                                     
000003c0 &amp;lt;__libc_start_main@plt&amp;gt;:  
 3c0:   ff a3 10 00 00 00       jmp    *0x10(%ebx)
 3c6:   68 08 00 00 00          push   $0x8
 3cb:   e9 d0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在PLT(延迟绑定)中,so中的函数只有在调用时才做重定位,运行时调用so中的函数时一般plt表项内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bar@plt的第一条指令是一条通过GOT间接跳转的指令.bar@GOT表示GOT中保存bar()这个函数相应的项.为了实现延迟绑定,链接器
在初始化阶段没有将bar()的地址走入到该项,而是将上面代码中第二条指令push n的地址地址填入到bar@GOT中,这个步骤不需要
查找任何符号,所以代价很低.也即,第一条指令的效果是跳转到第二条指令,相当于没有进行任何操作.然后将n和moudleID两个参
数压入栈中作为&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;的参数,其中n是bar这个符号引用在重定位表.rel.plt中的下标,&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;
函数在进行一系列工作年以后将bar()的真正地址填入到bar@GOT中.一旦bar()这个函数被解析完毕,当我们再次调用bar@plt时,
第一条jmp指令就能够跳转到真正的bar()函数中&lt;/p&gt;

&lt;p&gt;plt重定位过程图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc7.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重定位之后的调用图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc8.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在动态跟踪puts函数的重定位过程:&lt;/p&gt;

&lt;p&gt;a)跳转到plt表之前内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text:565CC53A call    _puts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;b)上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;call _puts&lt;/code&gt;在ida中f7之后跳转到.plt表,内容如下(eip=0x565cc3b0),对应指令为jmp dword ptr [ebx+0ch]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===&amp;gt;EIP=0x565cc3b0

.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
.plt:565CC3B0
.plt:565CC3B6
.plt:565CC3B6 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B6
.plt:565CC3B6
.plt:565CC3B6 sub_565CC3B6 proc near                  ; CODE XREF: _puts↑j
.plt:565CC3B6                                         ; DATA XREF: .got.plt:565CE00C↓o
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
.plt:565CC3BB sub_565CC3B6 endp
.plt:565CC3BB
.plt:565CC3C0 ; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
.plt:565CC3C6 ; ---------------------------------------------------------------------------
.plt:565CC3C6 push    8
.plt:565CC3CB jmp     sub_565CC3A0
.plt:565CC3CB _plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c)上一步动态调试发现jmp dword ptr [ebx+0xch]实际上就是跳到下一条指令处,也即跳到0x565cc3b6处的push 0,执行完
0x565cc3b6处的push 0之后会jmp到0x565cc3a0,而这个地址是plt表的起始地址,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3A0 push    dword ptr [ebx+4]
.plt:565CC3A6 jmp     dword ptr [ebx+8]
.plt:565CC3A6 sub_565CC3A0 endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d)在上面c中0x565cc3a6处的ebx+8在ida中的值为0x565ce008,0x565ce008处的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset sub_565CC3B6
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里是got表项,重定位将修改got表项中的值,目前0x565ce008这个got表项的内容是0xf7f5b700,也即0x565cc3a6处的jmp将跳转到
0xf7f5b700,0xf7f5b700处的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ld_2.24.so:F7F5B700 push    eax
ld_2.24.so:F7F5B701 push    ecx
ld_2.24.so:F7F5B702 push    edx
ld_2.24.so:F7F5B703 mov     edx, [esp+10h]
ld_2.24.so:F7F5B707 mov     eax, [esp+0Ch]
ld_2.24.so:F7F5B70B call    near ptr unk_F7F55000
ld_2.24.so:F7F5B710 pop     edx
ld_2.24.so:F7F5B711 mov     ecx, [esp]
ld_2.24.so:F7F5B714 mov     [esp], eax
ld_2.24.so:F7F5B717 mov     eax, [esp+4]
ld_2.24.so:F7F5B71B retn    0Ch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数了,联合&lt;code class=&quot;highlighter-rouge&quot;&gt;plt重定位过程图&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;重定位之后调用图&lt;/code&gt;可知,现在由于是puts函数第一次被调用,
正在进行puts函数(符号)的重定位,重定位之后会把got表项0x565ce008中的内容由原来的0xf7f5b700修改成puts函数的地址(这是
错误的想法,由于.got.plt结构特殊,实际并不会将0x565ce008处的内容修改,后面将看出),继续跟踪&lt;/p&gt;

&lt;p&gt;e)执行到上面0xf7f5b71b处的retn 0ch后,查看0x565ce008这个got表项内容有没有改变,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset _IO_puts
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现0x565ce008处的值不变,只是下0x565ce008+4=0x565ce00c处的函数名由原来的ida解析成的sub_565cc3b6变成ida解析成的
&lt;code class=&quot;highlighter-rouge&quot;&gt;IOputs&lt;/code&gt;,回忆下puts函数的重定位表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;重定位节 '.rel.plt' 位于偏移量 0x368 含有 2 个条目:
 偏移量     信息    类型              符号值      符号名称
0000200c  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
00002010  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;0x565ce00c实际是test在运行后的200c偏移(test在这次运行中实际加载基址为0x565ce00c-0x200c=0x565cc000),这
里的sub_565cc3b6实际上是上面c)中的plt表项中的jmp [ebx+0xc]的下一条指令的地址,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数中0xf7f5b71b处的retn 0ch后进入到_&lt;code class=&quot;highlighter-rouge&quot;&gt;IO_puts&lt;/code&gt;函数,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;libc_2.24.so:F7DB8890 _IO_puts:
libc_2.24.so:F7DB8890 push    ebp
libc_2.24.so:F7DB8891 mov     ebp, esp
libc_2.24.so:F7DB8893 push    edi
libc_2.24.so:F7DB8894 push    esi
libc_2.24.so:F7DB8895 push    ebx
libc_2.24.so:F7DB8896 call    near ptr unk_F7E79A25
libc_2.24.so:F7DB889B add     edi, 153765h
libc_2.24.so:F7DB88A1 sub     esp, 28h
libc_2.24.so:F7DB88A4 push    dword ptr [ebp+8]
libc_2.24.so:F7DB88A7 call    near ptr unk_F7DCECB0
libc_2.24.so:F7DB88AC mov     edx, [edi+0DFCh]
libc_2.24.so:F7DB88B2 mov     esi, eax
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也即&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数的地址为0xf7db8890,也即got表项中0x565ce008+4处的内容由0x565cc3b6变成了0xf7db8890,至此,完成了
puts函数的重定位,而此时查看plt表项中的代码,没有发生变化,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只是此时,ebx+0xch的值为0x565ce00c,而0x565ce00c中的内容已经由原来的0x565cc3b6变成了&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数的地址0xf7db8890,
也就是第一次调用puts函数后,以后从plt表项中的代码jmp到的地方不再会经过&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数,而是直接的
&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数了.也即证明重定位过程中plt中的代码是不会变的,只是在重定位后,plt中代码不变的情况下实际会取到got表项中
的其他值,这样也体现了PIC的原理(利用相对偏移跳转到函数).&lt;/p&gt;

&lt;p&gt;6.GOT表结构&lt;/p&gt;

&lt;p&gt;elf将GOT拆分成了两个表分别为.got和.got.plt,其中.got用来保存全局变量引用的地址,.got.plt用来保存函数引用的地址,也就
是说,所有对于外部函数的引用全部被分离出来放到了.got.plt中,另外,.got.plt还有一个特殊的地方是它的前三项是有特殊意义
的:&lt;/p&gt;

&lt;p&gt;第一项保存的是.dynamic段的地址
第二项保存的是本模块的ID
第三项保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve()&lt;/code&gt;的地址&lt;/p&gt;

&lt;p&gt;查看上面4中跟踪完puts函数的重定位后的.got.plt的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE000 assume cs:_got_plt
.got.plt:565CE000 ;org 565CE000h
.got.plt:565CE000 _GLOBAL_OFFSET_TABLE_ dd 1EFCh
.got.plt:565CE004 db  20h
.got.plt:565CE005 db 0A9h
.got.plt:565CE006 db 0F6h
.got.plt:565CE007 db 0F7h
.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset _IO_puts
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一项的值为0x565ce000,第二项的值为0xf7f6a920,第三项的值为0xf7f5b700(前3项为公共项),第四项开始为第一个函数项
(puts函数的地址)&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/05/%E7%90%86%E8%A7%A3%E9%87%8D%E5%AE%9A%E4%BD%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/05/%E7%90%86%E8%A7%A3%E9%87%8D%E5%AE%9A%E4%BD%8D/</guid>
        
        <category>重定位</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>设置上传目录不解析</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;设置上传目录不解析要怎样实现,之前一直以为是chmod -x uploads实现的,但是并不是这样&lt;/p&gt;

&lt;h3 id=&quot;0x01-linux的文件属性&quot;&gt;0x01 linux的文件属性&lt;/h3&gt;

&lt;p&gt;linux的文件夹和文件的属性特点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/resolve.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个文件有r属性,文件所在的文件夹也有r属性,但是文件所在文件夹没有x属性,那么这个文件是不能cat的,会提示权限不够,
这种情况下,如果再给文件赋予x属性,这个文件也是不能执行的,会提示权限不够,笔者认为是因为该文件所在的文件夹没有x属性
导致这个文件不可读,不可读的情况下,就算赋予x属性也是无法执行的&lt;/p&gt;

&lt;h3 id=&quot;0x02-设置上传目录不解析&quot;&gt;0x02 设置上传目录不解析&lt;/h3&gt;

&lt;p&gt;从上面看出,可通过chmod -x uploads让uploads目录下的webshell.php不解析,webshell.php不解析的原因是webshell.php对
apache用户www-data不可读(即使webshell.php的属性是644),webshell.php对apache用户www-data不可读的原因是uploads目录没
有x属性.但是这种通过chmod -x uploads的方法没有意义,因为这样虽然防住了webshell.php不解析,却也会导致正常的图片和其
他文件无法查看和使用&lt;/p&gt;

&lt;p&gt;真正的用法是通过httpd.conf(现在叫apache2.conf)或者.htaccess来实现,具体实现方法可参考&lt;a href=&quot;http://www.freebuf.com/articles/2465.html&quot;&gt;这里&lt;/a&gt;,.htaccess的更多用法
可参考&lt;a href=&quot;http://www.curafund.com/upload/download_file/1463483103.pdf&quot;&gt;这里&lt;/a&gt;,httpd.conf(apache2.conf)和.htaccess的关系可参考&lt;a href=&quot;http://m.itboth.com/d/RBvuy2/apache-.htaccess-cgi-include&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/12/01/%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%95%E4%B8%8D%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/12/01/%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%95%E4%B8%8D%E8%A7%A3%E6%9E%90/</guid>
        
        <category>upload</category>
        
        <category>webshell</category>
        
        
        <category>web</category>
        
      </item>
    
  </channel>
</rss>
