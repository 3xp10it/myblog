<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="https://www.w3.org/2005/Atom">
  <channel>
    <title>quanyechavshuo</title>
    <description>A blog about programming and network security</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 12 Dec 2017 17:55:42 +0800</pubDate>
    <lastBuildDate>Tue, 12 Dec 2017 17:55:42 +0800</lastBuildDate>
    <generator>Jekyll v3.4.2</generator>
    
      <item>
        <title>Android软件安全与逆向分析第3章笔记</title>
        <description>&lt;h3 id=&quot;进入android-dalvik虚拟机&quot;&gt;进入Android Dalvik虚拟机&lt;/h3&gt;

&lt;p&gt;1.虽然Android平台使用了Java语言来开发应用程序,但Android程序却不是运行在标准Java虚拟机上的,可能是为了解决移动设备
上软件运行效率的问题,也可能是为了规避与Oracle公司的版权纠纷.Google为Android平台专门设计了一套虚拟机来运行Android
程序,它就是Dalvik Virtual Machine(Dalvik虚拟机)&lt;/p&gt;

&lt;p&gt;2.Dalvik虚拟机作为Android平台的核心组件,拥有如下几个特点:&lt;/p&gt;

&lt;p&gt;a)体积小,占用内存空间小&lt;br /&gt;
b)专有的DEX可执行文件格式,体积更小,执行速度更快&lt;br /&gt;
c)常量池采用32位索引值,寻址类方法名,字段名,常量更快 
d)基于寄存器架构,并拥有一套完整的指令系统&lt;br /&gt;
e)提供了对象生命周期管理,堆栈管理,线程管理,安全和异常管理以及垃圾回收等重要功能&lt;br /&gt;
f)所有的Android程序都运行在Android系统进程里,每个进程对应着一个Dalvik虚拟机实例&lt;/p&gt;

&lt;p&gt;3.Dalvik虚拟机与Java虚拟机的区别&lt;/p&gt;

&lt;p&gt;a)Java虚拟机运行的是Java字节码,Dalvik虚拟机运行的是Dalvik字节码&lt;/p&gt;

&lt;p&gt;传统的Java程序经过编译,生成Java字节码保存在class文件中,Java虚拟机通过解码class文件中的内容来运行程序.而Dalvik虚拟
机运行的是Dalvik字节码,所有的Dalvik字节码由Java字节码转换而来,并被打包到一个DEX(Dalvik Executable)可执行文件中
.Dalvik虚拟机通过解释DEX文件来执行这些字节码&lt;/p&gt;

&lt;p&gt;b)Dalvik可执行文件体积更小&lt;/p&gt;

&lt;p&gt;Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码.dx工具对Java类文件重新排列,消除在类文件中出现的所
有冗余信息,避免虚拟机在初始化时出现反复的文件加载与解析过程.dx将所有的Java类文件中的常量池进行分解,消除其中的冗余
信息,重新组合形成一个常量池,所有的类文件共享同一个常量池&lt;/p&gt;

&lt;p&gt;c)Java虚拟机与Dalvik虚拟机虚拟机架构不同&lt;/p&gt;

&lt;p&gt;Java虚拟机基于栈架构.程序在运行时虚拟机需要频繁的从栈上读取或写入数据.Dalvik虚拟机基于寄存器架构,数据的访问通过寄
存器直接传递,这样的访问方式比基于栈方式要快很多,基于寄存器架构的Dalvik虚拟机与基于栈架构的Java虚拟机相比,由于生成
的代码指令减少了,程序执行速度会更快一些&lt;/p&gt;

&lt;p&gt;4.Android系统由Linux内核,函数库,Android运行时,应用程序框架以及应用程序组成.Dalvik虚拟机属于Android运行时环境,它与
一些核心库共同承担Android应用程序的运行工作&lt;/p&gt;

&lt;p&gt;5.JIT(Just-in-time Compilation,即时编译),双称为动态编译,是一种在运行时将字节码翻译为机器码的技术,使得程序的执行速
度更快.主流的JIT包含两种字节码编译方式:&lt;/p&gt;

&lt;p&gt;method方式:以函数或方法为单位进行编译,耗费更多的内存
trace方式:以trace为单位进行编译,耗费内存少,目前Dalvik虚拟机默认采用trace方式编译代码&lt;/p&gt;

&lt;p&gt;6.Dalvik虚拟机基于寄存器架构,在代码中大量地使用到了寄存器,Dalvik中用到的寄存器都是32位的,支持任何类型,64位类型用2
个相信寄存器表示,Dalvik支持2^16-1=65535个寄存器,寄存器采用v0作起始值,因此它的取值范围是v0~v65535.Dalvik虚拟机为每
个进程维护一个调用栈,这个调用栈其中一个作用就是用来”虚拟”寄存器,每个函数都在函数头部使用.registers指令指定函数用
到的寄存器数目,当虚拟机执行到这个函数时,会可以接收寄存器的数目分配适当的栈空间,这些栈空间就是用来存放寄存器实际的
值的.虚拟机通过处理字节码,对寄存器进入读与写的操作&lt;/p&gt;

&lt;p&gt;7.在Android4.0系统以前,每个指令的字节码只占用一个字节,范围是0x0~0xff.在Android4.0系统中,又扩充了一部分指令,这些指
令被称为扩展指令&lt;/p&gt;

&lt;p&gt;8.编译smali文件命令:&lt;code class=&quot;highlighter-rouge&quot;&gt;java -jar smali.jar -o output.dex input.smali&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/08/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/08/Android%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E4%B8%8E%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%AC%AC3%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>Android</category>
        
        <category>reverse</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>理解重定位</title>
        <description>&lt;h3 id=&quot;0x00-必读link&quot;&gt;0x00 必读link&lt;/h3&gt;

&lt;p&gt;1.书籍&lt;code class=&quot;highlighter-rouge&quot;&gt;程序员的自我修养&lt;/code&gt;中第4.2和7.3和7.4和7.5章节&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://www.zhihu.com/question/21249496&quot;&gt;Linux动态链接为什么要用PLT和GOT表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/&quot;&gt;共享库加载时重定位&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24231428&quot;&gt;pie/pic/aslr的理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/&quot;&gt;共享库中的PIC&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-预备知识&quot;&gt;0x01 预备知识&lt;/h3&gt;

&lt;p&gt;1.硬件对变量和函数的寻址方式不同,寻找变量要求绝对地址,寻找函数要求相对地址.&lt;/p&gt;

&lt;p&gt;call指令的偏移量计算方法:偏移量=跳转到的地址-call指令后一条指令的起始地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00413766    e8 7a da ff ff      call 00411e5
0041376b    ...                 ...

e8代表call,7a da ff ff代表偏移量0xffffda7a,对应负数-0x2586,0x0041376b+(-0x2586)=0x00411e5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.程序由编译(成汇编代码),链接(组合.o文件)得到可执行文件,重定位有链接时重定位+装载时重定位(上面必读link中叫load time
relocate),装载时重定位完成后得到的地址是虚拟存储器的虚拟地址,实际与内存交互时,需要由内核再完成虚拟存储器的虚拟
地址到真实物理内存地址的转换.&lt;/p&gt;

&lt;p&gt;4.编译阶段,.o文件的全局变量位置不确定,因为这时无法确定还有其它哪些.o文件,以及链接器将来会按什么顺序”排列”这些.o文
件,所以编译阶段没有重定位,链接阶段,如果elf没有调用so中的符号,则可以在链接时重定位所有符号的地址(因为这时所有的.o
文件的数据段代码段都组合完成了,所有符号的偏移都是确定的),如果elf调用了so中的符号,则由于so文件的符号位置不确定,因为
这时不知道.so文件将来被加载到进程空间的什么位置,所以与so中符号有关的地址需要装载时重定位.&lt;/p&gt;

&lt;p&gt;5.在没有开启pie的情况下:elf如果没有调用so则不用装载时重定位.elf如果没有调用so则没有plt表(有got表).so(elf)通过
plt+got来实现pic(pie).plt表中的内容是代码,got表中的内容是数据(各种符号的地址)&lt;/p&gt;

&lt;p&gt;6.一般情况下,exe的期望加载基址为0x400000(4M),dll为0x1000000(16M),elf为0x8048000(约128M),so为0x40000000(1G),期望加
载基址由编译器指定,在可执行文件中有一个位置存放这个值&lt;/p&gt;

&lt;p&gt;7.查看elf有没有开pie可简单通过readelf -l elffile看出,对应如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Elf 文件类型为 DYN (共享目标文件)       ===&amp;gt;对应开启了pie
Elf 文件类型为 EXEC (可执行文件)        ===&amp;gt;对应未开启pie
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.实际情况中,对有PIE保护的elf,ida静态分析时会以加载基址=0加载,angr在加载这样的elf时会以加载基址=0x400000加载到虚
拟内存中进行符号执行,也即angr会强制将有pie保护的elf加载到0x400000处去,这样就相当于去掉了pie的每次加载基址不同
(aslr)的特性&lt;/p&gt;

&lt;p&gt;9.plt和got示例(linux下这样叫,macOS下有其他名字)&lt;/p&gt;

&lt;p&gt;如下图中printf函数是外部so文件中的函数,于是需要有plt和got,从左边的printf,puts,atoi等函数看出,一般只有外部so文件中
的函数调用才会用到plt,在下图ida中,发现plt段在.init段之后,.text段之前&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;printf函数的plt表中内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:080483C0
.plt:080483C0 ; =============== S U B R O U T I N E =======================================
.plt:080483C0
.plt:080483C0 ; Attributes: thunk
.plt:080483C0
.plt:080483C0 ; int printf(const char *format, ...)
.plt:080483C0 _printf         proc near               ; CODE XREF: main+2C↓p
.plt:080483C0
.plt:080483C0 format          = dword ptr  4
.plt:080483C0
.plt:080483C0                 jmp     ds:off_804A000
.plt:080483C0 _printf         endp
.plt:080483C0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;printf函数对应的got表中内容如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中的got表被ida解析了,ida指出0x804A000处的内容是printf函数的偏移,实际在16进制模式下的内容如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也即在0x804A000这个地址中的值为0x804A030,也即got表中对应内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x804A000:0x804A030
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个0x804A030在运行后会被因为重定位被修改成其他值,因为实际运行时printf函数的地址应该会变成不再是0x404A030了&lt;/p&gt;

&lt;h3 id=&quot;0x02-链接时重定位&quot;&gt;0x02 链接时重定位&lt;/h3&gt;

&lt;p&gt;如果没涉及so函数调用,则只通过链接时重定位即可完成重定位,不需要装载时重定位,由链接器单独完成重定位,下面进入操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;works in x86 kali linux

vi a.c

    /* a.c */
    extern int shared;

    int main()
    {
        int a = 100;
        swap(&amp;amp;a,&amp;amp;shared);
    }

vi b.c

    /* b.c */
    int shared = 1;

    void swap(int* a,int* b)
    {
        *a ^= *b ^= *a ^= *b;
    }

gcc -c a.c b.c 
    编译得到a.o和b.o目标文件

ld a.o b.o -e main -o ab
    链接a.o和b.o,设置输出文件为ab,设置main函数为入口

objdump -h a.o
    a.o:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         0000004a  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000000  00000000  00000000  00000086  2**0
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000086  2**0

objdump -h b.o
    b.o:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .group        00000008  00000000  00000000  00000034  2**2
                      CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
      1 .text         00000043  00000000  00000000  0000003c  2**0
                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
      2 .data         00000004  00000000  00000000  00000080  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .bss          00000000  00000000  00000000  00000084  2**0

objdump -h ab
    ab:     文件格式 elf32-i386

    节:
    Idx Name          Size      VMA       LMA       File off  Algn
      0 .text         00000091  08048094  08048094  00000094  2**0
                      CONTENTS, ALLOC, LOAD, READONLY, CODE
      1 .eh_frame     00000080  08048128  08048128  00000128  2**2
                      CONTENTS, ALLOC, LOAD, READONLY, DATA
      2 .got.plt      0000000c  0804a000  0804a000  00001000  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      3 .data         00000004  0804a00c  0804a00c  0000100c  2**2
                      CONTENTS, ALLOC, LOAD, DATA
      4 .comment      00000026  00000000  00000000  00001010  2**0

      VMA表示虚拟存储器的虚拟地址,由上可以看出,在链接之前,所有段的VMA都是0,在链接后出现了got表.且got表中的内容全
      为0,如下:
            .got.plt:0804A000 ; ===========================================================================
            .got.plt:0804A000
            .got.plt:0804A000 ; Segment type: Pure data
            .got.plt:0804A000 ; Segment permissions: Read/Write
            .got.plt:0804A000 _got_plt        segment dword public 'DATA' use32
            .got.plt:0804A000                 assume cs:_got_plt
            .got.plt:0804A000                 ;org 804A000h
            .got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd 0              ; DATA XREF: LOAD:0804805C↑o
            .got.plt:0804A000                                         ; swap+10↑r ...
            .got.plt:0804A004                 db    0
            .got.plt:0804A005                 db    0
            .got.plt:0804A006                 db    0
            .got.plt:0804A007                 db    0
            .got.plt:0804A008                 db    0
            .got.plt:0804A009                 db    0
            .got.plt:0804A00A                 db    0
            .got.plt:0804A00B                 db    0
            .got.plt:0804A00B _got_plt        ends
            .got.plt:0804A00B
            .data:0804A00C ; ===========================================================================
      如果在链接前就产生了got表的话,可以通过在编译时直接在需要重定位的地方写上got表项的地址中的指针指向的值来达到
      plt表的功能,如:
      mov var,[[0x0804A000]]   
      其中0x0804A000是一个got表项的地址.这样的话(在链接前就产生了got表)就可以省去plt表了,因为plt表的作用就是找到
      got表中的地址.当然这里的elf文件ab没有plt表,因为不涉及so文件中符号的使用.

objdump -d a.o
    a.o:     文件格式 elf32-i386
    Disassembly of section .text:
    00000000 &amp;lt;main&amp;gt;:
       0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
       4:	83 e4 f0             	and    $0xfffffff0,%esp
       7:	ff 71 fc             	pushl  -0x4(%ecx)
       a:	55                   	push   %ebp
       b:	89 e5                	mov    %esp,%ebp
       d:	53                   	push   %ebx
       e:	51                   	push   %ecx
       f:	83 ec 10             	sub    $0x10,%esp
      12:	e8 fc ff ff ff       	call   13 &amp;lt;main+0x13&amp;gt;
      17:	05 01 00 00 00       	add    $0x1,%eax
      1c:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
      23:	83 ec 08             	sub    $0x8,%esp
      26:	8b 90 00 00 00 00    	mov    0x0(%eax),%edx   ===&amp;gt;shared变量
      2c:	52                   	push   %edx
      2d:	8d 55 f4             	lea    -0xc(%ebp),%edx
      30:	52                   	push   %edx
      31:	89 c3                	mov    %eax,%ebx
      33:	e8 fc ff ff ff       	call   34 &amp;lt;main+0x34&amp;gt;   ===&amp;gt;swap函数
      38:	83 c4 10             	add    $0x10,%esp
      3b:	b8 00 00 00 00       	mov    $0x0,%eax
      40:	8d 65 f8             	lea    -0x8(%ebp),%esp
      43:	59                   	pop    %ecx
      44:	5b                   	pop    %ebx
      45:	5d                   	pop    %ebp
      46:	8d 61 fc             	lea    -0x4(%ecx),%esp
      49:	c3                   	ret    

      如上反汇编代码中,在a.c编译成a.o时,编译器不知道shared变量和swap函数的地址,因为它们定义在其他目标文件中
      (b.o),所以编译器就暂时把地址0看作是shared的地址,同样将call指令的目标地址的位置当作call的目标地址
      (0xfffffffc=-4,0x38-0x4=0x34,相当于call自己),也即在编译阶段,编译器把这两个待重定位的值分别写成0x00000000和
      0xfffffffc,把真正的地址计算工作留给了链接器,链接器在完成地址和空间分配之后就已经可以确定所有符号的虚拟地址
      了(因为这里未涉及so的调用),那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正.

objdump -d ab
    ab:     文件格式 elf32-i386
    Disassembly of section .text:

    08048094 &amp;lt;main&amp;gt;:
     8048094:	8d 4c 24 04          	lea    0x4(%esp),%ecx
     8048098:	83 e4 f0             	and    $0xfffffff0,%esp
     804809b:	ff 71 fc             	pushl  -0x4(%ecx)
     804809e:	55                   	push   %ebp
     804809f:	89 e5                	mov    %esp,%ebp
     80480a1:	53                   	push   %ebx
     80480a2:	51                   	push   %ecx
     80480a3:	83 ec 10             	sub    $0x10,%esp
     80480a6:	e8 33 00 00 00       	call   80480de &amp;lt;__x86.get_pc_thunk.ax&amp;gt;
     80480ab:	05 55 1f 00 00       	add    $0x1f55,%eax
     80480b0:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%ebp)
     80480b7:	83 ec 08             	sub    $0x8,%esp
     80480ba:	c7 c2 0c a0 04 08    	mov    $0x804a00c,%edx      ===&amp;gt;shared变量
     80480c0:	52                   	push   %edx
     80480c1:	8d 55 f4             	lea    -0xc(%ebp),%edx
     80480c4:	52                   	push   %edx
     80480c5:	89 c3                	mov    %eax,%ebx
     80480c7:	e8 16 00 00 00       	call   80480e2 &amp;lt;swap&amp;gt;       ===&amp;gt;swap函数
     80480cc:	83 c4 10             	add    $0x10,%esp
     80480cf:	b8 00 00 00 00       	mov    $0x0,%eax
     80480d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
     80480d7:	59                   	pop    %ecx
     80480d8:	5b                   	pop    %ebx
     80480d9:	5d                   	pop    %ebp
     80480da:	8d 61 fc             	lea    -0x4(%ecx),%esp
     80480dd:	c3                   	ret    

     由ab文件的反汇编代码可以看出,经过链接阶段的修正后,shared变量和swap函数的地址分别为0x804a00c和0x00000016.
     链接器通过重定位表来对shared和swap的地址重定位,对于每个要重定位的elf段都有一个对应的重定位段(重定位表),比如
     代码段.text如有要重定位的地方,那么会有一个相应叫.rel.text的段保存了代码段的重定位表,如果代码段.data有要重定
     位的地方,那么会有一个相应叫.rel.data的段保存了数据段的重定位表,可以通过objdump -r或readelf -r查看目标文件的
     重定位表,objdump -r可查看.o文件的重定位位,无法查看elf文件的重定位表,如果要查看elf文件的重定位表要使用readelf
     -r elffile,在.o文件中重定位段分别为.rel.text和.rel.data的段在elf(so)文件中的名称为.rel.plt和.rel.dyn,其中
     .rel.plt是对函数的引用的修正,它所修正的位置位于.got.plt;其中.rel.dyn是对数据引用的修正,它所修正的位置位于
     .got以及数据段.

     .o文件:(查看方法:objdump|readelf -r xxx.o)
     .rel.text&amp;lt;===&amp;gt;代码段重定位表
     .rel.data&amp;lt;===&amp;gt;数据段重定位表

     elf(so)文件:(查看方法:readelf -r elffile)
    .rel.plt&amp;lt;===&amp;gt;代码段重定位表,对函数引用的修正,修正的位置位于.got.plt
    .rel.dyn&amp;lt;===&amp;gt;数据段重定位表,对数据引用的修正,修正的位置位于.got以及数据段

objdump -r a.o
    a.o:     文件格式 elf32-i386
    RELOCATION RECORDS FOR [.text]:
    OFFSET   TYPE              VALUE 
    00000013 R_386_PC32        __x86.get_pc_thunk.ax
    00000018 R_386_GOTPC       _GLOBAL_OFFSET_TABLE_
    00000028 R_386_GOT32X      shared
    00000034 R_386_PLT32       swap

    由上看出shared和swap是不同的重定位类型,下面是不同重定位类型的不同计算重定位值的方法.
    容易想到,变量和函数的计算重定位值的算法是不同的,因为函数一般用相对地址,变量用绝对地址.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc4.png&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ab文件不涉及so的调用,所以链接时重定位就可以完成重定位的工作了,证明如下,在gdb加载ab文件后,分别查看main的地址
,main+0x28,main+0x34中的内容发现与运行前(链接后)链接器认为的地址一致,具体如下:

gdb ab
p main
    $1 = {&amp;lt;text variable, no debug info&amp;gt;} 0x8048094 &amp;lt;main&amp;gt;
x main+0x28
    (gdb) x main+0x28
    0x80480bc &amp;lt;main+40&amp;gt;:	0x0804a00c
x main+0x34
    (gdb) x main+0x34
    0x80480c8 &amp;lt;main+52&amp;gt;:	0x00000016
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x03-装载时重定位&quot;&gt;0x03 装载时重定位&lt;/h3&gt;

&lt;p&gt;1.场景&lt;/p&gt;

&lt;p&gt;以上链接时重定位可以完成没有调用so文件的代码的重定位工作,如果涉及到so中符号的调用,则需要装载时重定位来完成与调用
so符号相关代码的重定位工作,因为在可执行文件加载so前是不知道so的加载基址的,重定位与so符号相关的值这项工作需要装载
时重定位完成.&lt;/p&gt;

&lt;p&gt;实例:(works in kali x64)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/* test.c */
#include &amp;lt;stdio.h&amp;gt;

void print_banner()
{
    printf(&quot;Welcome to World of PLT and GOT\n&quot;);
}

int main(void)
{
    print_banner();

    return 0;
}

由于实验在x64的kali系统下进行,要编译32位的elf需要先安装依赖,上面的链接时重定位的内容是在x86的kali上做的实验,而这
里是在x64上做的实验,原因是做这个实验时旁边没有x86的机器.
    apt-get install gcc-multilib
    apt-get install g++-multilib

编译:gcc -Wall -g -o test.o -c test.c -m32
链接:gcc -o test test.o -m32
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.普通的装载时重定位&lt;/p&gt;

&lt;p&gt;为了能够使so可以在任意地址装载,可以通过在链接时对所有绝对地址的引用不作重定位,而把这一步推迟到装载时再完成.一旦
模块装载地址确定,即目标地址确定,那么系统就对程序中所有的绝对地址引用进行重定位.假设函数foobar相对于代码段的起始地
址是0x100,当模块被装载到0x10000000时,假设代码段位于模块的最开始,那么可以确定foobar的地址为0x10000100,这时候,系统
遍历模块中的重定位表,把所有对foobar的地址引用都重定位到0x10000100.但是由于这种普通的装载时重定位存在一些问题,现在
的操作系统一般使用pie|pic技术&lt;/p&gt;

&lt;p&gt;3.PIC(特殊的装载时重定位)&lt;/p&gt;

&lt;p&gt;PIC:程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变,通过把指令中的那些需要修改的部分分离出来,跟数据
部分放在一起,这样指令部分就可以保持不变,而数据部分可以在每个进程中拥有一个副本,这种方案就是目前被称为
&lt;code class=&quot;highlighter-rouge&quot;&gt;地址无关代码&lt;/code&gt;技术,PIC是对动态链接库(so)而言的,可执行文件(elf)对应的技术叫PIE.&lt;/p&gt;

&lt;p&gt;在test.c得到的test文件,查看test文件有没有使用到pie(现在gcc一般默认开启了pie选项):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./checksec -f test
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FORTIFY Fortified Fortifiable  FILE
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   No      0       0test

说明开启了pie
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用ida打开test,双击print_banner函数,可以看到对应的反汇编代码如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双击其中的so中的put函数(也即对应test.c中的printf函数),可以看到ida中的注释&lt;code class=&quot;highlighter-rouge&quot;&gt;PIC mode&lt;/code&gt;,说明printf对应的so库采用了PIC
技术:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.怎样实现PIC?&lt;/p&gt;

&lt;p&gt;a)模块内部的函数调用,跳转&lt;/p&gt;

&lt;p&gt;这种情况下是最简单的,直接使用相对地址调用或者基于寄存器的相对调用即可,所以对于这种指令是不需要重定位的&lt;/p&gt;

&lt;p&gt;b)模块内部数据访问&lt;/p&gt;

&lt;p&gt;指令中不能直接包含数据的绝对地址,于是只能用相对寻址.&lt;code class=&quot;highlighter-rouge&quot;&gt;__i686.get_pc_thunk.cx&lt;/code&gt;函数可以获取当前汇编指令的下一条指令
的地址,会将这个地址放到ecx寄存器,即把&lt;code class=&quot;highlighter-rouge&quot;&gt;call __i686.get_pc_thunk.cx&lt;/code&gt;下一条指令的地址放到ecx中.由于任何一条指令与它
需要访问的模块内部的数据之间的距离是确定的,结合这个函数,可实现模块内部数据访问的相对寻址.如下在test文件中的
&lt;code class=&quot;highlighter-rouge&quot;&gt;__x86_get_pc_thunk_ax&lt;/code&gt;函数,作用是将下一条指令的地址放到ax中.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push    ebp
mov     ebp, esp
push    ebx
sub     esp, 4
call    __x86_get_pc_thunk_ax
add     eax, 1AD7h
sub     esp, 0Ch
lea     edx, (aWelcomeToWorld - 2000h)[eax] ; &quot;Welcome to World of PLT and GOT&quot;
push    edx             ; s
mov     ebx, eax
call    _puts
add     esp, 10h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__x86_get_pc_thunk_ax&lt;/code&gt;的实现很简单,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public __x86_get_pc_thunk_ax
__x86_get_pc_thunk_ax proc near
; __unwind {
mov     eax, [esp+0]
retn
; } // starts at 576
__x86_get_pc_thunk_ax endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c)模块间数据访问&lt;/p&gt;

&lt;p&gt;由于模块间的数据访问目标地址要等到装载时才知道,只好通过got表来实现.elf的做法是数据段里面建立一个指向这些变量的指
针数组,也被称为全局偏移表(GOT),当代码需要引用模块间的数据时,可以通过GOT中相对应的项间接引用.(任何一条指令与GOT表
的距离是确定的,于是可通过上面b中相同方法找到GOT的地址,再根据GOT中变量对应的项找到变量的目标地址)&lt;/p&gt;

&lt;p&gt;d)模块间调用,跳转&lt;/p&gt;

&lt;p&gt;与上面c相同,只不过GOT中对应的内容由变量地址变成函数地址&lt;/p&gt;

&lt;p&gt;5.延迟绑定PLT&lt;/p&gt;

&lt;p&gt;在一个程序运行过程中,可能很多函数在程序执行完成时都不会被用到,比如一些错误处理函数或者是一些用户很少用到的功能模
块等,如果一开始就把所有函数都链接好实际上是一种浪费,所以elf采用了一种叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;延迟绑定&lt;/code&gt;的做法,基本思想就是当函数第一
次被用到时才进行绑定(符号查找,重定位),如果没有用到则不进行绑定,所以程序开始执行时,模块间的函数调用都没有进行绑定,
而是需要用到时才由动态链接器来钢表绑定,一般PLT是针对可执行文件(elf)而言的.&lt;/p&gt;

&lt;p&gt;在运行test前,test文件的put函数的plt内容很简单,直接jmp,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:000003B0                 jmp     ds:off_200C     ; PIC mode
.plt:000003B0 _puts           endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际运行test时,put函数的plt内容会发生变化,变成下面的样子:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565843B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565843B0 _puts endp
.plt:565843B0
.plt:565843B6
.plt:565843B6 ; =============== S U B R O U T I N E =======================================
.plt:565843B6
.plt:565843B6
.plt:565843B6 sub_565843B6 proc near                  ; CODE XREF: _puts↑j
.plt:565843B6                                         ; DATA XREF: .got.plt:5658600C↓o
.plt:565843B6 push    0
.plt:565843BB jmp     sub_565843A0

.plt:565843A0 push    dword ptr [ebx+4]
.plt:565843A6 jmp     dword ptr [ebx+8]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也即由jmp ds:off_200c变成jmp dword ptr [ebx+0ch],对应的机器码的变化是:
由ff 25 0c 20 00 00变成ff a3 0c 00 00 00
现在感到迷惑了,怎么会这样,plt表中的内容按道理不会变才对(plt表中的内容是代码),按理只有got表中的内容才会改变,使用
objdump查看下,发现与ida不同&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objdump -D test
    其中puts函数反汇编内容如下:
    000003b0 &amp;lt;puts@plt&amp;gt;:                                 
     3b0:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)
     3b6:   68 00 00 00 00          push   $0x0
     3bb:   e9 e0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;     

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明puts函数的plt表项内容没变,而ida中却在test运行前解析成其他内容了,这应该是ida的bug吧(实验中用的是macOS下的ida加
载的test文件,动态调试时用的是ida远程调试kali x64下的test),但是ida怎么会将[ebx+0ch]解析成ds:off_200c呢?用readelf查
看下test文件的重定位表如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;readelf -r test

重定位节 '.rel.dyn' 位于偏移量 0x328 含有 8 个条目:
 偏移量     信息    类型              符号值      符号名称
00001ef4  00000008 R_386_RELATIVE   
00001ef8  00000008 R_386_RELATIVE   
00001ff8  00000008 R_386_RELATIVE   
00002018  00000008 R_386_RELATIVE   
00001fec  00000106 R_386_GLOB_DAT    00000000   _ITM_deregisterTMClone
00001ff0  00000206 R_386_GLOB_DAT    00000000   __cxa_finalize@GLIBC_2.1.3
00001ff4  00000406 R_386_GLOB_DAT    00000000   __gmon_start__
00001ffc  00000606 R_386_GLOB_DAT    00000000   _ITM_registerTMCloneTa

重定位节 '.rel.plt' 位于偏移量 0x368 含有 2 个条目:
 偏移量     信息    类型              符号值      符号名称
0000200c  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
00002010  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出,其中puts函数的重定位项的偏移量是200c,猜测由于这个elf文件(test文件)有pie属性,而ida加载有pie属性的elf时是以
&lt;code class=&quot;highlighter-rouge&quot;&gt;加载基址=0&lt;/code&gt;加载的,于是ida解析出这个具有pie属性文件test的代码jmp [ebx+0ch]实际在运行时是jmp到与文件头初始处偏移
200c中存放的地址,从而ida将这里解析成jmp ds:200c了,并将机器码变成了ff 25 0c 20 00 00,实际上这里的机器码在运行前是
ff a3 0c 00 00 00.实际上从后面的分析可以知道,test在运行时会有第一次调用puts函数时的对puts函数的重定位,在重定位时
jmp [ebx+0ch]实际上是跳到下一条汇编指令的地址,而重定位后,jmp [ebx+0ch]指令不变,跳转到的位置会变成不再是下一条指
令的位置,而是完成重定位后的puts函数的地址,也即test文件偏移200c处(这个地方在.got.plt段中)的puts函数的.got.plt表项中
存放的内容,ida在test运行前就这样解析,可能是为了给用户忽略掉puts函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;PLT延迟绑定&lt;/code&gt;的过程,让用户看起来程序在运行时
“更简洁”&lt;/p&gt;

&lt;p&gt;动态调试时ida的内容没问题.上面的plt中内容由于是在test未运行时在ida中加载看出的,这种情况”有误”,需要重新查看真实的
plt表中内容,直接查看运行后的ida中的test文件的plt表的内容:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3A0 ; ===========================================================================
.plt:565CC3A0
.plt:565CC3A0 ; Segment type: Pure code
.plt:565CC3A0 ; Segment permissions: Read/Execute
.plt:565CC3A0 _plt segment para public 'CODE' use32
.plt:565CC3A0 assume cs:_plt
.plt:565CC3A0 ;org 565CC3A0h
.plt:565CC3A0 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.plt:565CC3A0
.plt:565CC3A0 ; =============== S U B R O U T I N E =======================================
.plt:565CC3A0
.plt:565CC3A0
.plt:565CC3A0 sub_565CC3A0 proc near                  ; CODE XREF: sub_565CC3B6+5↓j
.plt:565CC3A0                                         ; .plt:565CC3CB↓j
.plt:565CC3A0 push    dword ptr [ebx+4]
.plt:565CC3A6 jmp     dword ptr [ebx+8]
.plt:565CC3A6 sub_565CC3A0 endp
.plt:565CC3A6
.plt:565CC3A6 ; ---------------------------------------------------------------------------
.plt:565CC3AC align 10h
.plt:565CC3B0
.plt:565CC3B0 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B0
.plt:565CC3B0 ; Attributes: thunk
.plt:565CC3B0
.plt:565CC3B0 ; int puts(const char *s)
.plt:565CC3B0 _puts proc near                         ; CODE XREF: print_banner+1D↓p
.plt:565CC3B0
.plt:565CC3B0 s= dword ptr  4
.plt:565CC3B0
.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
.plt:565CC3B0
.plt:565CC3B6
.plt:565CC3B6 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B6
.plt:565CC3B6
.plt:565CC3B6 sub_565CC3B6 proc near                  ; CODE XREF: _puts↑j
.plt:565CC3B6                                         ; DATA XREF: .got.plt:565CE00C↓o
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
.plt:565CC3BB sub_565CC3B6 endp
.plt:565CC3BB
.plt:565CC3C0 ; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
.plt:565CC3C6 ; ---------------------------------------------------------------------------
.plt:565CC3C6 push    8
.plt:565CC3CB jmp     sub_565CC3A0
.plt:565CC3CB _plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;objdump -D test中查看更简洁,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Disassembly of section .plt:               
                                                
000003a0 &amp;lt;.plt&amp;gt;:                                                  
 3a0:   ff b3 04 00 00 00       pushl  0x4(%ebx)   
 3a6:   ff a3 08 00 00 00       jmp    *0x8(%ebx)
 3ac:   00 00                   add    %al,(%eax)        
        ...                                
                                                
000003b0 &amp;lt;puts@plt&amp;gt;:                                 
 3b0:   ff a3 0c 00 00 00       jmp    *0xc(%ebx)
 3b6:   68 00 00 00 00          push   $0x0
 3bb:   e9 e0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;     
                                     
000003c0 &amp;lt;__libc_start_main@plt&amp;gt;:  
 3c0:   ff a3 10 00 00 00       jmp    *0x10(%ebx)
 3c6:   68 08 00 00 00          push   $0x8
 3cb:   e9 d0 ff ff ff          jmp    3a0 &amp;lt;.plt&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在PLT(延迟绑定)中,so中的函数只有在调用时才做重定位,运行时调用so中的函数时一般plt表项内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bar@plt的第一条指令是一条通过GOT间接跳转的指令.bar@GOT表示GOT中保存bar()这个函数相应的项.为了实现延迟绑定,链接器
在初始化阶段没有将bar()的地址走入到该项,而是将上面代码中第二条指令push n的地址地址填入到bar@GOT中,这个步骤不需要
查找任何符号,所以代价很低.也即,第一条指令的效果是跳转到第二条指令,相当于没有进行任何操作.然后将n和moudleID两个参
数压入栈中作为&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;的参数,其中n是bar这个符号引用在重定位表.rel.plt中的下标,&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;
函数在进行一系列工作年以后将bar()的真正地址填入到bar@GOT中.一旦bar()这个函数被解析完毕,当我们再次调用bar@plt时,
第一条jmp指令就能够跳转到真正的bar()函数中&lt;/p&gt;

&lt;p&gt;plt重定位过程图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc7.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重定位之后的调用图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/reloc8.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在动态跟踪puts函数的重定位过程:&lt;/p&gt;

&lt;p&gt;a)跳转到plt表之前内容如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.text:565CC53A call    _puts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;b)上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;call _puts&lt;/code&gt;在ida中f7之后跳转到.plt表,内容如下(eip=0x565cc3b0),对应指令为jmp dword ptr [ebx+0ch]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===&amp;gt;EIP=0x565cc3b0

.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
.plt:565CC3B0
.plt:565CC3B6
.plt:565CC3B6 ; =============== S U B R O U T I N E =======================================
.plt:565CC3B6
.plt:565CC3B6
.plt:565CC3B6 sub_565CC3B6 proc near                  ; CODE XREF: _puts↑j
.plt:565CC3B6                                         ; DATA XREF: .got.plt:565CE00C↓o
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
.plt:565CC3BB sub_565CC3B6 endp
.plt:565CC3BB
.plt:565CC3C0 ; [00000006 BYTES: COLLAPSED FUNCTION ___libc_start_main. PRESS CTRL-NUMPAD+ TO EXPAND]
.plt:565CC3C6 ; ---------------------------------------------------------------------------
.plt:565CC3C6 push    8
.plt:565CC3CB jmp     sub_565CC3A0
.plt:565CC3CB _plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;c)上一步动态调试发现jmp dword ptr [ebx+0xch]实际上就是跳到下一条指令处,也即跳到0x565cc3b6处的push 0,执行完
0x565cc3b6处的push 0之后会jmp到0x565cc3a0,而这个地址是plt表的起始地址,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3A0 push    dword ptr [ebx+4]
.plt:565CC3A6 jmp     dword ptr [ebx+8]
.plt:565CC3A6 sub_565CC3A0 endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d)在上面c中0x565cc3a6处的ebx+8在ida中的值为0x565ce008,0x565ce008处的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset sub_565CC3B6
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里是got表项,重定位将修改got表项中的值,目前0x565ce008这个got表项的内容是0xf7f5b700,也即0x565cc3a6处的jmp将跳转到
0xf7f5b700,0xf7f5b700处的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ld_2.24.so:F7F5B700 push    eax
ld_2.24.so:F7F5B701 push    ecx
ld_2.24.so:F7F5B702 push    edx
ld_2.24.so:F7F5B703 mov     edx, [esp+10h]
ld_2.24.so:F7F5B707 mov     eax, [esp+0Ch]
ld_2.24.so:F7F5B70B call    near ptr unk_F7F55000
ld_2.24.so:F7F5B710 pop     edx
ld_2.24.so:F7F5B711 mov     ecx, [esp]
ld_2.24.so:F7F5B714 mov     [esp], eax
ld_2.24.so:F7F5B717 mov     eax, [esp+4]
ld_2.24.so:F7F5B71B retn    0Ch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数了,联合&lt;code class=&quot;highlighter-rouge&quot;&gt;plt重定位过程图&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;重定位之后调用图&lt;/code&gt;可知,现在由于是puts函数第一次被调用,
正在进行puts函数(符号)的重定位,重定位之后会把got表项0x565ce008中的内容由原来的0xf7f5b700修改成puts函数的地址(这是
错误的想法,由于.got.plt结构特殊,实际并不会将0x565ce008处的内容修改,后面将看出),继续跟踪&lt;/p&gt;

&lt;p&gt;e)执行到上面0xf7f5b71b处的retn 0ch后,查看0x565ce008这个got表项内容有没有改变,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset _IO_puts
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现0x565ce008处的值不变,只是下0x565ce008+4=0x565ce00c处的函数名由原来的ida解析成的sub_565cc3b6变成ida解析成的
&lt;code class=&quot;highlighter-rouge&quot;&gt;IOputs&lt;/code&gt;,回忆下puts函数的重定位表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;重定位节 '.rel.plt' 位于偏移量 0x368 含有 2 个条目:
 偏移量     信息    类型              符号值      符号名称
0000200c  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
00002010  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;0x565ce00c实际是test在运行后的200c偏移(test在这次运行中实际加载基址为0x565ce00c-0x200c=0x565cc000),这
里的sub_565cc3b6实际上是上面c)中的plt表项中的jmp [ebx+0xc]的下一条指令的地址,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B6 push    0
.plt:565CC3BB jmp     sub_565CC3A0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数中0xf7f5b71b处的retn 0ch后进入到_&lt;code class=&quot;highlighter-rouge&quot;&gt;IO_puts&lt;/code&gt;函数,内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;libc_2.24.so:F7DB8890 _IO_puts:
libc_2.24.so:F7DB8890 push    ebp
libc_2.24.so:F7DB8891 mov     ebp, esp
libc_2.24.so:F7DB8893 push    edi
libc_2.24.so:F7DB8894 push    esi
libc_2.24.so:F7DB8895 push    ebx
libc_2.24.so:F7DB8896 call    near ptr unk_F7E79A25
libc_2.24.so:F7DB889B add     edi, 153765h
libc_2.24.so:F7DB88A1 sub     esp, 28h
libc_2.24.so:F7DB88A4 push    dword ptr [ebp+8]
libc_2.24.so:F7DB88A7 call    near ptr unk_F7DCECB0
libc_2.24.so:F7DB88AC mov     edx, [edi+0DFCh]
libc_2.24.so:F7DB88B2 mov     esi, eax
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也即&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数的地址为0xf7db8890,也即got表项中0x565ce008+4处的内容由0x565cc3b6变成了0xf7db8890,至此,完成了
puts函数的重定位,而此时查看plt表项中的代码,没有发生变化,如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.plt:565CC3B0 jmp     dword ptr [ebx+0Ch]             ; PIC mode
.plt:565CC3B0 _puts endp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只是此时,ebx+0xch的值为0x565ce00c,而0x565ce00c中的内容已经由原来的0x565cc3b6变成了&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数的地址0xf7db8890,
也就是第一次调用puts函数后,以后从plt表项中的代码jmp到的地方不再会经过&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve&lt;/code&gt;函数,而是直接的
&lt;code class=&quot;highlighter-rouge&quot;&gt;_IO_puts&lt;/code&gt;函数了.也即证明重定位过程中plt中的代码是不会变的,只是在重定位后,plt中代码不变的情况下实际会取到got表项中
的其他值,这样也体现了PIC的原理(利用相对偏移跳转到函数).&lt;/p&gt;

&lt;p&gt;6.GOT表结构&lt;/p&gt;

&lt;p&gt;elf将GOT拆分成了两个表分别为.got和.got.plt,其中.got用来保存全局变量引用的地址,.got.plt用来保存函数引用的地址,也就
是说,所有对于外部函数的引用全部被分离出来放到了.got.plt中,另外,.got.plt还有一个特殊的地方是它的前三项是有特殊意义
的:&lt;/p&gt;

&lt;p&gt;第一项保存的是.dynamic段的地址
第二项保存的是本模块的ID
第三项保存的是&lt;code class=&quot;highlighter-rouge&quot;&gt;_dl_runtime_resolve()&lt;/code&gt;的地址&lt;/p&gt;

&lt;p&gt;查看上面4中跟踪完puts函数的重定位后的.got.plt的内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.got.plt:565CE000 assume cs:_got_plt
.got.plt:565CE000 ;org 565CE000h
.got.plt:565CE000 _GLOBAL_OFFSET_TABLE_ dd 1EFCh
.got.plt:565CE004 db  20h
.got.plt:565CE005 db 0A9h
.got.plt:565CE006 db 0F6h
.got.plt:565CE007 db 0F7h
.got.plt:565CE008 db    0
.got.plt:565CE009 db 0B7h
.got.plt:565CE00A db 0F5h
.got.plt:565CE00B db 0F7h
.got.plt:565CE00C dd offset _IO_puts
.got.plt:565CE010 dd offset __libc_start_main
.got.plt:565CE010 _got_plt ends
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一项的值为0x565ce000,第二项的值为0xf7f6a920,第三项的值为0xf7f5b700(前3项为公共项),第四项开始为第一个函数项
(puts函数的地址)&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/05/%E7%90%86%E8%A7%A3%E9%87%8D%E5%AE%9A%E4%BD%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/05/%E7%90%86%E8%A7%A3%E9%87%8D%E5%AE%9A%E4%BD%8D/</guid>
        
        <category>重定位</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>设置上传目录不解析</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;设置上传目录不解析要怎样实现,之前一直以为是chmod -x uploads实现的,但是并不是这样&lt;/p&gt;

&lt;h3 id=&quot;0x01-linux的文件属性&quot;&gt;0x01 linux的文件属性&lt;/h3&gt;

&lt;p&gt;linux的文件夹和文件的属性特点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/resolve.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个文件有r属性,文件所在的文件夹也有r属性,但是文件所在文件夹没有x属性,那么这个文件是不能cat的,会提示权限不够,
这种情况下,如果再给文件赋予x属性,这个文件也是不能执行的,会提示权限不够,笔者认为是因为该文件所在的文件夹没有x属性
导致这个文件不可读,不可读的情况下,就算赋予x属性也是无法执行的&lt;/p&gt;

&lt;h3 id=&quot;0x02-设置上传目录不解析&quot;&gt;0x02 设置上传目录不解析&lt;/h3&gt;

&lt;p&gt;从上面看出,可通过chmod -x uploads让uploads目录下的webshell.php不解析,webshell.php不解析的原因是webshell.php对
apache用户www-data不可读(即使webshell.php的属性是644),webshell.php对apache用户www-data不可读的原因是uploads目录没
有x属性.但是这种通过chmod -x uploads的方法没有意义,因为这样虽然防住了webshell.php不解析,却也会导致正常的图片和其
他文件无法查看和使用&lt;/p&gt;

&lt;p&gt;真正的用法是通过httpd.conf(现在叫apache2.conf)或者.htaccess来实现,具体实现方法可参考&lt;a href=&quot;http://www.freebuf.com/articles/2465.html&quot;&gt;这里&lt;/a&gt;,.htaccess的更多用法
可参考&lt;a href=&quot;http://www.curafund.com/upload/download_file/1463483103.pdf&quot;&gt;这里&lt;/a&gt;,httpd.conf(apache2.conf)和.htaccess的关系可参考&lt;a href=&quot;http://m.itboth.com/d/RBvuy2/apache-.htaccess-cgi-include&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/web/2017/12/01/%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%95%E4%B8%8D%E8%A7%A3%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/web/2017/12/01/%E8%AE%BE%E7%BD%AE%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%95%E4%B8%8D%E8%A7%A3%E6%9E%90/</guid>
        
        <category>upload</category>
        
        <category>webshell</category>
        
        
        <category>web</category>
        
      </item>
    
      <item>
        <title>老码识途第2章笔记</title>
        <description>&lt;h3 id=&quot;庖丁解码底层的力量与乐趣&quot;&gt;庖丁解码:底层的力量与乐趣&lt;/h3&gt;

&lt;p&gt;1.全局变量或字符串常量等数据存放在程序的数据段&lt;/p&gt;

&lt;p&gt;2.jmp的机器码是eb,jz的机器码是74&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/01/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/12/01/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>老码识途</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>老码识途第1章笔记</title>
        <description>&lt;h3 id=&quot;欲向码途问大道锵锵bit是吾刀&quot;&gt;欲向码途问大道,锵锵bit是吾刀&lt;/h3&gt;

&lt;p&gt;1.c语言中嵌入的汇编能够识别高级语言中的符号,如变量address&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int i,gi;
void * address{
    _asm {
    mov address,offset _lb1
    jmp address
    }
    i=2;
_lb1:
    gi=12;
    
}


                            jmp address
004113C8 ff 25 cc 74 41 00  jmp dword ptr ds:[004174cch]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.指针的类型信息(dword ptr,word ptr,byte ptr…)决定了赋值/读取时写/读多少字节.读/写多少字节的信息不是存放在指针
变量中,而是放到了与该地址相关的赋值指令中,如&lt;code class=&quot;highlighter-rouge&quot;&gt;mov dword ptr [eax],0ch&lt;/code&gt;中的dword指明了这个信息.不同类型指针,访问字
节数不同,&lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt;访问4字节,&lt;code class=&quot;highlighter-rouge&quot;&gt;short *&lt;/code&gt;访问2字节,这样就方便我们操控一个地址,否则如果只有地址信息,每次访问它还要附加说
明访问的字节数.这时,我们也能理解指针加/减1不是加/减1字节,而是加/减长度为该指针指向类型的长度的字节数,我们也能理解
,&lt;code class=&quot;highlighter-rouge&quot;&gt;void *&lt;/code&gt;类型的指针为什么无法进行加减运算,因为它只是汇编语言中的地址,没有类型信息,加减的时候不知道加减多少字节&lt;/p&gt;

&lt;p&gt;3.强制类型转换中有2点:&lt;/p&gt;

&lt;p&gt;a)不能将一个&lt;code class=&quot;highlighter-rouge&quot;&gt;short *&lt;/code&gt;指针变量赋值给&lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt;变量,因为生成赋值语句的指令时,必然生成move dword指令,即写4字节,而&lt;code class=&quot;highlighter-rouge&quot;&gt;short
*&lt;/code&gt;的变量只有2字节`&lt;/p&gt;

&lt;p&gt;b)指针强制类型转换的影响不是在转换的时候发生,在转换时除了赋值地址没有多余动作,起效的时是在用转换后的身份去访问内
存的时候,编译器会按转换后的指针类型产生相应代码,如下打印的结果是0xcccc000c而不是0c.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int *pi;
short si=12;
pi=(int *)&amp;amp;si;
printf(&quot;%x&quot;,*pi);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.计算负数值方法:取反加1&lt;/p&gt;

&lt;p&gt;5.call指令的偏移量计算方法:偏移量=跳转到的地址-call指令后一条指令的起始地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00413766    e8 7a da ff ff      call 00411e5
0041376b    ...                 ...

e8代表call,7a da ff ff代表偏移量0xffffda7a,对应负数-0x2586,0x0041376b+(-0x2586)=0x00411e5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.call指令相当于以下2条指令,在调用call之前要先push函数参数(x86),如push 1,push2,call 0x0402848,所以可以理解:在当前
函数帧栈中,第1个参数的位置在ebp+8处,因为ebp+4处的内容是call之前push的返回地址.在使用了ebp寻址的函数中,ebp+偏移量
是参数的地址,ebp-偏移量是局部变量的地址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;push 返回地址
jmp 函数入口
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7._cdecl是调用方清理栈,_pascal,_fastcall和_stdcall是被调用方清理栈.c语言缺省调用惯例是_cdecl,_stdcall通常用于
win32 API.&lt;a href=&quot;https://www.cnblogs.com/john-h/p/6276828.html&quot;&gt;更多&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.函数指针赋值的原则是:只能将与指针原型匹配的函数的入口地址赋值给它,因为不同的函数的调用约定不一定相同,如上面的7
中所示&lt;/p&gt;

&lt;p&gt;9.数组的第1个元素的索引从0开始的原因&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;索引从1开始:

第1个元素的地址=首地址a
第2个元素的地址=首地址a+1x元素大小
第3个元素的地址=首地址a+2x元素大小
第i个元素的地址=首地址a+(i-1)x元素大小

索引从0开始:

第0个元素的地址=首地址a
第1个元素的地址=首地址a+1x元素大小
第2个元素的地址=首地址a+2x元素大小
第i个元素的地址=首地址a+(i)x元素大小
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;10.从上面9中也理解了c语言为什么会发生数组越界错误,因为它只是拿到首部地址然后加偏移量,如果索引值超出范围,那么求得
的元素地址也就超过了范围&lt;/p&gt;

&lt;p&gt;11.一般情况下,网络字节顺序是大端,主机字节顺序是小端&lt;/p&gt;

&lt;p&gt;12.内存中字节对齐的规律&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;首先选定一个盒子,然后依序将字段往盒子中放,当盒子放不下后,又用下一个盒子存放,直至所有字段都存放完毕.

相关限制条件:
a)盒子长度=min{max{sizeof(成员变量)},对齐长度}
b)字段放入盒子的可放置位置如下:
    离盒子头部偏移字节数=nxsizeof(成员变量)     (n=0,1,2,...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;13.为了让结构体更整齐以便于在不同字节序程序间传递,我们就尽量调整结构体的字段顺序,在没办法的情况下,可考虑主动添加
一些字段,防止计算机为了对齐而填充&lt;/p&gt;

&lt;p&gt;14.一般情况下,switch比if-else快&lt;/p&gt;

&lt;p&gt;15.ga,ge,gb…中ab无符号,gl有符号&lt;/p&gt;

&lt;p&gt;16.在cpu保护模式下,每个执行进程(程序的一个实例)都拥有自己独立的线性地址空间,这种机制叫虚存系统&lt;/p&gt;

&lt;p&gt;17.完成加载程序并将eip寄存器的值指向main()入口的程序称为加载器&lt;/p&gt;

&lt;p&gt;18.重定位与模块绑定&lt;a href=&quot;http://blog.csdn.net/ithzhang/article/details/7058576&quot;&gt;理解&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;relocAddr=actualBase+a
* relocAddr=*relocAddr+actualBase-expectedAddr
eg.在exe中,一般expectedAddr为0x400000(4M),dll为0x1000000(16M),在一个有重定位段的pe中,有多个a,如a=0x100,a=0x502,
表示在pe的偏移0x100,0x502处的4字节值需要修改为原来的值+(实际加载基址与期望加载基址的差)

一般elf的expectedAddr为0x8048000(约128M),linux共享库的expectedAddr为0x40000000(1G)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的expectedAddr可通过ida加载一个elf,查看ida中的进度条最开始位置的地址,这个地址即是elf期望的加载基址,如下图期望
加载基址为0x8048000&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/lmst1-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;或者通过linux下的工具readelf -l elffile查看,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/lmst1-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;20.vtune是一个收费$899的性能分析工具(可下载破解版),python下免费的其他工具可参考&lt;a href=&quot;https://www.cnblogs.com/nisen/p/6076082.html&quot;&gt;这里1&lt;/a&gt;,&lt;a href=&quot;https://github.com/rkern/line_profiler&quot;&gt;这里2&lt;/a&gt;,&lt;a href=&quot;https://github.com/pythonprofilers/memory_profiler&quot;&gt;这里3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;21.学习汇编的方法:用汇编实现开发环境所带的运行时库中的函数,如c语言中的strlen,strcpy等.然后,分析系统库实现的这些函
数.因为它们调用频繁,所以要求有很高的效率,基本都用汇编撰写.好好阅读能学到很多高级技巧,(能从高手的经典中汲取到很多营
养),再做性能实验,测试自己版本与系统版本的差异,并分析修改(这一过程可用vtune在优化方面深入实战),最后分析不同库实现
的异同和好坏,如vc,c++ builder,delphi,gcc&lt;/p&gt;

&lt;p&gt;22.一个技巧:判断一个数能否被4整除可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;test xxx,3    je ...&lt;/code&gt;实现&lt;/p&gt;

&lt;p&gt;23.对于&lt;code class=&quot;highlighter-rouge&quot;&gt;_declspec(naked) int strlen2(char *str)&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;_declspec(naked)&lt;/code&gt;属于vc的特殊关键字,表示该函数的左右括号不会生
成任何代码,此时strlen2()的代码就是汇编本身&lt;/p&gt;

</description>
        <pubDate>Thu, 30 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/11/30/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/11/30/%E8%80%81%E7%A0%81%E8%AF%86%E9%80%94%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>老码识途</category>
        
        
        <category>二进制</category>
        
      </item>
    
      <item>
        <title>kali linux安装源的问题</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;新下载的kali linux 3在安装pd的paralles tools时需要安装&lt;code class=&quot;highlighter-rouge&quot;&gt;linux-headers-$(uname -r)&lt;/code&gt;,于是apt-get update,出现了经典的
基于debain的系统的安装源的问题,如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/3xp10it/pic/master/kali3.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-必读link&quot;&gt;0x01 必读link&lt;/h3&gt;

&lt;p&gt;debain安装源地址语法&lt;a href=&quot;http://www.cnblogs.com/beanmoon/p/3387652.html&quot;&gt;理解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get update&lt;/code&gt; Hash 校验和不符等错误的原因&lt;br /&gt;
&lt;a href=&quot;http://www.kali.org.cn/thread-23272-1-1.html&quot;&gt;1&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://forum.ubuntu.org.cn/viewtopic.php?t=473765&quot;&gt;2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x02-解决方法&quot;&gt;0x02 解决方法&lt;/h3&gt;

&lt;p&gt;1.理解debain安装源地址格式语法后,设置正确的源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kali官方debain源:
http://http.kali.org/

需要在sources.list文件中如下设置:
deb http://http.kali.org/ kali-rolling main contrib non-free
其中main contrib non-free的顺序可变
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.&lt;a href=&quot;http://blog.csdn.net/theonegis/article/details/59142193&quot;&gt;这里&lt;/a&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get update -o Acquire-by-hash=yes -o Acquire::https::No-Cache=True -o Acquire::http::No-Cache=True&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.手机开个热点或换个wifi或开vpn之后重新&lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get update&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;4.解决安装源的问题后如果再安装paralles tools还有问题可按照&lt;a href=&quot;http://kb.parallels.com/en/123968&quot;&gt;这里&lt;/a&gt;解决&lt;/p&gt;

&lt;p&gt;5.如果上面4中的链接没有成功安装,则升级paralleles desktop,实际安装中,由paralleles12升级为paralleles13.2.0后再按照上面3中的链接可成功安装&lt;/p&gt;

</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/linux/2017/11/27/kali-linux%E5%AE%89%E8%A3%85%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2017/11/27/kali-linux%E5%AE%89%E8%A3%85%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>kali</category>
        
        <category>debain</category>
        
        <category>sources.list</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>流畅的python第2章笔记</title>
        <description>&lt;h3 id=&quot;序列构成的数组&quot;&gt;序列构成的数组&lt;/h3&gt;

&lt;p&gt;1.列表推导是一种构建列表的方法,它异常强大,掌握列表推导还可以为我们打开生成器表达式的大门,后者具有生成各种类型的元
素并用它们来填充序列的功能&lt;/p&gt;

&lt;p&gt;2.通常的原则是,只用列表推导来创建新的列表,并且尽量保持简短.如果列表推导的代码超过了两行,你可能就要考虑是不是利用
for循环重写了&lt;/p&gt;

&lt;p&gt;3.列表推导示例:&lt;code class=&quot;highlighter-rouge&quot;&gt;tshirts=[(color,size) for color in colors for size in sizes]&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/11/21/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/11/21/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC2%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>流畅的python第1章笔记</title>
        <description>&lt;h3 id=&quot;python数据模型&quot;&gt;Python数据模型&lt;/h3&gt;

&lt;p&gt;1.doctest模块是测试代码中在注释内的以&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;开头的所在行的python语句正确性的模块&lt;/p&gt;

&lt;p&gt;2.特殊方法的存在是为了被python解释器调用的,你自己不需要调用它.例如,没有&lt;code class=&quot;highlighter-rouge&quot;&gt;my_obj.__len__()&lt;/code&gt;这种写法,而应该用
&lt;code class=&quot;highlighter-rouge&quot;&gt;len(my_obj)&lt;/code&gt;,在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;len(my_obj)&lt;/code&gt;时,如果&lt;code class=&quot;highlighter-rouge&quot;&gt;my_obj&lt;/code&gt;是一个自定义类的对象,那么python会自己调用其中由你实现的
&lt;code class=&quot;highlighter-rouge&quot;&gt;__len__&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;3.如果是python内置类型,如list,str,bytearray(字节序列),那么CPython会抄近路,&lt;code class=&quot;highlighter-rouge&quot;&gt;__len__&lt;/code&gt;实际上会直接返回PyVarObject里
的&lt;code class=&quot;highlighter-rouge&quot;&gt;ob_size&lt;/code&gt;属性,直接读取这个值比调用一个方法要快很多&lt;/p&gt;

&lt;p&gt;4.很多时候,特殊方法是隐式的,比如&lt;code class=&quot;highlighter-rouge&quot;&gt;for i in x:&lt;/code&gt;这个语句,背后其实用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;iter(x)&lt;/code&gt;,而这个函数的背后则是
&lt;code class=&quot;highlighter-rouge&quot;&gt;x.__iter__()&lt;/code&gt;方法,当然前提是这个方法在x中被实现了&lt;/p&gt;

&lt;p&gt;5.Python有个内置函数&lt;code class=&quot;highlighter-rouge&quot;&gt;repr&lt;/code&gt;,它能把一个对象用字符串的形式表达出来以便辨认,这就是”字符串表示形式”,repr就是通过
&lt;code class=&quot;highlighter-rouge&quot;&gt;__repr__&lt;/code&gt;这个特殊方法来得到一个对象的字符表示形式的,如果没有实现&lt;code class=&quot;highlighter-rouge&quot;&gt;__repr__&lt;/code&gt;,当我们在控制台里打印一个向量的实例时,
得到的字符串可能会是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Vector object at 0x10e100070&amp;gt;&lt;/code&gt;.通常eval(repr(obj))和obj是等同的.&lt;code class=&quot;highlighter-rouge&quot;&gt;%r&lt;/code&gt;可获取对象各个属性的标
准字符串表示形式.&lt;/p&gt;

&lt;p&gt;6.&lt;code class=&quot;highlighter-rouge&quot;&gt;repr()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;str()&lt;/code&gt;的对比:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;repr()得到的结果是给python看的,方便调试和记录日志
str()得到的结果是用户看的,方便给终端用户看
如果一个对象没有__str__函数,而python又需要调用它时,解释器会用__repr__作为替代

import datetime
d=datetime.date.today()
print(&quot;%s&quot; % d)
print(&quot;%r&quot; % d)

输出:
2017-11-20
datetime.date(2017,11,20)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7.bool(x)的背后是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;x.__bool__()&lt;/code&gt;的结果;如果不存在&lt;code class=&quot;highlighter-rouge&quot;&gt;__bool__&lt;/code&gt;方法,那么bool(x)会尝试调用&lt;code class=&quot;highlighter-rouge&quot;&gt;x.__len__()&lt;/code&gt;,若返回0,则
bool会返回False,否则返回True.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;None==[]==()=={}==False?    ====&amp;gt; 不是的
而是:
bool(None)==bool([])=bool(())==bool({})==False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8.在python中,输入import this会弹出python之禅&lt;/p&gt;

&lt;p&gt;9.len之所以不是一个普通的方法,是为了让python自带的数据结构可以走后门,因为如果x是一个内置类型的实例,那么len(x)会通
过CPython直接从一个C结构体里读取对象的长度得到,完全不会调用任何方法,获取一个集合中元素的数量是一个很常见的操作,在
str,list,memoryview等类型上,这个操作必须高效&lt;/p&gt;

&lt;p&gt;10.通过实现特殊方法,自定义数据类型可以表现得跟内置类型一样,从而让我们写出更具表达力的代码.如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class FrenchDeck:
    ranks=[str(n) for n in range(2,11)]+list('JQKA')
    suits='spades diamonds clubs hearts'.split()

    def __init__(self):
        self.cards=...

    def __len__(self):
        return len(self._cards)

    def __getitem__(self,position):
        return self._cards[position]
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;11.python的&lt;a href=&quot;http://blog.csdn.net/yuan_j_y/article/details/9317817&quot;&gt;四个魔法方法&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/python/2017/11/20/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/11/20/%E6%B5%81%E7%95%85%E7%9A%84python%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>python</category>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Linux内核源代码情景分析第1章笔记</title>
        <description>&lt;h3 id=&quot;预备知识&quot;&gt;预备知识&lt;/h3&gt;

&lt;p&gt;1.在安装好的linux系统中,内核源代码位于/usr/src/linux.如果是从gnu网站下载的linux内核的tar文件,则展开以后在一个叫
linux的子目录中.&lt;/p&gt;

&lt;p&gt;2.linux的源代码看似庞大,其实对于每一个具体的内核而言并不是所有的.c和.h文件都会用到,而是在编译(包括连接)时根据系统
的配置有选择地使用&lt;/p&gt;

&lt;p&gt;3.在版本号x.yy.zz中,yy一方面表示版本的变迁,一方面标志着版本的种类,即”发行版”或”开发版”.如果yy为偶数便表示一个相对
稳定,已经发行的版本,如果为奇数则表示还在开发中.”发行版”和”开发版”的zz是独立编号的,因此并没有固定的对应关系,例如,
当开发版本号达到2.3.99时,相应的发行版还只是2.2.18&lt;/p&gt;

&lt;p&gt;4.linux的内核基本上只有一种来源,那就是同Linus主持开发和维护的内核版本,但是有很多公司在发行linux操作系统不同的发行
版,如Red Hat,Caldera等等.原则上全世界只有一个linux,所谓”某某linux”只是它的一种发行版本或修订版本.另外,不要把Linux
内核的版本与发行商自己的版本(如”Red Hat6.0”)混淆,例如,Caldera2.2版的内核是2.2.5版&lt;/p&gt;

&lt;p&gt;5.对于大多数用户,由发行商提供的这些发行版起着十分重要的作用.让用户自行配置和生成整个系统是相当困难的,因为那样用户
不但要自己下载内核源程序,自己编译安装,还要从不同的ftp站点下载各种自由软件添加到自己的系统中,还要为系统加入各种有
用的工具,等等.而所有这些工作都是很费时费力的事情.linux的发行厂商正是看到了这一点,替用户做了这些工作,在内核上集成
了大量的应用软件.并且,为了安装软件,发行厂商同时还提供了用于软件安装的工具性软件,以利于用户安装管理.(apt-get/yum)&lt;/p&gt;

&lt;p&gt;6.&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/linux/2017/11/20/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/linux/2017/11/20/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90%E7%AC%AC1%E7%AB%A0%E7%AC%94%E8%AE%B0/</guid>
        
        <category>kernel</category>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>angr解题</title>
        <description>&lt;h3 id=&quot;0x00-about&quot;&gt;0x00 About&lt;/h3&gt;

&lt;p&gt;1.kali linux安装angr&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get install python-dev libffi-dev build-essential virtualenvwrapper
mkvirtualenv angr &amp;amp;&amp;amp; pip install angr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.必读link&lt;/p&gt;

&lt;p&gt;1)&lt;a href=&quot;http://www.freebuf.com/articles/web/150296.html&quot;&gt;用法小结&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2)&lt;a href=&quot;http://angr.io/api-doc&quot;&gt;api文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3)&lt;a href=&quot;https://hitcon.org/2016/CMT/slide/day1-r1-a-1.pdf&quot;&gt;进阶文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;0x01-注意&quot;&gt;0x01 注意&lt;/h3&gt;

&lt;p&gt;1.获取程序的输出的值的方法为&lt;code class=&quot;highlighter-rouge&quot;&gt;ex.found[0].posix.dumps(1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.如果程序不能从开头执行(如:开头损坏),则可用&lt;code class=&quot;highlighter-rouge&quot;&gt;state = p.factory.blank_state(addr=xxx)&lt;/code&gt;,从开头运行则可用
&lt;code class=&quot;highlighter-rouge&quot;&gt;p.factory.entry_state&lt;/code&gt;,更多的state运行方法参考&lt;a href=&quot;https://github.com/angr/angr-doc/blob/master/docs/states.md&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.目前的理解是find是到哪里停,avoid是不能经过哪,在解题时,avoid可没有,find必需有,但是最好两者都有,这样可减少符号执
行的计算量&lt;/p&gt;

&lt;p&gt;4.通过字符串设置find方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;pg.explore(find=lambda s:&quot;it is my secret&quot; ins.posix.dumps(1))&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.claripy的BVS函数可以创建一个指定长度的抽象数据,如下,要注意的是:BVS的第2个参数的大小是位数,不是字节数,claripy的
功能与z3相当&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import claripy
a = claripy.BVS(&quot;sym_val&quot;, 32)
b = claripy.RotateLeft(a, 8)
c = b + 4
s = claripy.Solver()
s.add(c == 0x41424344)
assert s.eval(c, 1)[0] == 0x41424344
assert s.eval(a, 1)[0] == 0x40414243
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;0x02-解题&quot;&gt;0x02 解题&lt;/h3&gt;

&lt;h4 id=&quot;0xa-命令行参数&quot;&gt;0xa 命令行参数&lt;/h4&gt;

&lt;p&gt;从命令行提供程序参数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p = angr.Project('./ais3_crackme')
arg1=claripy.BVS('arg1',30*8)
state=p.factory.entry_state(args=[p.filename,arg1])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后获取命令行参数值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arg1=ex.found[0].solver.eval(arg1,cast_to = str)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/cosmopolitanme/article/details/73284074&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import angr
import claripy
find = 0x400602
avoid = [0x40060e]

p = angr.Project('./ais3_crackme')
arg1 = claripy.BVS('arg1', 30 * 8)
state = p.factory.entry_state(args=[p.filename, arg1])

ex = p.factory.simgr(state)
ex.explore(find=find, avoid=avoid)

arg1 = ex.found[0].solver.eval(arg1, cast_to=str)
print(arg1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xb-标准输入&quot;&gt;0xb 标准输入&lt;/h4&gt;

&lt;p&gt;从标准输入中提供程序参数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;state.posix.files[0].read_from(30)
或
for _ in xrange(5):  
    k = state.posix.files[0].read_from(1)
    state.se.add(k!=10)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后获取标准输入值:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;inp = ex.found[0].posix.files[0].all_bytes()  
print ex.found[0].solver.eval(inp,cast_to = str)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://oj.xctf.org.cn/web/practice/defensetrain/465f6bb8f4ad4d65a70cce2bd69dfacf/&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import angr
find = (0x8048697,)
avoid = (0x804869e,)

p = angr.Project('./ppp')
state = p.factory.entry_state()
state.posix.files[0].read_from(50)

pg = p.factory.simgr(state, threads=8)
ex = pg.explore(find=find, avoid=avoid)

output = ex.found[0].posix.dumps(1)
print(output)
inp = ex.found[0].posix.files[0].all_bytes()
print ex.found[0].solver.eval(inp, cast_to=str)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;0xc-文件输入&quot;&gt;0xc 文件输入&lt;/h4&gt;

&lt;p&gt;从文件中提供程序’参数’&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://ctfhacker.com/re/angr/2016/02/21/ctf-symbolic-execution.html&quot;&gt;题目地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解法:&lt;/p&gt;

&lt;p&gt;to be continue…&lt;/p&gt;

</description>
        <pubDate>Thu, 16 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/11/16/angr%E8%A7%A3%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/11/16/angr%E8%A7%A3%E9%A2%98/</guid>
        
        <category>angr</category>
        
        <category>符号执行</category>
        
        
        <category>二进制</category>
        
      </item>
    
  </channel>
</rss>
